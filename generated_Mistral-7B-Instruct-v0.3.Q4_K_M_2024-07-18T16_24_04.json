[
    {
        "instruction": "Can you provide an example of how to update a row in Actian 4GL SQL using the update statement?",
        "input": "",
        "output": "Here's an example of how to update a single row in a table \"employees\" where the employee_id is '001':\n```sql\nupdate employees set salary = 5000 where employee_id = '001';\n```",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->database_procedures",
        "task_description": "Explain the database procedures in Actian 4GL SQL and how they are used in OpenROAD.",
        "document": [
            "# Update Statement\n\nThis statement updates the values of the columns in a database table.\n\nThis statement has the following syntax:\n\n- Non-cursor version:\n  ```\n  [repeated] update tablename [corrname]\n       [from fromclause]\n       set columnname = dbexpression {, columnname =\n                 dbexpression}\n       [where searchcondition];\n  ```\n- Cursor version:\n  ```\n  update tablename set columnname = dbexpression\n       {, columnname = dbexpression} where current of\n            cursor_variable;\n  ```\n\nwhere fromclause has the following alternative syntaxes:\n```\nfrom tablename [corrname]{, tablename [corrname]}\nfrom :fromvariable\n```\n\nThe update statement modifies the values in columns in a database table.\n\nThe tablename identifies the table that you want to update and must match the table name specified in the open statement for the specified cursor.\n\nEach column that you include in the update statement must also have been specified in the for update clause of the open statement that opened the cursor.\n\nThe optional corrname defines a correlation name for the table. Correlation names provide a shorthand way to refer to tables in a query.\n\nThe optional repeated keyword directs the DBMS to encode and save the query execution plan for the statement. This is a performance enhancement if you intend to execute this statement more than once.\n\nNote: Do not use the repeated keyword if you place the entire where clause, searchcondition, in a single variable or if a table name or column name is represented by a dynamic name.\n\n## Parameters--Update Statement\n\nThis statement has the following parameters:\n\n- tablename: Specifies the name of the database table that you want to update. This is a dynamic name.\n- corrname: Specifies the correlation name for the table. This is a dynamic name. This parameter is used only in the non-cursor version.\n- columnname: Specifies the name of a particular column to be updated in the table. This is a dynamic name.\n- dbexpression: Specifies a database expression\n- searchcondition: Specifies a logical database expression of conditions that must be satisfied by all rows selected. You can use simple variables (preceded by colons) in a search condition wherever you can use a literal. Alternatively, you can place the entire search condition in a single varchar variable, and specify the search condition as the name of this variable (proceeded by a colon). This parameter is only used in the non-cursor version.\n- cursor_variable: Specifies the reference variable that points to the CursorObject for which the statement is issued. Used only in the cursor version.\n- fromvariable: Specifies the entire from clause as a single varchar variable, preeded by a colon. This is a dynamic name.\n\n### Set Clause\n\nThe set clause specifies the columns in the table that you want to update.\n\n### Where Clause\n\nIf you do not include a where clause, OpenROAD updates all of the rows in the table. If you include a where clause, OpenROAD updates only the rows in the table that satisfy searchcondition in the where clause.\n\nThe \"where current of\" clause directs OpenROAD to update the row on which the specified cursor is positioned. The cursor_variable must point to a CursorObject that you opened using a for update clause.\n\n## Update Mode\n\nThe update mode of the cursor, specified when you opened the cursor, affects how you can use the update statement. You can open a cursor for deferred or direct update.\n\n### Deferred Mode\n\nWith deferred mode cursors, you can perform only one operation against each row. This operation can be an update or a delete but not both. Similarly, you cannot use the repeated option with a deferred update cursor. Cursors that are opened for direct update do not have these restrictions. However, if the cursor is a direct update cursor and you perform two cursor updates that are not separated by a fetch statement, you can update the same row twice.\n\nAfter a successful update, OpenROAD sets the IIrowcount system variable to one. The cursor remains pointing to the same row (the State attribute of the CursorObject remains CS_CURRENT) and subsequent update or delete statements for the cursor take effect on the same row. If the update is not successful, OpenROAD sets IIrowcount to -1 or 0.\n\nIf the cursor is not pointing to a row, 4GL generates a runtime error message indicating that you must execute a fetch statement. If the row the cursor is pointing to has been deleted from the underlying database table (as the result, for example, of a non-cursor delete), no row is updated.\n\nIt is not necessary to commit after each cursor update. All the changes that you make are committed when you close the cursor. (Do not update the current row of a cursor, commit the change, and then continue in a loop in order to repeat the process. This process fails because the first commit statement closes the cursor.)\n\nYou must issue any update statements for a cursor in the same session in which you opened the cursor.\n\nFor more information about the update statement, see the Programming Guide.\n\n## Examples--Update Statement\n\nUpdate rows in the projects table with values from the current frame:",
            "Update rows in the projects table with values from the current frame:\n\n```\nrepeated update projects\n     set hours = :hours, duedate = :enddate\n     where name = :name;\ncommit;\n```\n\nUpdate the personnel table with a computed value:\n\n```\nupdate personnel\n     set sal = :salary * 1.1\n     where empno = :empno;\ncommit;\n```\n\nUpdate the salaries of all employees in job category, acc, using the value for a standard raise in the table dept:\n\n```\nupdate employee e from dept d\n     set salary = d.std_raise * e.salary\n     where e.jobcat = 'acc' and d.dname = e.dname;\ncommit;\n```\n\nUpdate the vendor address based on the attributes of the addr reference variable:\n\n```\nupdate vendor\n     set city = :addr.city, state = :addr.state\n     where vendorno = :vno;\ncommit;\n```\n\nUpdate the row pointed to by the open cursor, emp_cursor:\n\n```\nupdate emptable\n     set name = :namefield, age = :agefield\n     where current of emp_cursor;\ncommit;\n```"
        ]
    },
    {
        "instruction": "In what scenarios would you use a cursor version of the update statement in OpenROAD?",
        "input": "",
        "output": "The cursor version of the update statement is used when you want to update multiple rows based on some condition and traverse the result set one by one. It is useful when you have an iterative loop where you need to perform some action for each row in a table. The `cursor_variable` points to the current row, allowing you to update it as needed within the loop.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->database_procedures",
        "task_description": "Explain the database procedures in Actian 4GL SQL and how they are used in OpenROAD.",
        "document": [
            "# Update Statement\n\nThis statement updates the values of the columns in a database table.\n\nThis statement has the following syntax:\n\n- Non-cursor version:\n  ```\n  [repeated] update tablename [corrname]\n       [from fromclause]\n       set columnname = dbexpression {, columnname =\n                 dbexpression}\n       [where searchcondition];\n  ```\n- Cursor version:\n  ```\n  update tablename set columnname = dbexpression\n       {, columnname = dbexpression} where current of\n            cursor_variable;\n  ```\n\nwhere fromclause has the following alternative syntaxes:\n```\nfrom tablename [corrname]{, tablename [corrname]}\nfrom :fromvariable\n```\n\nThe update statement modifies the values in columns in a database table.\n\nThe tablename identifies the table that you want to update and must match the table name specified in the open statement for the specified cursor.\n\nEach column that you include in the update statement must also have been specified in the for update clause of the open statement that opened the cursor.\n\nThe optional corrname defines a correlation name for the table. Correlation names provide a shorthand way to refer to tables in a query.\n\nThe optional repeated keyword directs the DBMS to encode and save the query execution plan for the statement. This is a performance enhancement if you intend to execute this statement more than once.\n\nNote: Do not use the repeated keyword if you place the entire where clause, searchcondition, in a single variable or if a table name or column name is represented by a dynamic name.\n\n## Parameters--Update Statement\n\nThis statement has the following parameters:\n\n- tablename: Specifies the name of the database table that you want to update. This is a dynamic name.\n- corrname: Specifies the correlation name for the table. This is a dynamic name. This parameter is used only in the non-cursor version.\n- columnname: Specifies the name of a particular column to be updated in the table. This is a dynamic name.\n- dbexpression: Specifies a database expression\n- searchcondition: Specifies a logical database expression of conditions that must be satisfied by all rows selected. You can use simple variables (preceded by colons) in a search condition wherever you can use a literal. Alternatively, you can place the entire search condition in a single varchar variable, and specify the search condition as the name of this variable (proceeded by a colon). This parameter is only used in the non-cursor version.\n- cursor_variable: Specifies the reference variable that points to the CursorObject for which the statement is issued. Used only in the cursor version.\n- fromvariable: Specifies the entire from clause as a single varchar variable, preeded by a colon. This is a dynamic name.\n\n### Set Clause\n\nThe set clause specifies the columns in the table that you want to update.\n\n### Where Clause\n\nIf you do not include a where clause, OpenROAD updates all of the rows in the table. If you include a where clause, OpenROAD updates only the rows in the table that satisfy searchcondition in the where clause.\n\nThe \"where current of\" clause directs OpenROAD to update the row on which the specified cursor is positioned. The cursor_variable must point to a CursorObject that you opened using a for update clause.\n\n## Update Mode\n\nThe update mode of the cursor, specified when you opened the cursor, affects how you can use the update statement. You can open a cursor for deferred or direct update.\n\n### Deferred Mode\n\nWith deferred mode cursors, you can perform only one operation against each row. This operation can be an update or a delete but not both. Similarly, you cannot use the repeated option with a deferred update cursor. Cursors that are opened for direct update do not have these restrictions. However, if the cursor is a direct update cursor and you perform two cursor updates that are not separated by a fetch statement, you can update the same row twice.\n\nAfter a successful update, OpenROAD sets the IIrowcount system variable to one. The cursor remains pointing to the same row (the State attribute of the CursorObject remains CS_CURRENT) and subsequent update or delete statements for the cursor take effect on the same row. If the update is not successful, OpenROAD sets IIrowcount to -1 or 0.\n\nIf the cursor is not pointing to a row, 4GL generates a runtime error message indicating that you must execute a fetch statement. If the row the cursor is pointing to has been deleted from the underlying database table (as the result, for example, of a non-cursor delete), no row is updated.\n\nIt is not necessary to commit after each cursor update. All the changes that you make are committed when you close the cursor. (Do not update the current row of a cursor, commit the change, and then continue in a loop in order to repeat the process. This process fails because the first commit statement closes the cursor.)\n\nYou must issue any update statements for a cursor in the same session in which you opened the cursor.\n\nFor more information about the update statement, see the Programming Guide.\n\n## Examples--Update Statement\n\nUpdate rows in the projects table with values from the current frame:",
            "Update rows in the projects table with values from the current frame:\n\n```\nrepeated update projects\n     set hours = :hours, duedate = :enddate\n     where name = :name;\ncommit;\n```\n\nUpdate the personnel table with a computed value:\n\n```\nupdate personnel\n     set sal = :salary * 1.1\n     where empno = :empno;\ncommit;\n```\n\nUpdate the salaries of all employees in job category, acc, using the value for a standard raise in the table dept:\n\n```\nupdate employee e from dept d\n     set salary = d.std_raise * e.salary\n     where e.jobcat = 'acc' and d.dname = e.dname;\ncommit;\n```\n\nUpdate the vendor address based on the attributes of the addr reference variable:\n\n```\nupdate vendor\n     set city = :addr.city, state = :addr.state\n     where vendorno = :vno;\ncommit;\n```\n\nUpdate the row pointed to by the open cursor, emp_cursor:\n\n```\nupdate emptable\n     set name = :namefield, age = :agefield\n     where current of emp_cursor;\ncommit;\n```"
        ]
    },
    {
        "instruction": "What is a correlation name and how it is used in Actian 4GL SQL update statement?",
        "input": "",
        "output": "A correlation name is an optional parameter that can be specified while working with the update statement. It helps provide a shorthand way to refer to tables in a query. This makes your code more readable and maintainable as you are not writing complex join conditions every time. For example, if we have two tables: employees and departments, a correlation name for employees can be emp_table. Then instead of writing update employees set... from employees inner join departments on departments.dept_id = employees.dept_id, you can write update emp_table set...",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->database_procedures",
        "task_description": "Explain the database procedures in Actian 4GL SQL and how they are used in OpenROAD.",
        "document": [
            "# Update Statement\n\nThis statement updates the values of the columns in a database table.\n\nThis statement has the following syntax:\n\n- Non-cursor version:\n  ```\n  [repeated] update tablename [corrname]\n       [from fromclause]\n       set columnname = dbexpression {, columnname =\n                 dbexpression}\n       [where searchcondition];\n  ```\n- Cursor version:\n  ```\n  update tablename set columnname = dbexpression\n       {, columnname = dbexpression} where current of\n            cursor_variable;\n  ```\n\nwhere fromclause has the following alternative syntaxes:\n```\nfrom tablename [corrname]{, tablename [corrname]}\nfrom :fromvariable\n```\n\nThe update statement modifies the values in columns in a database table.\n\nThe tablename identifies the table that you want to update and must match the table name specified in the open statement for the specified cursor.\n\nEach column that you include in the update statement must also have been specified in the for update clause of the open statement that opened the cursor.\n\nThe optional corrname defines a correlation name for the table. Correlation names provide a shorthand way to refer to tables in a query.\n\nThe optional repeated keyword directs the DBMS to encode and save the query execution plan for the statement. This is a performance enhancement if you intend to execute this statement more than once.\n\nNote: Do not use the repeated keyword if you place the entire where clause, searchcondition, in a single variable or if a table name or column name is represented by a dynamic name.\n\n## Parameters--Update Statement\n\nThis statement has the following parameters:\n\n- tablename: Specifies the name of the database table that you want to update. This is a dynamic name.\n- corrname: Specifies the correlation name for the table. This is a dynamic name. This parameter is used only in the non-cursor version.\n- columnname: Specifies the name of a particular column to be updated in the table. This is a dynamic name.\n- dbexpression: Specifies a database expression\n- searchcondition: Specifies a logical database expression of conditions that must be satisfied by all rows selected. You can use simple variables (preceded by colons) in a search condition wherever you can use a literal. Alternatively, you can place the entire search condition in a single varchar variable, and specify the search condition as the name of this variable (proceeded by a colon). This parameter is only used in the non-cursor version.\n- cursor_variable: Specifies the reference variable that points to the CursorObject for which the statement is issued. Used only in the cursor version.\n- fromvariable: Specifies the entire from clause as a single varchar variable, preeded by a colon. This is a dynamic name.\n\n### Set Clause\n\nThe set clause specifies the columns in the table that you want to update.\n\n### Where Clause\n\nIf you do not include a where clause, OpenROAD updates all of the rows in the table. If you include a where clause, OpenROAD updates only the rows in the table that satisfy searchcondition in the where clause.\n\nThe \"where current of\" clause directs OpenROAD to update the row on which the specified cursor is positioned. The cursor_variable must point to a CursorObject that you opened using a for update clause.\n\n## Update Mode\n\nThe update mode of the cursor, specified when you opened the cursor, affects how you can use the update statement. You can open a cursor for deferred or direct update.\n\n### Deferred Mode\n\nWith deferred mode cursors, you can perform only one operation against each row. This operation can be an update or a delete but not both. Similarly, you cannot use the repeated option with a deferred update cursor. Cursors that are opened for direct update do not have these restrictions. However, if the cursor is a direct update cursor and you perform two cursor updates that are not separated by a fetch statement, you can update the same row twice.\n\nAfter a successful update, OpenROAD sets the IIrowcount system variable to one. The cursor remains pointing to the same row (the State attribute of the CursorObject remains CS_CURRENT) and subsequent update or delete statements for the cursor take effect on the same row. If the update is not successful, OpenROAD sets IIrowcount to -1 or 0.\n\nIf the cursor is not pointing to a row, 4GL generates a runtime error message indicating that you must execute a fetch statement. If the row the cursor is pointing to has been deleted from the underlying database table (as the result, for example, of a non-cursor delete), no row is updated.\n\nIt is not necessary to commit after each cursor update. All the changes that you make are committed when you close the cursor. (Do not update the current row of a cursor, commit the change, and then continue in a loop in order to repeat the process. This process fails because the first commit statement closes the cursor.)\n\nYou must issue any update statements for a cursor in the same session in which you opened the cursor.\n\nFor more information about the update statement, see the Programming Guide.\n\n## Examples--Update Statement\n\nUpdate rows in the projects table with values from the current frame:",
            "Update rows in the projects table with values from the current frame:\n\n```\nrepeated update projects\n     set hours = :hours, duedate = :enddate\n     where name = :name;\ncommit;\n```\n\nUpdate the personnel table with a computed value:\n\n```\nupdate personnel\n     set sal = :salary * 1.1\n     where empno = :empno;\ncommit;\n```\n\nUpdate the salaries of all employees in job category, acc, using the value for a standard raise in the table dept:\n\n```\nupdate employee e from dept d\n     set salary = d.std_raise * e.salary\n     where e.jobcat = 'acc' and d.dname = e.dname;\ncommit;\n```\n\nUpdate the vendor address based on the attributes of the addr reference variable:\n\n```\nupdate vendor\n     set city = :addr.city, state = :addr.state\n     where vendorno = :vno;\ncommit;\n```\n\nUpdate the row pointed to by the open cursor, emp_cursor:\n\n```\nupdate emptable\n     set name = :namefield, age = :agefield\n     where current of emp_cursor;\ncommit;\n```"
        ]
    },
    {
        "instruction": "Can you explain the role of 'dbexpression' in Actian 4GL SQL update statement?",
        "input": "",
        "output": "The `dbexpression` parameter in the update statement defines what new value a particular column will have after an update operation. This can be a literal, a column from the same or other table, arithmetic expressions etc. The values of the `dbexpression` can also be derived from user input or from some computation within your program. For example, in the following update statement, we are updating the 'salary' column with a new value which is the sum of current salary and an increment:\n```sql\nupdate employees set salary = salary + 1000;\n```",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->database_procedures",
        "task_description": "Explain the database procedures in Actian 4GL SQL and how they are used in OpenROAD.",
        "document": [
            "# Update Statement\n\nThis statement updates the values of the columns in a database table.\n\nThis statement has the following syntax:\n\n- Non-cursor version:\n  ```\n  [repeated] update tablename [corrname]\n       [from fromclause]\n       set columnname = dbexpression {, columnname =\n                 dbexpression}\n       [where searchcondition];\n  ```\n- Cursor version:\n  ```\n  update tablename set columnname = dbexpression\n       {, columnname = dbexpression} where current of\n            cursor_variable;\n  ```\n\nwhere fromclause has the following alternative syntaxes:\n```\nfrom tablename [corrname]{, tablename [corrname]}\nfrom :fromvariable\n```\n\nThe update statement modifies the values in columns in a database table.\n\nThe tablename identifies the table that you want to update and must match the table name specified in the open statement for the specified cursor.\n\nEach column that you include in the update statement must also have been specified in the for update clause of the open statement that opened the cursor.\n\nThe optional corrname defines a correlation name for the table. Correlation names provide a shorthand way to refer to tables in a query.\n\nThe optional repeated keyword directs the DBMS to encode and save the query execution plan for the statement. This is a performance enhancement if you intend to execute this statement more than once.\n\nNote: Do not use the repeated keyword if you place the entire where clause, searchcondition, in a single variable or if a table name or column name is represented by a dynamic name.\n\n## Parameters--Update Statement\n\nThis statement has the following parameters:\n\n- tablename: Specifies the name of the database table that you want to update. This is a dynamic name.\n- corrname: Specifies the correlation name for the table. This is a dynamic name. This parameter is used only in the non-cursor version.\n- columnname: Specifies the name of a particular column to be updated in the table. This is a dynamic name.\n- dbexpression: Specifies a database expression\n- searchcondition: Specifies a logical database expression of conditions that must be satisfied by all rows selected. You can use simple variables (preceded by colons) in a search condition wherever you can use a literal. Alternatively, you can place the entire search condition in a single varchar variable, and specify the search condition as the name of this variable (proceeded by a colon). This parameter is only used in the non-cursor version.\n- cursor_variable: Specifies the reference variable that points to the CursorObject for which the statement is issued. Used only in the cursor version.\n- fromvariable: Specifies the entire from clause as a single varchar variable, preeded by a colon. This is a dynamic name.\n\n### Set Clause\n\nThe set clause specifies the columns in the table that you want to update.\n\n### Where Clause\n\nIf you do not include a where clause, OpenROAD updates all of the rows in the table. If you include a where clause, OpenROAD updates only the rows in the table that satisfy searchcondition in the where clause.\n\nThe \"where current of\" clause directs OpenROAD to update the row on which the specified cursor is positioned. The cursor_variable must point to a CursorObject that you opened using a for update clause.\n\n## Update Mode\n\nThe update mode of the cursor, specified when you opened the cursor, affects how you can use the update statement. You can open a cursor for deferred or direct update.\n\n### Deferred Mode\n\nWith deferred mode cursors, you can perform only one operation against each row. This operation can be an update or a delete but not both. Similarly, you cannot use the repeated option with a deferred update cursor. Cursors that are opened for direct update do not have these restrictions. However, if the cursor is a direct update cursor and you perform two cursor updates that are not separated by a fetch statement, you can update the same row twice.\n\nAfter a successful update, OpenROAD sets the IIrowcount system variable to one. The cursor remains pointing to the same row (the State attribute of the CursorObject remains CS_CURRENT) and subsequent update or delete statements for the cursor take effect on the same row. If the update is not successful, OpenROAD sets IIrowcount to -1 or 0.\n\nIf the cursor is not pointing to a row, 4GL generates a runtime error message indicating that you must execute a fetch statement. If the row the cursor is pointing to has been deleted from the underlying database table (as the result, for example, of a non-cursor delete), no row is updated.\n\nIt is not necessary to commit after each cursor update. All the changes that you make are committed when you close the cursor. (Do not update the current row of a cursor, commit the change, and then continue in a loop in order to repeat the process. This process fails because the first commit statement closes the cursor.)\n\nYou must issue any update statements for a cursor in the same session in which you opened the cursor.\n\nFor more information about the update statement, see the Programming Guide.\n\n## Examples--Update Statement\n\nUpdate rows in the projects table with values from the current frame:",
            "Update rows in the projects table with values from the current frame:\n\n```\nrepeated update projects\n     set hours = :hours, duedate = :enddate\n     where name = :name;\ncommit;\n```\n\nUpdate the personnel table with a computed value:\n\n```\nupdate personnel\n     set sal = :salary * 1.1\n     where empno = :empno;\ncommit;\n```\n\nUpdate the salaries of all employees in job category, acc, using the value for a standard raise in the table dept:\n\n```\nupdate employee e from dept d\n     set salary = d.std_raise * e.salary\n     where e.jobcat = 'acc' and d.dname = e.dname;\ncommit;\n```\n\nUpdate the vendor address based on the attributes of the addr reference variable:\n\n```\nupdate vendor\n     set city = :addr.city, state = :addr.state\n     where vendorno = :vno;\ncommit;\n```\n\nUpdate the row pointed to by the open cursor, emp_cursor:\n\n```\nupdate emptable\n     set name = :namefield, age = :agefield\n     where current of emp_cursor;\ncommit;\n```"
        ]
    },
    {
        "instruction": "Can you explain how to use the 'where clause' in Actian 4GL SQL update statement?",
        "input": "",
        "output": "The `where clause` in the update statement is used to specify a search condition that restricts the rows which are updated. By default, an `update` statement will attempt to modify every row in a table. However, you might want to update only certain rows based on some criteria. You can use the `where` clause for this purpose by specifying conditions such as column name and values, operators, logical operations etc.\n\nHere's an example where we are updating the 'status' column of employees whose salary is greater than 5000:\n```sql\nupdate employees set status = 'High Salary' where salary > 5000;\n```",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->database_procedures",
        "task_description": "Explain the database procedures in Actian 4GL SQL and how they are used in OpenROAD.",
        "document": [
            "# Update Statement\n\nThis statement updates the values of the columns in a database table.\n\nThis statement has the following syntax:\n\n- Non-cursor version:\n  ```\n  [repeated] update tablename [corrname]\n       [from fromclause]\n       set columnname = dbexpression {, columnname =\n                 dbexpression}\n       [where searchcondition];\n  ```\n- Cursor version:\n  ```\n  update tablename set columnname = dbexpression\n       {, columnname = dbexpression} where current of\n            cursor_variable;\n  ```\n\nwhere fromclause has the following alternative syntaxes:\n```\nfrom tablename [corrname]{, tablename [corrname]}\nfrom :fromvariable\n```\n\nThe update statement modifies the values in columns in a database table.\n\nThe tablename identifies the table that you want to update and must match the table name specified in the open statement for the specified cursor.\n\nEach column that you include in the update statement must also have been specified in the for update clause of the open statement that opened the cursor.\n\nThe optional corrname defines a correlation name for the table. Correlation names provide a shorthand way to refer to tables in a query.\n\nThe optional repeated keyword directs the DBMS to encode and save the query execution plan for the statement. This is a performance enhancement if you intend to execute this statement more than once.\n\nNote: Do not use the repeated keyword if you place the entire where clause, searchcondition, in a single variable or if a table name or column name is represented by a dynamic name.\n\n## Parameters--Update Statement\n\nThis statement has the following parameters:\n\n- tablename: Specifies the name of the database table that you want to update. This is a dynamic name.\n- corrname: Specifies the correlation name for the table. This is a dynamic name. This parameter is used only in the non-cursor version.\n- columnname: Specifies the name of a particular column to be updated in the table. This is a dynamic name.\n- dbexpression: Specifies a database expression\n- searchcondition: Specifies a logical database expression of conditions that must be satisfied by all rows selected. You can use simple variables (preceded by colons) in a search condition wherever you can use a literal. Alternatively, you can place the entire search condition in a single varchar variable, and specify the search condition as the name of this variable (proceeded by a colon). This parameter is only used in the non-cursor version.\n- cursor_variable: Specifies the reference variable that points to the CursorObject for which the statement is issued. Used only in the cursor version.\n- fromvariable: Specifies the entire from clause as a single varchar variable, preeded by a colon. This is a dynamic name.\n\n### Set Clause\n\nThe set clause specifies the columns in the table that you want to update.\n\n### Where Clause\n\nIf you do not include a where clause, OpenROAD updates all of the rows in the table. If you include a where clause, OpenROAD updates only the rows in the table that satisfy searchcondition in the where clause.\n\nThe \"where current of\" clause directs OpenROAD to update the row on which the specified cursor is positioned. The cursor_variable must point to a CursorObject that you opened using a for update clause.\n\n## Update Mode\n\nThe update mode of the cursor, specified when you opened the cursor, affects how you can use the update statement. You can open a cursor for deferred or direct update.\n\n### Deferred Mode\n\nWith deferred mode cursors, you can perform only one operation against each row. This operation can be an update or a delete but not both. Similarly, you cannot use the repeated option with a deferred update cursor. Cursors that are opened for direct update do not have these restrictions. However, if the cursor is a direct update cursor and you perform two cursor updates that are not separated by a fetch statement, you can update the same row twice.\n\nAfter a successful update, OpenROAD sets the IIrowcount system variable to one. The cursor remains pointing to the same row (the State attribute of the CursorObject remains CS_CURRENT) and subsequent update or delete statements for the cursor take effect on the same row. If the update is not successful, OpenROAD sets IIrowcount to -1 or 0.\n\nIf the cursor is not pointing to a row, 4GL generates a runtime error message indicating that you must execute a fetch statement. If the row the cursor is pointing to has been deleted from the underlying database table (as the result, for example, of a non-cursor delete), no row is updated.\n\nIt is not necessary to commit after each cursor update. All the changes that you make are committed when you close the cursor. (Do not update the current row of a cursor, commit the change, and then continue in a loop in order to repeat the process. This process fails because the first commit statement closes the cursor.)\n\nYou must issue any update statements for a cursor in the same session in which you opened the cursor.\n\nFor more information about the update statement, see the Programming Guide.\n\n## Examples--Update Statement\n\nUpdate rows in the projects table with values from the current frame:",
            "Update rows in the projects table with values from the current frame:\n\n```\nrepeated update projects\n     set hours = :hours, duedate = :enddate\n     where name = :name;\ncommit;\n```\n\nUpdate the personnel table with a computed value:\n\n```\nupdate personnel\n     set sal = :salary * 1.1\n     where empno = :empno;\ncommit;\n```\n\nUpdate the salaries of all employees in job category, acc, using the value for a standard raise in the table dept:\n\n```\nupdate employee e from dept d\n     set salary = d.std_raise * e.salary\n     where e.jobcat = 'acc' and d.dname = e.dname;\ncommit;\n```\n\nUpdate the vendor address based on the attributes of the addr reference variable:\n\n```\nupdate vendor\n     set city = :addr.city, state = :addr.state\n     where vendorno = :vno;\ncommit;\n```\n\nUpdate the row pointed to by the open cursor, emp_cursor:\n\n```\nupdate emptable\n     set name = :namefield, age = :agefield\n     where current of emp_cursor;\ncommit;\n```"
        ]
    },
    {
        "instruction": "Can you explain what happens when a cursor is updated without using the fetch statement?",
        "input": "",
        "output": "When a cursor is updated without using the fetch statement in Actian 4GL SQL, it will attempt to update the same row multiple times. However, if the cursor is opened in deferred mode, you can only perform one operation against each row, and this will result in a runtime error. In direct mode, updating the same row multiple times without using the fetch statement is allowed but it is not recommended because it can lead to unexpected results. It's always safer to use the fetch statement to move to the next row before updating it again.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->database_procedures",
        "task_description": "Explain the database procedures in Actian 4GL SQL and how they are used in OpenROAD.",
        "document": [
            "# Update Statement\n\nThis statement updates the values of the columns in a database table.\n\nThis statement has the following syntax:\n\n- Non-cursor version:\n  ```\n  [repeated] update tablename [corrname]\n       [from fromclause]\n       set columnname = dbexpression {, columnname =\n                 dbexpression}\n       [where searchcondition];\n  ```\n- Cursor version:\n  ```\n  update tablename set columnname = dbexpression\n       {, columnname = dbexpression} where current of\n            cursor_variable;\n  ```\n\nwhere fromclause has the following alternative syntaxes:\n```\nfrom tablename [corrname]{, tablename [corrname]}\nfrom :fromvariable\n```\n\nThe update statement modifies the values in columns in a database table.\n\nThe tablename identifies the table that you want to update and must match the table name specified in the open statement for the specified cursor.\n\nEach column that you include in the update statement must also have been specified in the for update clause of the open statement that opened the cursor.\n\nThe optional corrname defines a correlation name for the table. Correlation names provide a shorthand way to refer to tables in a query.\n\nThe optional repeated keyword directs the DBMS to encode and save the query execution plan for the statement. This is a performance enhancement if you intend to execute this statement more than once.\n\nNote: Do not use the repeated keyword if you place the entire where clause, searchcondition, in a single variable or if a table name or column name is represented by a dynamic name.\n\n## Parameters--Update Statement\n\nThis statement has the following parameters:\n\n- tablename: Specifies the name of the database table that you want to update. This is a dynamic name.\n- corrname: Specifies the correlation name for the table. This is a dynamic name. This parameter is used only in the non-cursor version.\n- columnname: Specifies the name of a particular column to be updated in the table. This is a dynamic name.\n- dbexpression: Specifies a database expression\n- searchcondition: Specifies a logical database expression of conditions that must be satisfied by all rows selected. You can use simple variables (preceded by colons) in a search condition wherever you can use a literal. Alternatively, you can place the entire search condition in a single varchar variable, and specify the search condition as the name of this variable (proceeded by a colon). This parameter is only used in the non-cursor version.\n- cursor_variable: Specifies the reference variable that points to the CursorObject for which the statement is issued. Used only in the cursor version.\n- fromvariable: Specifies the entire from clause as a single varchar variable, preeded by a colon. This is a dynamic name.\n\n### Set Clause\n\nThe set clause specifies the columns in the table that you want to update.\n\n### Where Clause\n\nIf you do not include a where clause, OpenROAD updates all of the rows in the table. If you include a where clause, OpenROAD updates only the rows in the table that satisfy searchcondition in the where clause.\n\nThe \"where current of\" clause directs OpenROAD to update the row on which the specified cursor is positioned. The cursor_variable must point to a CursorObject that you opened using a for update clause.\n\n## Update Mode\n\nThe update mode of the cursor, specified when you opened the cursor, affects how you can use the update statement. You can open a cursor for deferred or direct update.\n\n### Deferred Mode\n\nWith deferred mode cursors, you can perform only one operation against each row. This operation can be an update or a delete but not both. Similarly, you cannot use the repeated option with a deferred update cursor. Cursors that are opened for direct update do not have these restrictions. However, if the cursor is a direct update cursor and you perform two cursor updates that are not separated by a fetch statement, you can update the same row twice.\n\nAfter a successful update, OpenROAD sets the IIrowcount system variable to one. The cursor remains pointing to the same row (the State attribute of the CursorObject remains CS_CURRENT) and subsequent update or delete statements for the cursor take effect on the same row. If the update is not successful, OpenROAD sets IIrowcount to -1 or 0.\n\nIf the cursor is not pointing to a row, 4GL generates a runtime error message indicating that you must execute a fetch statement. If the row the cursor is pointing to has been deleted from the underlying database table (as the result, for example, of a non-cursor delete), no row is updated.\n\nIt is not necessary to commit after each cursor update. All the changes that you make are committed when you close the cursor. (Do not update the current row of a cursor, commit the change, and then continue in a loop in order to repeat the process. This process fails because the first commit statement closes the cursor.)\n\nYou must issue any update statements for a cursor in the same session in which you opened the cursor.\n\nFor more information about the update statement, see the Programming Guide.\n\n## Examples--Update Statement\n\nUpdate rows in the projects table with values from the current frame:",
            "Update rows in the projects table with values from the current frame:\n\n```\nrepeated update projects\n     set hours = :hours, duedate = :enddate\n     where name = :name;\ncommit;\n```\n\nUpdate the personnel table with a computed value:\n\n```\nupdate personnel\n     set sal = :salary * 1.1\n     where empno = :empno;\ncommit;\n```\n\nUpdate the salaries of all employees in job category, acc, using the value for a standard raise in the table dept:\n\n```\nupdate employee e from dept d\n     set salary = d.std_raise * e.salary\n     where e.jobcat = 'acc' and d.dname = e.dname;\ncommit;\n```\n\nUpdate the vendor address based on the attributes of the addr reference variable:\n\n```\nupdate vendor\n     set city = :addr.city, state = :addr.state\n     where vendorno = :vno;\ncommit;\n```\n\nUpdate the row pointed to by the open cursor, emp_cursor:\n\n```\nupdate emptable\n     set name = :namefield, age = :agefield\n     where current of emp_cursor;\ncommit;\n```"
        ]
    },
    {
        "instruction": "Explain the difference between a single update statement and a cursor-based update in Actian 4GL SQL.",
        "input": "",
        "output": "The main difference between a single update statement and a cursor-based update lies in the way they handle multiple rows. A single update statement modifies all rows that match the specified condition, while a cursor-based update processes the result set one row at a time using the cursor variable. The cursor version allows for more complex processing where you might need to modify individual rows based on some looping logic or user input during runtime.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->database_procedures",
        "task_description": "Explain the database procedures in Actian 4GL SQL and how they are used in OpenROAD.",
        "document": [
            "# Update Statement\n\nThis statement updates the values of the columns in a database table.\n\nThis statement has the following syntax:\n\n- Non-cursor version:\n  ```\n  [repeated] update tablename [corrname]\n       [from fromclause]\n       set columnname = dbexpression {, columnname =\n                 dbexpression}\n       [where searchcondition];\n  ```\n- Cursor version:\n  ```\n  update tablename set columnname = dbexpression\n       {, columnname = dbexpression} where current of\n            cursor_variable;\n  ```\n\nwhere fromclause has the following alternative syntaxes:\n```\nfrom tablename [corrname]{, tablename [corrname]}\nfrom :fromvariable\n```\n\nThe update statement modifies the values in columns in a database table.\n\nThe tablename identifies the table that you want to update and must match the table name specified in the open statement for the specified cursor.\n\nEach column that you include in the update statement must also have been specified in the for update clause of the open statement that opened the cursor.\n\nThe optional corrname defines a correlation name for the table. Correlation names provide a shorthand way to refer to tables in a query.\n\nThe optional repeated keyword directs the DBMS to encode and save the query execution plan for the statement. This is a performance enhancement if you intend to execute this statement more than once.\n\nNote: Do not use the repeated keyword if you place the entire where clause, searchcondition, in a single variable or if a table name or column name is represented by a dynamic name.\n\n## Parameters--Update Statement\n\nThis statement has the following parameters:\n\n- tablename: Specifies the name of the database table that you want to update. This is a dynamic name.\n- corrname: Specifies the correlation name for the table. This is a dynamic name. This parameter is used only in the non-cursor version.\n- columnname: Specifies the name of a particular column to be updated in the table. This is a dynamic name.\n- dbexpression: Specifies a database expression\n- searchcondition: Specifies a logical database expression of conditions that must be satisfied by all rows selected. You can use simple variables (preceded by colons) in a search condition wherever you can use a literal. Alternatively, you can place the entire search condition in a single varchar variable, and specify the search condition as the name of this variable (proceeded by a colon). This parameter is only used in the non-cursor version.\n- cursor_variable: Specifies the reference variable that points to the CursorObject for which the statement is issued. Used only in the cursor version.\n- fromvariable: Specifies the entire from clause as a single varchar variable, preeded by a colon. This is a dynamic name.\n\n### Set Clause\n\nThe set clause specifies the columns in the table that you want to update.\n\n### Where Clause\n\nIf you do not include a where clause, OpenROAD updates all of the rows in the table. If you include a where clause, OpenROAD updates only the rows in the table that satisfy searchcondition in the where clause.\n\nThe \"where current of\" clause directs OpenROAD to update the row on which the specified cursor is positioned. The cursor_variable must point to a CursorObject that you opened using a for update clause.\n\n## Update Mode\n\nThe update mode of the cursor, specified when you opened the cursor, affects how you can use the update statement. You can open a cursor for deferred or direct update.\n\n### Deferred Mode\n\nWith deferred mode cursors, you can perform only one operation against each row. This operation can be an update or a delete but not both. Similarly, you cannot use the repeated option with a deferred update cursor. Cursors that are opened for direct update do not have these restrictions. However, if the cursor is a direct update cursor and you perform two cursor updates that are not separated by a fetch statement, you can update the same row twice.\n\nAfter a successful update, OpenROAD sets the IIrowcount system variable to one. The cursor remains pointing to the same row (the State attribute of the CursorObject remains CS_CURRENT) and subsequent update or delete statements for the cursor take effect on the same row. If the update is not successful, OpenROAD sets IIrowcount to -1 or 0.\n\nIf the cursor is not pointing to a row, 4GL generates a runtime error message indicating that you must execute a fetch statement. If the row the cursor is pointing to has been deleted from the underlying database table (as the result, for example, of a non-cursor delete), no row is updated.\n\nIt is not necessary to commit after each cursor update. All the changes that you make are committed when you close the cursor. (Do not update the current row of a cursor, commit the change, and then continue in a loop in order to repeat the process. This process fails because the first commit statement closes the cursor.)\n\nYou must issue any update statements for a cursor in the same session in which you opened the cursor.\n\nFor more information about the update statement, see the Programming Guide.\n\n## Examples--Update Statement\n\nUpdate rows in the projects table with values from the current frame:",
            "Update rows in the projects table with values from the current frame:\n\n```\nrepeated update projects\n     set hours = :hours, duedate = :enddate\n     where name = :name;\ncommit;\n```\n\nUpdate the personnel table with a computed value:\n\n```\nupdate personnel\n     set sal = :salary * 1.1\n     where empno = :empno;\ncommit;\n```\n\nUpdate the salaries of all employees in job category, acc, using the value for a standard raise in the table dept:\n\n```\nupdate employee e from dept d\n     set salary = d.std_raise * e.salary\n     where e.jobcat = 'acc' and d.dname = e.dname;\ncommit;\n```\n\nUpdate the vendor address based on the attributes of the addr reference variable:\n\n```\nupdate vendor\n     set city = :addr.city, state = :addr.state\n     where vendorno = :vno;\ncommit;\n```\n\nUpdate the row pointed to by the open cursor, emp_cursor:\n\n```\nupdate emptable\n     set name = :namefield, age = :agefield\n     where current of emp_cursor;\ncommit;\n```"
        ]
    },
    {
        "instruction": "In OpenROAD, how can you retrieve data from multiple tables and perform an update operation?",
        "input": "",
        "output": "To perform an update operation using joined tables in OpenROAD, you need to create a derived table from the join and use that derived table for updating the target table. Here's an example:\n```sql\ncreate derived table derived_emp as\nselect e.employee_id, d.department_salary from employees e left outer join departments d\n     on e.dname = d.dname;\n\nupdate employee e\n     set salary = d.department_salary\n     where e.employee_id in (select employee_id from derived_emp);\ncommit;\n```",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->database_procedures",
        "task_description": "Explain the database procedures in Actian 4GL SQL and how they are used in OpenROAD.",
        "document": [
            "# Update Statement\n\nThis statement updates the values of the columns in a database table.\n\nThis statement has the following syntax:\n\n- Non-cursor version:\n  ```\n  [repeated] update tablename [corrname]\n       [from fromclause]\n       set columnname = dbexpression {, columnname =\n                 dbexpression}\n       [where searchcondition];\n  ```\n- Cursor version:\n  ```\n  update tablename set columnname = dbexpression\n       {, columnname = dbexpression} where current of\n            cursor_variable;\n  ```\n\nwhere fromclause has the following alternative syntaxes:\n```\nfrom tablename [corrname]{, tablename [corrname]}\nfrom :fromvariable\n```\n\nThe update statement modifies the values in columns in a database table.\n\nThe tablename identifies the table that you want to update and must match the table name specified in the open statement for the specified cursor.\n\nEach column that you include in the update statement must also have been specified in the for update clause of the open statement that opened the cursor.\n\nThe optional corrname defines a correlation name for the table. Correlation names provide a shorthand way to refer to tables in a query.\n\nThe optional repeated keyword directs the DBMS to encode and save the query execution plan for the statement. This is a performance enhancement if you intend to execute this statement more than once.\n\nNote: Do not use the repeated keyword if you place the entire where clause, searchcondition, in a single variable or if a table name or column name is represented by a dynamic name.\n\n## Parameters--Update Statement\n\nThis statement has the following parameters:\n\n- tablename: Specifies the name of the database table that you want to update. This is a dynamic name.\n- corrname: Specifies the correlation name for the table. This is a dynamic name. This parameter is used only in the non-cursor version.\n- columnname: Specifies the name of a particular column to be updated in the table. This is a dynamic name.\n- dbexpression: Specifies a database expression\n- searchcondition: Specifies a logical database expression of conditions that must be satisfied by all rows selected. You can use simple variables (preceded by colons) in a search condition wherever you can use a literal. Alternatively, you can place the entire search condition in a single varchar variable, and specify the search condition as the name of this variable (proceeded by a colon). This parameter is only used in the non-cursor version.\n- cursor_variable: Specifies the reference variable that points to the CursorObject for which the statement is issued. Used only in the cursor version.\n- fromvariable: Specifies the entire from clause as a single varchar variable, preeded by a colon. This is a dynamic name.\n\n### Set Clause\n\nThe set clause specifies the columns in the table that you want to update.\n\n### Where Clause\n\nIf you do not include a where clause, OpenROAD updates all of the rows in the table. If you include a where clause, OpenROAD updates only the rows in the table that satisfy searchcondition in the where clause.\n\nThe \"where current of\" clause directs OpenROAD to update the row on which the specified cursor is positioned. The cursor_variable must point to a CursorObject that you opened using a for update clause.\n\n## Update Mode\n\nThe update mode of the cursor, specified when you opened the cursor, affects how you can use the update statement. You can open a cursor for deferred or direct update.\n\n### Deferred Mode\n\nWith deferred mode cursors, you can perform only one operation against each row. This operation can be an update or a delete but not both. Similarly, you cannot use the repeated option with a deferred update cursor. Cursors that are opened for direct update do not have these restrictions. However, if the cursor is a direct update cursor and you perform two cursor updates that are not separated by a fetch statement, you can update the same row twice.\n\nAfter a successful update, OpenROAD sets the IIrowcount system variable to one. The cursor remains pointing to the same row (the State attribute of the CursorObject remains CS_CURRENT) and subsequent update or delete statements for the cursor take effect on the same row. If the update is not successful, OpenROAD sets IIrowcount to -1 or 0.\n\nIf the cursor is not pointing to a row, 4GL generates a runtime error message indicating that you must execute a fetch statement. If the row the cursor is pointing to has been deleted from the underlying database table (as the result, for example, of a non-cursor delete), no row is updated.\n\nIt is not necessary to commit after each cursor update. All the changes that you make are committed when you close the cursor. (Do not update the current row of a cursor, commit the change, and then continue in a loop in order to repeat the process. This process fails because the first commit statement closes the cursor.)\n\nYou must issue any update statements for a cursor in the same session in which you opened the cursor.\n\nFor more information about the update statement, see the Programming Guide.\n\n## Examples--Update Statement\n\nUpdate rows in the projects table with values from the current frame:",
            "Update rows in the projects table with values from the current frame:\n\n```\nrepeated update projects\n     set hours = :hours, duedate = :enddate\n     where name = :name;\ncommit;\n```\n\nUpdate the personnel table with a computed value:\n\n```\nupdate personnel\n     set sal = :salary * 1.1\n     where empno = :empno;\ncommit;\n```\n\nUpdate the salaries of all employees in job category, acc, using the value for a standard raise in the table dept:\n\n```\nupdate employee e from dept d\n     set salary = d.std_raise * e.salary\n     where e.jobcat = 'acc' and d.dname = e.dname;\ncommit;\n```\n\nUpdate the vendor address based on the attributes of the addr reference variable:\n\n```\nupdate vendor\n     set city = :addr.city, state = :addr.state\n     where vendorno = :vno;\ncommit;\n```\n\nUpdate the row pointed to by the open cursor, emp_cursor:\n\n```\nupdate emptable\n     set name = :namefield, age = :agefield\n     where current of emp_cursor;\ncommit;\n```"
        ]
    },
    {
        "instruction": "Give an example of a database procedure used in OpenROAD for updating multiple tables simultaneously.",
        "input": "",
        "output": "An example of a database procedure that updates multiple tables simultaneously in OpenROAD is as follows:\n\n```sql\nprocedure update_employee_salaries(p_std_raise numeric)\nbegin\n  update employee e, dept d\n     set e.salary = d.std_raise * e.salary\n     where e.jobcat = d.jobcat and e.dname = d.dname;\n\n  update projects p\n     set estimated_time = (e.sal * p.hours) * 0.9\n     where p.assigned_to = (select empno from employee where name = 'John');\ncommit;\nend;\n```\nIn this example, we have a stored procedure `update_employee_salaries` that updates both the employee table and the projects table simultaneously. The `std_raise` parameter is passed into the procedure which is then used to update the salaries of all employees in their respective departments and also updates the estimated time for projects assigned to John.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->database_procedures",
        "task_description": "Explain the database procedures in Actian 4GL SQL and how they are used in OpenROAD.",
        "document": [
            "# Update Statement\n\nThis statement updates the values of the columns in a database table.\n\nThis statement has the following syntax:\n\n- Non-cursor version:\n  ```\n  [repeated] update tablename [corrname]\n       [from fromclause]\n       set columnname = dbexpression {, columnname =\n                 dbexpression}\n       [where searchcondition];\n  ```\n- Cursor version:\n  ```\n  update tablename set columnname = dbexpression\n       {, columnname = dbexpression} where current of\n            cursor_variable;\n  ```\n\nwhere fromclause has the following alternative syntaxes:\n```\nfrom tablename [corrname]{, tablename [corrname]}\nfrom :fromvariable\n```\n\nThe update statement modifies the values in columns in a database table.\n\nThe tablename identifies the table that you want to update and must match the table name specified in the open statement for the specified cursor.\n\nEach column that you include in the update statement must also have been specified in the for update clause of the open statement that opened the cursor.\n\nThe optional corrname defines a correlation name for the table. Correlation names provide a shorthand way to refer to tables in a query.\n\nThe optional repeated keyword directs the DBMS to encode and save the query execution plan for the statement. This is a performance enhancement if you intend to execute this statement more than once.\n\nNote: Do not use the repeated keyword if you place the entire where clause, searchcondition, in a single variable or if a table name or column name is represented by a dynamic name.\n\n## Parameters--Update Statement\n\nThis statement has the following parameters:\n\n- tablename: Specifies the name of the database table that you want to update. This is a dynamic name.\n- corrname: Specifies the correlation name for the table. This is a dynamic name. This parameter is used only in the non-cursor version.\n- columnname: Specifies the name of a particular column to be updated in the table. This is a dynamic name.\n- dbexpression: Specifies a database expression\n- searchcondition: Specifies a logical database expression of conditions that must be satisfied by all rows selected. You can use simple variables (preceded by colons) in a search condition wherever you can use a literal. Alternatively, you can place the entire search condition in a single varchar variable, and specify the search condition as the name of this variable (proceeded by a colon). This parameter is only used in the non-cursor version.\n- cursor_variable: Specifies the reference variable that points to the CursorObject for which the statement is issued. Used only in the cursor version.\n- fromvariable: Specifies the entire from clause as a single varchar variable, preeded by a colon. This is a dynamic name.\n\n### Set Clause\n\nThe set clause specifies the columns in the table that you want to update.\n\n### Where Clause\n\nIf you do not include a where clause, OpenROAD updates all of the rows in the table. If you include a where clause, OpenROAD updates only the rows in the table that satisfy searchcondition in the where clause.\n\nThe \"where current of\" clause directs OpenROAD to update the row on which the specified cursor is positioned. The cursor_variable must point to a CursorObject that you opened using a for update clause.\n\n## Update Mode\n\nThe update mode of the cursor, specified when you opened the cursor, affects how you can use the update statement. You can open a cursor for deferred or direct update.\n\n### Deferred Mode\n\nWith deferred mode cursors, you can perform only one operation against each row. This operation can be an update or a delete but not both. Similarly, you cannot use the repeated option with a deferred update cursor. Cursors that are opened for direct update do not have these restrictions. However, if the cursor is a direct update cursor and you perform two cursor updates that are not separated by a fetch statement, you can update the same row twice.\n\nAfter a successful update, OpenROAD sets the IIrowcount system variable to one. The cursor remains pointing to the same row (the State attribute of the CursorObject remains CS_CURRENT) and subsequent update or delete statements for the cursor take effect on the same row. If the update is not successful, OpenROAD sets IIrowcount to -1 or 0.\n\nIf the cursor is not pointing to a row, 4GL generates a runtime error message indicating that you must execute a fetch statement. If the row the cursor is pointing to has been deleted from the underlying database table (as the result, for example, of a non-cursor delete), no row is updated.\n\nIt is not necessary to commit after each cursor update. All the changes that you make are committed when you close the cursor. (Do not update the current row of a cursor, commit the change, and then continue in a loop in order to repeat the process. This process fails because the first commit statement closes the cursor.)\n\nYou must issue any update statements for a cursor in the same session in which you opened the cursor.\n\nFor more information about the update statement, see the Programming Guide.\n\n## Examples--Update Statement\n\nUpdate rows in the projects table with values from the current frame:",
            "Update rows in the projects table with values from the current frame:\n\n```\nrepeated update projects\n     set hours = :hours, duedate = :enddate\n     where name = :name;\ncommit;\n```\n\nUpdate the personnel table with a computed value:\n\n```\nupdate personnel\n     set sal = :salary * 1.1\n     where empno = :empno;\ncommit;\n```\n\nUpdate the salaries of all employees in job category, acc, using the value for a standard raise in the table dept:\n\n```\nupdate employee e from dept d\n     set salary = d.std_raise * e.salary\n     where e.jobcat = 'acc' and d.dname = e.dname;\ncommit;\n```\n\nUpdate the vendor address based on the attributes of the addr reference variable:\n\n```\nupdate vendor\n     set city = :addr.city, state = :addr.state\n     where vendorno = :vno;\ncommit;\n```\n\nUpdate the row pointed to by the open cursor, emp_cursor:\n\n```\nupdate emptable\n     set name = :namefield, age = :agefield\n     where current of emp_cursor;\ncommit;\n```"
        ]
    },
    {
        "instruction": "Describe the use case of using a cursor in a database procedure with an example in OpenROAD.",
        "input": "",
        "output": "Using cursors in a database procedure is useful when you need to iterate over multiple rows, apply some logic or perform conditional operations on each row. Here's an example of using a cursor in OpenROAD:\n\n```sql\nprocedure update_employee_promotions()\nbegin\n  declare employee_cursor cursor for\n    select empno, name, salary from employee\n    where jobcat = 'junior';\n\n  open employee_cursor;\n\n  loop\n    fetch next from employee_cursor into v_empno, v_name, v_salary;\n\n    if (v_salary > 60000) then\n      update employee set jobcat = 'senior' where empno = v_empno;\n    end if;\n  end loop;\n\n  close employee_cursor;\ncommit;\nend;\n```\nIn this example, we have a stored procedure `update_employee_promotions` that uses a cursor to iterate through all junior employees and checks their salary. If the salary is greater than 60,000, the job category is updated to 'senior' for that employee. This way, we can perform conditional operations on each row using a cursor in OpenROAD.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->database_procedures",
        "task_description": "Explain the database procedures in Actian 4GL SQL and how they are used in OpenROAD.",
        "document": [
            "# Update Statement\n\nThis statement updates the values of the columns in a database table.\n\nThis statement has the following syntax:\n\n- Non-cursor version:\n  ```\n  [repeated] update tablename [corrname]\n       [from fromclause]\n       set columnname = dbexpression {, columnname =\n                 dbexpression}\n       [where searchcondition];\n  ```\n- Cursor version:\n  ```\n  update tablename set columnname = dbexpression\n       {, columnname = dbexpression} where current of\n            cursor_variable;\n  ```\n\nwhere fromclause has the following alternative syntaxes:\n```\nfrom tablename [corrname]{, tablename [corrname]}\nfrom :fromvariable\n```\n\nThe update statement modifies the values in columns in a database table.\n\nThe tablename identifies the table that you want to update and must match the table name specified in the open statement for the specified cursor.\n\nEach column that you include in the update statement must also have been specified in the for update clause of the open statement that opened the cursor.\n\nThe optional corrname defines a correlation name for the table. Correlation names provide a shorthand way to refer to tables in a query.\n\nThe optional repeated keyword directs the DBMS to encode and save the query execution plan for the statement. This is a performance enhancement if you intend to execute this statement more than once.\n\nNote: Do not use the repeated keyword if you place the entire where clause, searchcondition, in a single variable or if a table name or column name is represented by a dynamic name.\n\n## Parameters--Update Statement\n\nThis statement has the following parameters:\n\n- tablename: Specifies the name of the database table that you want to update. This is a dynamic name.\n- corrname: Specifies the correlation name for the table. This is a dynamic name. This parameter is used only in the non-cursor version.\n- columnname: Specifies the name of a particular column to be updated in the table. This is a dynamic name.\n- dbexpression: Specifies a database expression\n- searchcondition: Specifies a logical database expression of conditions that must be satisfied by all rows selected. You can use simple variables (preceded by colons) in a search condition wherever you can use a literal. Alternatively, you can place the entire search condition in a single varchar variable, and specify the search condition as the name of this variable (proceeded by a colon). This parameter is only used in the non-cursor version.\n- cursor_variable: Specifies the reference variable that points to the CursorObject for which the statement is issued. Used only in the cursor version.\n- fromvariable: Specifies the entire from clause as a single varchar variable, preeded by a colon. This is a dynamic name.\n\n### Set Clause\n\nThe set clause specifies the columns in the table that you want to update.\n\n### Where Clause\n\nIf you do not include a where clause, OpenROAD updates all of the rows in the table. If you include a where clause, OpenROAD updates only the rows in the table that satisfy searchcondition in the where clause.\n\nThe \"where current of\" clause directs OpenROAD to update the row on which the specified cursor is positioned. The cursor_variable must point to a CursorObject that you opened using a for update clause.\n\n## Update Mode\n\nThe update mode of the cursor, specified when you opened the cursor, affects how you can use the update statement. You can open a cursor for deferred or direct update.\n\n### Deferred Mode\n\nWith deferred mode cursors, you can perform only one operation against each row. This operation can be an update or a delete but not both. Similarly, you cannot use the repeated option with a deferred update cursor. Cursors that are opened for direct update do not have these restrictions. However, if the cursor is a direct update cursor and you perform two cursor updates that are not separated by a fetch statement, you can update the same row twice.\n\nAfter a successful update, OpenROAD sets the IIrowcount system variable to one. The cursor remains pointing to the same row (the State attribute of the CursorObject remains CS_CURRENT) and subsequent update or delete statements for the cursor take effect on the same row. If the update is not successful, OpenROAD sets IIrowcount to -1 or 0.\n\nIf the cursor is not pointing to a row, 4GL generates a runtime error message indicating that you must execute a fetch statement. If the row the cursor is pointing to has been deleted from the underlying database table (as the result, for example, of a non-cursor delete), no row is updated.\n\nIt is not necessary to commit after each cursor update. All the changes that you make are committed when you close the cursor. (Do not update the current row of a cursor, commit the change, and then continue in a loop in order to repeat the process. This process fails because the first commit statement closes the cursor.)\n\nYou must issue any update statements for a cursor in the same session in which you opened the cursor.\n\nFor more information about the update statement, see the Programming Guide.\n\n## Examples--Update Statement\n\nUpdate rows in the projects table with values from the current frame:",
            "Update rows in the projects table with values from the current frame:\n\n```\nrepeated update projects\n     set hours = :hours, duedate = :enddate\n     where name = :name;\ncommit;\n```\n\nUpdate the personnel table with a computed value:\n\n```\nupdate personnel\n     set sal = :salary * 1.1\n     where empno = :empno;\ncommit;\n```\n\nUpdate the salaries of all employees in job category, acc, using the value for a standard raise in the table dept:\n\n```\nupdate employee e from dept d\n     set salary = d.std_raise * e.salary\n     where e.jobcat = 'acc' and d.dname = e.dname;\ncommit;\n```\n\nUpdate the vendor address based on the attributes of the addr reference variable:\n\n```\nupdate vendor\n     set city = :addr.city, state = :addr.state\n     where vendorno = :vno;\ncommit;\n```\n\nUpdate the row pointed to by the open cursor, emp_cursor:\n\n```\nupdate emptable\n     set name = :namefield, age = :agefield\n     where current of emp_cursor;\ncommit;\n```"
        ]
    },
    {
        "instruction": "What is a computed value in OpenROAD, and how would you use it to update a column in the personnel table?",
        "input": "",
        "output": "A computed value is a value calculated during runtime based on other values within the system. In OpenROAD, you can use a computed value to perform calculations like adding, subtracting, multiplying, or dividing values, and then store that result in a column of a table. To update a column using a computed value, you can write an `update` statement like this:\n\n```\nupdate personnel\n     set sal = :salary * 1.1\n     where empno = :empno;\ncommit;\n```\nIn this example, the computed value is the employee's salary multiplied by 1.1, which simulates a 10% raise for that specific row in the personnel table. The `where empno = :empno` clause restricts the update to only the row with the matching employee number.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->database_procedures",
        "task_description": "Explain the database procedures in Actian 4GL SQL and how they are used in OpenROAD.",
        "document": [
            "# Update Statement\n\nThis statement updates the values of the columns in a database table.\n\nThis statement has the following syntax:\n\n- Non-cursor version:\n  ```\n  [repeated] update tablename [corrname]\n       [from fromclause]\n       set columnname = dbexpression {, columnname =\n                 dbexpression}\n       [where searchcondition];\n  ```\n- Cursor version:\n  ```\n  update tablename set columnname = dbexpression\n       {, columnname = dbexpression} where current of\n            cursor_variable;\n  ```\n\nwhere fromclause has the following alternative syntaxes:\n```\nfrom tablename [corrname]{, tablename [corrname]}\nfrom :fromvariable\n```\n\nThe update statement modifies the values in columns in a database table.\n\nThe tablename identifies the table that you want to update and must match the table name specified in the open statement for the specified cursor.\n\nEach column that you include in the update statement must also have been specified in the for update clause of the open statement that opened the cursor.\n\nThe optional corrname defines a correlation name for the table. Correlation names provide a shorthand way to refer to tables in a query.\n\nThe optional repeated keyword directs the DBMS to encode and save the query execution plan for the statement. This is a performance enhancement if you intend to execute this statement more than once.\n\nNote: Do not use the repeated keyword if you place the entire where clause, searchcondition, in a single variable or if a table name or column name is represented by a dynamic name.\n\n## Parameters--Update Statement\n\nThis statement has the following parameters:\n\n- tablename: Specifies the name of the database table that you want to update. This is a dynamic name.\n- corrname: Specifies the correlation name for the table. This is a dynamic name. This parameter is used only in the non-cursor version.\n- columnname: Specifies the name of a particular column to be updated in the table. This is a dynamic name.\n- dbexpression: Specifies a database expression\n- searchcondition: Specifies a logical database expression of conditions that must be satisfied by all rows selected. You can use simple variables (preceded by colons) in a search condition wherever you can use a literal. Alternatively, you can place the entire search condition in a single varchar variable, and specify the search condition as the name of this variable (proceeded by a colon). This parameter is only used in the non-cursor version.\n- cursor_variable: Specifies the reference variable that points to the CursorObject for which the statement is issued. Used only in the cursor version.\n- fromvariable: Specifies the entire from clause as a single varchar variable, preeded by a colon. This is a dynamic name.\n\n### Set Clause\n\nThe set clause specifies the columns in the table that you want to update.\n\n### Where Clause\n\nIf you do not include a where clause, OpenROAD updates all of the rows in the table. If you include a where clause, OpenROAD updates only the rows in the table that satisfy searchcondition in the where clause.\n\nThe \"where current of\" clause directs OpenROAD to update the row on which the specified cursor is positioned. The cursor_variable must point to a CursorObject that you opened using a for update clause.\n\n## Update Mode\n\nThe update mode of the cursor, specified when you opened the cursor, affects how you can use the update statement. You can open a cursor for deferred or direct update.\n\n### Deferred Mode\n\nWith deferred mode cursors, you can perform only one operation against each row. This operation can be an update or a delete but not both. Similarly, you cannot use the repeated option with a deferred update cursor. Cursors that are opened for direct update do not have these restrictions. However, if the cursor is a direct update cursor and you perform two cursor updates that are not separated by a fetch statement, you can update the same row twice.\n\nAfter a successful update, OpenROAD sets the IIrowcount system variable to one. The cursor remains pointing to the same row (the State attribute of the CursorObject remains CS_CURRENT) and subsequent update or delete statements for the cursor take effect on the same row. If the update is not successful, OpenROAD sets IIrowcount to -1 or 0.\n\nIf the cursor is not pointing to a row, 4GL generates a runtime error message indicating that you must execute a fetch statement. If the row the cursor is pointing to has been deleted from the underlying database table (as the result, for example, of a non-cursor delete), no row is updated.\n\nIt is not necessary to commit after each cursor update. All the changes that you make are committed when you close the cursor. (Do not update the current row of a cursor, commit the change, and then continue in a loop in order to repeat the process. This process fails because the first commit statement closes the cursor.)\n\nYou must issue any update statements for a cursor in the same session in which you opened the cursor.\n\nFor more information about the update statement, see the Programming Guide.\n\n## Examples--Update Statement\n\nUpdate rows in the projects table with values from the current frame:",
            "Update rows in the projects table with values from the current frame:\n\n```\nrepeated update projects\n     set hours = :hours, duedate = :enddate\n     where name = :name;\ncommit;\n```\n\nUpdate the personnel table with a computed value:\n\n```\nupdate personnel\n     set sal = :salary * 1.1\n     where empno = :empno;\ncommit;\n```\n\nUpdate the salaries of all employees in job category, acc, using the value for a standard raise in the table dept:\n\n```\nupdate employee e from dept d\n     set salary = d.std_raise * e.salary\n     where e.jobcat = 'acc' and d.dname = e.dname;\ncommit;\n```\n\nUpdate the vendor address based on the attributes of the addr reference variable:\n\n```\nupdate vendor\n     set city = :addr.city, state = :addr.state\n     where vendorno = :vno;\ncommit;\n```\n\nUpdate the row pointed to by the open cursor, emp_cursor:\n\n```\nupdate emptable\n     set name = :namefield, age = :agefield\n     where current of emp_cursor;\ncommit;\n```"
        ]
    },
    {
        "instruction": "Describe the use case scenario of using the update statement in Actian 4GL SQL within OpenROAD.",
        "input": "",
        "output": "The update statement is used when we want to modify existing data within a table in the database. A common use case could be updating an employee's salary, address, or any other attribute that might change over time. For example:\n```sql\nupdate employees set salary = 6000 where employee_id = 123;\n```\nThis statement will update the salary of the employee with ID `123` to `6000`.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->database_procedures",
        "task_description": "Explain the database procedures in Actian 4GL SQL and how they are used in OpenROAD.",
        "document": [
            "# Update Statement\n\nThis statement updates the values of the columns in a database table.\n\nThis statement has the following syntax:\n\n- Non-cursor version:\n  ```\n  [repeated] update tablename [corrname]\n       [from fromclause]\n       set columnname = dbexpression {, columnname =\n                 dbexpression}\n       [where searchcondition];\n  ```\n- Cursor version:\n  ```\n  update tablename set columnname = dbexpression\n       {, columnname = dbexpression} where current of\n            cursor_variable;\n  ```\n\nwhere fromclause has the following alternative syntaxes:\n```\nfrom tablename [corrname]{, tablename [corrname]}\nfrom :fromvariable\n```\n\nThe update statement modifies the values in columns in a database table.\n\nThe tablename identifies the table that you want to update and must match the table name specified in the open statement for the specified cursor.\n\nEach column that you include in the update statement must also have been specified in the for update clause of the open statement that opened the cursor.\n\nThe optional corrname defines a correlation name for the table. Correlation names provide a shorthand way to refer to tables in a query.\n\nThe optional repeated keyword directs the DBMS to encode and save the query execution plan for the statement. This is a performance enhancement if you intend to execute this statement more than once.\n\nNote: Do not use the repeated keyword if you place the entire where clause, searchcondition, in a single variable or if a table name or column name is represented by a dynamic name.\n\n## Parameters--Update Statement\n\nThis statement has the following parameters:\n\n- tablename: Specifies the name of the database table that you want to update. This is a dynamic name.\n- corrname: Specifies the correlation name for the table. This is a dynamic name. This parameter is used only in the non-cursor version.\n- columnname: Specifies the name of a particular column to be updated in the table. This is a dynamic name.\n- dbexpression: Specifies a database expression\n- searchcondition: Specifies a logical database expression of conditions that must be satisfied by all rows selected. You can use simple variables (preceded by colons) in a search condition wherever you can use a literal. Alternatively, you can place the entire search condition in a single varchar variable, and specify the search condition as the name of this variable (proceeded by a colon). This parameter is only used in the non-cursor version.\n- cursor_variable: Specifies the reference variable that points to the CursorObject for which the statement is issued. Used only in the cursor version.\n- fromvariable: Specifies the entire from clause as a single varchar variable, preeded by a colon. This is a dynamic name.\n\n### Set Clause\n\nThe set clause specifies the columns in the table that you want to update.\n\n### Where Clause\n\nIf you do not include a where clause, OpenROAD updates all of the rows in the table. If you include a where clause, OpenROAD updates only the rows in the table that satisfy searchcondition in the where clause.\n\nThe \"where current of\" clause directs OpenROAD to update the row on which the specified cursor is positioned. The cursor_variable must point to a CursorObject that you opened using a for update clause.\n\n## Update Mode\n\nThe update mode of the cursor, specified when you opened the cursor, affects how you can use the update statement. You can open a cursor for deferred or direct update.\n\n### Deferred Mode\n\nWith deferred mode cursors, you can perform only one operation against each row. This operation can be an update or a delete but not both. Similarly, you cannot use the repeated option with a deferred update cursor. Cursors that are opened for direct update do not have these restrictions. However, if the cursor is a direct update cursor and you perform two cursor updates that are not separated by a fetch statement, you can update the same row twice.\n\nAfter a successful update, OpenROAD sets the IIrowcount system variable to one. The cursor remains pointing to the same row (the State attribute of the CursorObject remains CS_CURRENT) and subsequent update or delete statements for the cursor take effect on the same row. If the update is not successful, OpenROAD sets IIrowcount to -1 or 0.\n\nIf the cursor is not pointing to a row, 4GL generates a runtime error message indicating that you must execute a fetch statement. If the row the cursor is pointing to has been deleted from the underlying database table (as the result, for example, of a non-cursor delete), no row is updated.\n\nIt is not necessary to commit after each cursor update. All the changes that you make are committed when you close the cursor. (Do not update the current row of a cursor, commit the change, and then continue in a loop in order to repeat the process. This process fails because the first commit statement closes the cursor.)\n\nYou must issue any update statements for a cursor in the same session in which you opened the cursor.\n\nFor more information about the update statement, see the Programming Guide.\n\n## Examples--Update Statement\n\nUpdate rows in the projects table with values from the current frame:",
            "Update rows in the projects table with values from the current frame:\n\n```\nrepeated update projects\n     set hours = :hours, duedate = :enddate\n     where name = :name;\ncommit;\n```\n\nUpdate the personnel table with a computed value:\n\n```\nupdate personnel\n     set sal = :salary * 1.1\n     where empno = :empno;\ncommit;\n```\n\nUpdate the salaries of all employees in job category, acc, using the value for a standard raise in the table dept:\n\n```\nupdate employee e from dept d\n     set salary = d.std_raise * e.salary\n     where e.jobcat = 'acc' and d.dname = e.dname;\ncommit;\n```\n\nUpdate the vendor address based on the attributes of the addr reference variable:\n\n```\nupdate vendor\n     set city = :addr.city, state = :addr.state\n     where vendorno = :vno;\ncommit;\n```\n\nUpdate the row pointed to by the open cursor, emp_cursor:\n\n```\nupdate emptable\n     set name = :namefield, age = :agefield\n     where current of emp_cursor;\ncommit;\n```"
        ]
    },
    {
        "instruction": "What is the difference between deferred mode and direct update mode in Actian 4GL SQL?",
        "input": "",
        "output": "In Actian 4GL SQL, when a cursor is opened for deferred update mode, only one operation (either an update or delete) can be performed against each row. On the other hand, a cursor opened in direct update mode allows multiple operations to be performed on the same row without needing to fetch again. Another key difference is that with deferred mode, you cannot use the repeated option while in direct update mode, this limitation does not apply.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->database_procedures",
        "task_description": "Explain the database procedures in Actian 4GL SQL and how they are used in OpenROAD.",
        "document": [
            "# Update Statement\n\nThis statement updates the values of the columns in a database table.\n\nThis statement has the following syntax:\n\n- Non-cursor version:\n  ```\n  [repeated] update tablename [corrname]\n       [from fromclause]\n       set columnname = dbexpression {, columnname =\n                 dbexpression}\n       [where searchcondition];\n  ```\n- Cursor version:\n  ```\n  update tablename set columnname = dbexpression\n       {, columnname = dbexpression} where current of\n            cursor_variable;\n  ```\n\nwhere fromclause has the following alternative syntaxes:\n```\nfrom tablename [corrname]{, tablename [corrname]}\nfrom :fromvariable\n```\n\nThe update statement modifies the values in columns in a database table.\n\nThe tablename identifies the table that you want to update and must match the table name specified in the open statement for the specified cursor.\n\nEach column that you include in the update statement must also have been specified in the for update clause of the open statement that opened the cursor.\n\nThe optional corrname defines a correlation name for the table. Correlation names provide a shorthand way to refer to tables in a query.\n\nThe optional repeated keyword directs the DBMS to encode and save the query execution plan for the statement. This is a performance enhancement if you intend to execute this statement more than once.\n\nNote: Do not use the repeated keyword if you place the entire where clause, searchcondition, in a single variable or if a table name or column name is represented by a dynamic name.\n\n## Parameters--Update Statement\n\nThis statement has the following parameters:\n\n- tablename: Specifies the name of the database table that you want to update. This is a dynamic name.\n- corrname: Specifies the correlation name for the table. This is a dynamic name. This parameter is used only in the non-cursor version.\n- columnname: Specifies the name of a particular column to be updated in the table. This is a dynamic name.\n- dbexpression: Specifies a database expression\n- searchcondition: Specifies a logical database expression of conditions that must be satisfied by all rows selected. You can use simple variables (preceded by colons) in a search condition wherever you can use a literal. Alternatively, you can place the entire search condition in a single varchar variable, and specify the search condition as the name of this variable (proceeded by a colon). This parameter is only used in the non-cursor version.\n- cursor_variable: Specifies the reference variable that points to the CursorObject for which the statement is issued. Used only in the cursor version.\n- fromvariable: Specifies the entire from clause as a single varchar variable, preeded by a colon. This is a dynamic name.\n\n### Set Clause\n\nThe set clause specifies the columns in the table that you want to update.\n\n### Where Clause\n\nIf you do not include a where clause, OpenROAD updates all of the rows in the table. If you include a where clause, OpenROAD updates only the rows in the table that satisfy searchcondition in the where clause.\n\nThe \"where current of\" clause directs OpenROAD to update the row on which the specified cursor is positioned. The cursor_variable must point to a CursorObject that you opened using a for update clause.\n\n## Update Mode\n\nThe update mode of the cursor, specified when you opened the cursor, affects how you can use the update statement. You can open a cursor for deferred or direct update.\n\n### Deferred Mode\n\nWith deferred mode cursors, you can perform only one operation against each row. This operation can be an update or a delete but not both. Similarly, you cannot use the repeated option with a deferred update cursor. Cursors that are opened for direct update do not have these restrictions. However, if the cursor is a direct update cursor and you perform two cursor updates that are not separated by a fetch statement, you can update the same row twice.\n\nAfter a successful update, OpenROAD sets the IIrowcount system variable to one. The cursor remains pointing to the same row (the State attribute of the CursorObject remains CS_CURRENT) and subsequent update or delete statements for the cursor take effect on the same row. If the update is not successful, OpenROAD sets IIrowcount to -1 or 0.\n\nIf the cursor is not pointing to a row, 4GL generates a runtime error message indicating that you must execute a fetch statement. If the row the cursor is pointing to has been deleted from the underlying database table (as the result, for example, of a non-cursor delete), no row is updated.\n\nIt is not necessary to commit after each cursor update. All the changes that you make are committed when you close the cursor. (Do not update the current row of a cursor, commit the change, and then continue in a loop in order to repeat the process. This process fails because the first commit statement closes the cursor.)\n\nYou must issue any update statements for a cursor in the same session in which you opened the cursor.\n\nFor more information about the update statement, see the Programming Guide.\n\n## Examples--Update Statement\n\nUpdate rows in the projects table with values from the current frame:",
            "Update rows in the projects table with values from the current frame:\n\n```\nrepeated update projects\n     set hours = :hours, duedate = :enddate\n     where name = :name;\ncommit;\n```\n\nUpdate the personnel table with a computed value:\n\n```\nupdate personnel\n     set sal = :salary * 1.1\n     where empno = :empno;\ncommit;\n```\n\nUpdate the salaries of all employees in job category, acc, using the value for a standard raise in the table dept:\n\n```\nupdate employee e from dept d\n     set salary = d.std_raise * e.salary\n     where e.jobcat = 'acc' and d.dname = e.dname;\ncommit;\n```\n\nUpdate the vendor address based on the attributes of the addr reference variable:\n\n```\nupdate vendor\n     set city = :addr.city, state = :addr.state\n     where vendorno = :vno;\ncommit;\n```\n\nUpdate the row pointed to by the open cursor, emp_cursor:\n\n```\nupdate emptable\n     set name = :namefield, age = :agefield\n     where current of emp_cursor;\ncommit;\n```"
        ]
    },
    {
        "instruction": "Describe how can you use a cursor in Actian 4GL SQL and provide an example.",
        "input": "",
        "output": "A cursor is a server-side database object used to store a result set of rows from a SELECT statement or a stored procedure. You can use cursors in Actian 4GL SQL to iterate through the rows of a result set and process them one at a time. Here's an example:\n\n```\ndeclare employee_cursor cursor for\n    select * from employees where salary > 5000;\n\nopen employee_cursor;\n\nloop\n    fetch employee_cursor into :employee_record;\n    if sqlca.sqlcode = 0 then\n        -- process the record here, e.g., update its status\n        update employees set status = 'High Salary' where empno = :employee_record.empno;\n    end if;\n    exit when not found;\nend loop;\n\nclose employee_cursor;\n```\n\nIn this example, we have declared a cursor named `employee_cursor` to fetch all the employees with salaries greater than 5000. We then open the cursor and enter a loop that fetches one record at a time until no more records are found. Inside the loop, we process the record (e.g., update its status) and proceed to the next record if there is one. Once all records have been processed, we close the cursor.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->database_procedures",
        "task_description": "Explain the database procedures in Actian 4GL SQL and how they are used in OpenROAD.",
        "document": [
            "# Update Statement\n\nThis statement updates the values of the columns in a database table.\n\nThis statement has the following syntax:\n\n- Non-cursor version:\n  ```\n  [repeated] update tablename [corrname]\n       [from fromclause]\n       set columnname = dbexpression {, columnname =\n                 dbexpression}\n       [where searchcondition];\n  ```\n- Cursor version:\n  ```\n  update tablename set columnname = dbexpression\n       {, columnname = dbexpression} where current of\n            cursor_variable;\n  ```\n\nwhere fromclause has the following alternative syntaxes:\n```\nfrom tablename [corrname]{, tablename [corrname]}\nfrom :fromvariable\n```\n\nThe update statement modifies the values in columns in a database table.\n\nThe tablename identifies the table that you want to update and must match the table name specified in the open statement for the specified cursor.\n\nEach column that you include in the update statement must also have been specified in the for update clause of the open statement that opened the cursor.\n\nThe optional corrname defines a correlation name for the table. Correlation names provide a shorthand way to refer to tables in a query.\n\nThe optional repeated keyword directs the DBMS to encode and save the query execution plan for the statement. This is a performance enhancement if you intend to execute this statement more than once.\n\nNote: Do not use the repeated keyword if you place the entire where clause, searchcondition, in a single variable or if a table name or column name is represented by a dynamic name.\n\n## Parameters--Update Statement\n\nThis statement has the following parameters:\n\n- tablename: Specifies the name of the database table that you want to update. This is a dynamic name.\n- corrname: Specifies the correlation name for the table. This is a dynamic name. This parameter is used only in the non-cursor version.\n- columnname: Specifies the name of a particular column to be updated in the table. This is a dynamic name.\n- dbexpression: Specifies a database expression\n- searchcondition: Specifies a logical database expression of conditions that must be satisfied by all rows selected. You can use simple variables (preceded by colons) in a search condition wherever you can use a literal. Alternatively, you can place the entire search condition in a single varchar variable, and specify the search condition as the name of this variable (proceeded by a colon). This parameter is only used in the non-cursor version.\n- cursor_variable: Specifies the reference variable that points to the CursorObject for which the statement is issued. Used only in the cursor version.\n- fromvariable: Specifies the entire from clause as a single varchar variable, preeded by a colon. This is a dynamic name.\n\n### Set Clause\n\nThe set clause specifies the columns in the table that you want to update.\n\n### Where Clause\n\nIf you do not include a where clause, OpenROAD updates all of the rows in the table. If you include a where clause, OpenROAD updates only the rows in the table that satisfy searchcondition in the where clause.\n\nThe \"where current of\" clause directs OpenROAD to update the row on which the specified cursor is positioned. The cursor_variable must point to a CursorObject that you opened using a for update clause.\n\n## Update Mode\n\nThe update mode of the cursor, specified when you opened the cursor, affects how you can use the update statement. You can open a cursor for deferred or direct update.\n\n### Deferred Mode\n\nWith deferred mode cursors, you can perform only one operation against each row. This operation can be an update or a delete but not both. Similarly, you cannot use the repeated option with a deferred update cursor. Cursors that are opened for direct update do not have these restrictions. However, if the cursor is a direct update cursor and you perform two cursor updates that are not separated by a fetch statement, you can update the same row twice.\n\nAfter a successful update, OpenROAD sets the IIrowcount system variable to one. The cursor remains pointing to the same row (the State attribute of the CursorObject remains CS_CURRENT) and subsequent update or delete statements for the cursor take effect on the same row. If the update is not successful, OpenROAD sets IIrowcount to -1 or 0.\n\nIf the cursor is not pointing to a row, 4GL generates a runtime error message indicating that you must execute a fetch statement. If the row the cursor is pointing to has been deleted from the underlying database table (as the result, for example, of a non-cursor delete), no row is updated.\n\nIt is not necessary to commit after each cursor update. All the changes that you make are committed when you close the cursor. (Do not update the current row of a cursor, commit the change, and then continue in a loop in order to repeat the process. This process fails because the first commit statement closes the cursor.)\n\nYou must issue any update statements for a cursor in the same session in which you opened the cursor.\n\nFor more information about the update statement, see the Programming Guide.\n\n## Examples--Update Statement\n\nUpdate rows in the projects table with values from the current frame:",
            "Update rows in the projects table with values from the current frame:\n\n```\nrepeated update projects\n     set hours = :hours, duedate = :enddate\n     where name = :name;\ncommit;\n```\n\nUpdate the personnel table with a computed value:\n\n```\nupdate personnel\n     set sal = :salary * 1.1\n     where empno = :empno;\ncommit;\n```\n\nUpdate the salaries of all employees in job category, acc, using the value for a standard raise in the table dept:\n\n```\nupdate employee e from dept d\n     set salary = d.std_raise * e.salary\n     where e.jobcat = 'acc' and d.dname = e.dname;\ncommit;\n```\n\nUpdate the vendor address based on the attributes of the addr reference variable:\n\n```\nupdate vendor\n     set city = :addr.city, state = :addr.state\n     where vendorno = :vno;\ncommit;\n```\n\nUpdate the row pointed to by the open cursor, emp_cursor:\n\n```\nupdate emptable\n     set name = :namefield, age = :agefield\n     where current of emp_cursor;\ncommit;\n```"
        ]
    },
    {
        "instruction": "How can you perform a bulk update operation in Actian 4GL SQL using an array?",
        "input": "",
        "output": "Actian 4GL SQL provides the `FOR` loop and `FOR EACH` statement to perform bulk updates using arrays. Here's an example:\n\n```\ndeclare emp_arr array[1..50] of employee;\n\nselect employee into emp_arr from employees where jobcat = 'acc';\n\nfor i in 1..50 loop\n    update employee set salary = emp_arr[i].salary + 100 where empno = emp_arr[i].empno;\nend loop;\n```\n\nIn this example, we have declared an array `emp_arr` to store the records of employees in the 'acc' job category. We then use the `SELECT` statement to fetch those records into the array. Finally, we perform a bulk update operation by iterating through the array using a `FOR` loop and updating each employee's salary by an additional 100 dollars.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->database_procedures",
        "task_description": "Explain the database procedures in Actian 4GL SQL and how they are used in OpenROAD.",
        "document": [
            "# Update Statement\n\nThis statement updates the values of the columns in a database table.\n\nThis statement has the following syntax:\n\n- Non-cursor version:\n  ```\n  [repeated] update tablename [corrname]\n       [from fromclause]\n       set columnname = dbexpression {, columnname =\n                 dbexpression}\n       [where searchcondition];\n  ```\n- Cursor version:\n  ```\n  update tablename set columnname = dbexpression\n       {, columnname = dbexpression} where current of\n            cursor_variable;\n  ```\n\nwhere fromclause has the following alternative syntaxes:\n```\nfrom tablename [corrname]{, tablename [corrname]}\nfrom :fromvariable\n```\n\nThe update statement modifies the values in columns in a database table.\n\nThe tablename identifies the table that you want to update and must match the table name specified in the open statement for the specified cursor.\n\nEach column that you include in the update statement must also have been specified in the for update clause of the open statement that opened the cursor.\n\nThe optional corrname defines a correlation name for the table. Correlation names provide a shorthand way to refer to tables in a query.\n\nThe optional repeated keyword directs the DBMS to encode and save the query execution plan for the statement. This is a performance enhancement if you intend to execute this statement more than once.\n\nNote: Do not use the repeated keyword if you place the entire where clause, searchcondition, in a single variable or if a table name or column name is represented by a dynamic name.\n\n## Parameters--Update Statement\n\nThis statement has the following parameters:\n\n- tablename: Specifies the name of the database table that you want to update. This is a dynamic name.\n- corrname: Specifies the correlation name for the table. This is a dynamic name. This parameter is used only in the non-cursor version.\n- columnname: Specifies the name of a particular column to be updated in the table. This is a dynamic name.\n- dbexpression: Specifies a database expression\n- searchcondition: Specifies a logical database expression of conditions that must be satisfied by all rows selected. You can use simple variables (preceded by colons) in a search condition wherever you can use a literal. Alternatively, you can place the entire search condition in a single varchar variable, and specify the search condition as the name of this variable (proceeded by a colon). This parameter is only used in the non-cursor version.\n- cursor_variable: Specifies the reference variable that points to the CursorObject for which the statement is issued. Used only in the cursor version.\n- fromvariable: Specifies the entire from clause as a single varchar variable, preeded by a colon. This is a dynamic name.\n\n### Set Clause\n\nThe set clause specifies the columns in the table that you want to update.\n\n### Where Clause\n\nIf you do not include a where clause, OpenROAD updates all of the rows in the table. If you include a where clause, OpenROAD updates only the rows in the table that satisfy searchcondition in the where clause.\n\nThe \"where current of\" clause directs OpenROAD to update the row on which the specified cursor is positioned. The cursor_variable must point to a CursorObject that you opened using a for update clause.\n\n## Update Mode\n\nThe update mode of the cursor, specified when you opened the cursor, affects how you can use the update statement. You can open a cursor for deferred or direct update.\n\n### Deferred Mode\n\nWith deferred mode cursors, you can perform only one operation against each row. This operation can be an update or a delete but not both. Similarly, you cannot use the repeated option with a deferred update cursor. Cursors that are opened for direct update do not have these restrictions. However, if the cursor is a direct update cursor and you perform two cursor updates that are not separated by a fetch statement, you can update the same row twice.\n\nAfter a successful update, OpenROAD sets the IIrowcount system variable to one. The cursor remains pointing to the same row (the State attribute of the CursorObject remains CS_CURRENT) and subsequent update or delete statements for the cursor take effect on the same row. If the update is not successful, OpenROAD sets IIrowcount to -1 or 0.\n\nIf the cursor is not pointing to a row, 4GL generates a runtime error message indicating that you must execute a fetch statement. If the row the cursor is pointing to has been deleted from the underlying database table (as the result, for example, of a non-cursor delete), no row is updated.\n\nIt is not necessary to commit after each cursor update. All the changes that you make are committed when you close the cursor. (Do not update the current row of a cursor, commit the change, and then continue in a loop in order to repeat the process. This process fails because the first commit statement closes the cursor.)\n\nYou must issue any update statements for a cursor in the same session in which you opened the cursor.\n\nFor more information about the update statement, see the Programming Guide.\n\n## Examples--Update Statement\n\nUpdate rows in the projects table with values from the current frame:",
            "Update rows in the projects table with values from the current frame:\n\n```\nrepeated update projects\n     set hours = :hours, duedate = :enddate\n     where name = :name;\ncommit;\n```\n\nUpdate the personnel table with a computed value:\n\n```\nupdate personnel\n     set sal = :salary * 1.1\n     where empno = :empno;\ncommit;\n```\n\nUpdate the salaries of all employees in job category, acc, using the value for a standard raise in the table dept:\n\n```\nupdate employee e from dept d\n     set salary = d.std_raise * e.salary\n     where e.jobcat = 'acc' and d.dname = e.dname;\ncommit;\n```\n\nUpdate the vendor address based on the attributes of the addr reference variable:\n\n```\nupdate vendor\n     set city = :addr.city, state = :addr.state\n     where vendorno = :vno;\ncommit;\n```\n\nUpdate the row pointed to by the open cursor, emp_cursor:\n\n```\nupdate emptable\n     set name = :namefield, age = :agefield\n     where current of emp_cursor;\ncommit;\n```"
        ]
    },
    {
        "instruction": "What are some best practices for handling errors during database updates in Actian 4GL SQL?",
        "input": "",
        "output": "Handling errors during database updates is crucial to ensure the integrity of your data and the stability of your application. In Actian 4GL SQL, you can handle errors by using the `ON CONTROL ERROR` clause in your UPDATE statement or by checking the `SQLCA` structure for error codes after performing an update operation. Here are some best practices:\n\n1. Use the `ON CONTROL ERROR` clause to specify a routine that will be called if an error occurs during the update operation. This allows you to handle errors in a centralized manner and prevents them from causing your entire application to fail.\n\n```\nupdate employees set salary = salary + 50 on control error go to my_error_routine;\n```\n\n2. Check the `SQLCA` structure after each update operation to see if an error occurred (`SQLCA.SQLCODE != 0`). If an error occurs, handle it appropriately by logging the error and possibly rolling back the transaction.\n3. Use transactions to ensure that multiple updates are either all committed successfully or rolled back if an error occurs.\n4. Use the `commit` statement at appropriate points in your code to ensure that changes are saved when they are intended to be saved.\n5. Use the `rollback` statement if you need to roll back a transaction because of an error or any other reason.\n6. Implement a good error handling strategy that includes logging errors, notifying administrators, and providing useful information about the error to help debugging.\n7. Test your code thoroughly to ensure that it handles errors gracefully and does not cause unexpected behavior or data inconsistencies.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->database_procedures",
        "task_description": "Explain the database procedures in Actian 4GL SQL and how they are used in OpenROAD.",
        "document": [
            "# Update Statement\n\nThis statement updates the values of the columns in a database table.\n\nThis statement has the following syntax:\n\n- Non-cursor version:\n  ```\n  [repeated] update tablename [corrname]\n       [from fromclause]\n       set columnname = dbexpression {, columnname =\n                 dbexpression}\n       [where searchcondition];\n  ```\n- Cursor version:\n  ```\n  update tablename set columnname = dbexpression\n       {, columnname = dbexpression} where current of\n            cursor_variable;\n  ```\n\nwhere fromclause has the following alternative syntaxes:\n```\nfrom tablename [corrname]{, tablename [corrname]}\nfrom :fromvariable\n```\n\nThe update statement modifies the values in columns in a database table.\n\nThe tablename identifies the table that you want to update and must match the table name specified in the open statement for the specified cursor.\n\nEach column that you include in the update statement must also have been specified in the for update clause of the open statement that opened the cursor.\n\nThe optional corrname defines a correlation name for the table. Correlation names provide a shorthand way to refer to tables in a query.\n\nThe optional repeated keyword directs the DBMS to encode and save the query execution plan for the statement. This is a performance enhancement if you intend to execute this statement more than once.\n\nNote: Do not use the repeated keyword if you place the entire where clause, searchcondition, in a single variable or if a table name or column name is represented by a dynamic name.\n\n## Parameters--Update Statement\n\nThis statement has the following parameters:\n\n- tablename: Specifies the name of the database table that you want to update. This is a dynamic name.\n- corrname: Specifies the correlation name for the table. This is a dynamic name. This parameter is used only in the non-cursor version.\n- columnname: Specifies the name of a particular column to be updated in the table. This is a dynamic name.\n- dbexpression: Specifies a database expression\n- searchcondition: Specifies a logical database expression of conditions that must be satisfied by all rows selected. You can use simple variables (preceded by colons) in a search condition wherever you can use a literal. Alternatively, you can place the entire search condition in a single varchar variable, and specify the search condition as the name of this variable (proceeded by a colon). This parameter is only used in the non-cursor version.\n- cursor_variable: Specifies the reference variable that points to the CursorObject for which the statement is issued. Used only in the cursor version.\n- fromvariable: Specifies the entire from clause as a single varchar variable, preeded by a colon. This is a dynamic name.\n\n### Set Clause\n\nThe set clause specifies the columns in the table that you want to update.\n\n### Where Clause\n\nIf you do not include a where clause, OpenROAD updates all of the rows in the table. If you include a where clause, OpenROAD updates only the rows in the table that satisfy searchcondition in the where clause.\n\nThe \"where current of\" clause directs OpenROAD to update the row on which the specified cursor is positioned. The cursor_variable must point to a CursorObject that you opened using a for update clause.\n\n## Update Mode\n\nThe update mode of the cursor, specified when you opened the cursor, affects how you can use the update statement. You can open a cursor for deferred or direct update.\n\n### Deferred Mode\n\nWith deferred mode cursors, you can perform only one operation against each row. This operation can be an update or a delete but not both. Similarly, you cannot use the repeated option with a deferred update cursor. Cursors that are opened for direct update do not have these restrictions. However, if the cursor is a direct update cursor and you perform two cursor updates that are not separated by a fetch statement, you can update the same row twice.\n\nAfter a successful update, OpenROAD sets the IIrowcount system variable to one. The cursor remains pointing to the same row (the State attribute of the CursorObject remains CS_CURRENT) and subsequent update or delete statements for the cursor take effect on the same row. If the update is not successful, OpenROAD sets IIrowcount to -1 or 0.\n\nIf the cursor is not pointing to a row, 4GL generates a runtime error message indicating that you must execute a fetch statement. If the row the cursor is pointing to has been deleted from the underlying database table (as the result, for example, of a non-cursor delete), no row is updated.\n\nIt is not necessary to commit after each cursor update. All the changes that you make are committed when you close the cursor. (Do not update the current row of a cursor, commit the change, and then continue in a loop in order to repeat the process. This process fails because the first commit statement closes the cursor.)\n\nYou must issue any update statements for a cursor in the same session in which you opened the cursor.\n\nFor more information about the update statement, see the Programming Guide.\n\n## Examples--Update Statement\n\nUpdate rows in the projects table with values from the current frame:",
            "Update rows in the projects table with values from the current frame:\n\n```\nrepeated update projects\n     set hours = :hours, duedate = :enddate\n     where name = :name;\ncommit;\n```\n\nUpdate the personnel table with a computed value:\n\n```\nupdate personnel\n     set sal = :salary * 1.1\n     where empno = :empno;\ncommit;\n```\n\nUpdate the salaries of all employees in job category, acc, using the value for a standard raise in the table dept:\n\n```\nupdate employee e from dept d\n     set salary = d.std_raise * e.salary\n     where e.jobcat = 'acc' and d.dname = e.dname;\ncommit;\n```\n\nUpdate the vendor address based on the attributes of the addr reference variable:\n\n```\nupdate vendor\n     set city = :addr.city, state = :addr.state\n     where vendorno = :vno;\ncommit;\n```\n\nUpdate the row pointed to by the open cursor, emp_cursor:\n\n```\nupdate emptable\n     set name = :namefield, age = :agefield\n     where current of emp_cursor;\ncommit;\n```"
        ]
    },
    {
        "instruction": "Explain how OpenROAD uses Actian 4GL SQL cursors for data manipulation.",
        "input": "",
        "output": "OpenROAD, a database development tool by Actian, utilizes Actian 4GL SQL cursors to facilitate data manipulation tasks such as inserting, updating, and deleting records in tables. A cursor is essentially a reference to a result set that can be used as a means of iterating through the rows of the result set. OpenROAD offers multiple types of cursors including static, dynamic, scrollable, and open cursors. These different types allow developers to implement various data manipulation strategies depending on their needs. For example, a developer might use an open cursor to update the row pointed to by the cursor after fetching it, or they might use a scrollable cursor to scroll backward through a result set and perform an action on a particular row.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->database_procedures",
        "task_description": "Explain the database procedures in Actian 4GL SQL and how they are used in OpenROAD.",
        "document": [
            "# Update Statement\n\nThis statement updates the values of the columns in a database table.\n\nThis statement has the following syntax:\n\n- Non-cursor version:\n  ```\n  [repeated] update tablename [corrname]\n       [from fromclause]\n       set columnname = dbexpression {, columnname =\n                 dbexpression}\n       [where searchcondition];\n  ```\n- Cursor version:\n  ```\n  update tablename set columnname = dbexpression\n       {, columnname = dbexpression} where current of\n            cursor_variable;\n  ```\n\nwhere fromclause has the following alternative syntaxes:\n```\nfrom tablename [corrname]{, tablename [corrname]}\nfrom :fromvariable\n```\n\nThe update statement modifies the values in columns in a database table.\n\nThe tablename identifies the table that you want to update and must match the table name specified in the open statement for the specified cursor.\n\nEach column that you include in the update statement must also have been specified in the for update clause of the open statement that opened the cursor.\n\nThe optional corrname defines a correlation name for the table. Correlation names provide a shorthand way to refer to tables in a query.\n\nThe optional repeated keyword directs the DBMS to encode and save the query execution plan for the statement. This is a performance enhancement if you intend to execute this statement more than once.\n\nNote: Do not use the repeated keyword if you place the entire where clause, searchcondition, in a single variable or if a table name or column name is represented by a dynamic name.\n\n## Parameters--Update Statement\n\nThis statement has the following parameters:\n\n- tablename: Specifies the name of the database table that you want to update. This is a dynamic name.\n- corrname: Specifies the correlation name for the table. This is a dynamic name. This parameter is used only in the non-cursor version.\n- columnname: Specifies the name of a particular column to be updated in the table. This is a dynamic name.\n- dbexpression: Specifies a database expression\n- searchcondition: Specifies a logical database expression of conditions that must be satisfied by all rows selected. You can use simple variables (preceded by colons) in a search condition wherever you can use a literal. Alternatively, you can place the entire search condition in a single varchar variable, and specify the search condition as the name of this variable (proceeded by a colon). This parameter is only used in the non-cursor version.\n- cursor_variable: Specifies the reference variable that points to the CursorObject for which the statement is issued. Used only in the cursor version.\n- fromvariable: Specifies the entire from clause as a single varchar variable, preeded by a colon. This is a dynamic name.\n\n### Set Clause\n\nThe set clause specifies the columns in the table that you want to update.\n\n### Where Clause\n\nIf you do not include a where clause, OpenROAD updates all of the rows in the table. If you include a where clause, OpenROAD updates only the rows in the table that satisfy searchcondition in the where clause.\n\nThe \"where current of\" clause directs OpenROAD to update the row on which the specified cursor is positioned. The cursor_variable must point to a CursorObject that you opened using a for update clause.\n\n## Update Mode\n\nThe update mode of the cursor, specified when you opened the cursor, affects how you can use the update statement. You can open a cursor for deferred or direct update.\n\n### Deferred Mode\n\nWith deferred mode cursors, you can perform only one operation against each row. This operation can be an update or a delete but not both. Similarly, you cannot use the repeated option with a deferred update cursor. Cursors that are opened for direct update do not have these restrictions. However, if the cursor is a direct update cursor and you perform two cursor updates that are not separated by a fetch statement, you can update the same row twice.\n\nAfter a successful update, OpenROAD sets the IIrowcount system variable to one. The cursor remains pointing to the same row (the State attribute of the CursorObject remains CS_CURRENT) and subsequent update or delete statements for the cursor take effect on the same row. If the update is not successful, OpenROAD sets IIrowcount to -1 or 0.\n\nIf the cursor is not pointing to a row, 4GL generates a runtime error message indicating that you must execute a fetch statement. If the row the cursor is pointing to has been deleted from the underlying database table (as the result, for example, of a non-cursor delete), no row is updated.\n\nIt is not necessary to commit after each cursor update. All the changes that you make are committed when you close the cursor. (Do not update the current row of a cursor, commit the change, and then continue in a loop in order to repeat the process. This process fails because the first commit statement closes the cursor.)\n\nYou must issue any update statements for a cursor in the same session in which you opened the cursor.\n\nFor more information about the update statement, see the Programming Guide.\n\n## Examples--Update Statement\n\nUpdate rows in the projects table with values from the current frame:",
            "Update rows in the projects table with values from the current frame:\n\n```\nrepeated update projects\n     set hours = :hours, duedate = :enddate\n     where name = :name;\ncommit;\n```\n\nUpdate the personnel table with a computed value:\n\n```\nupdate personnel\n     set sal = :salary * 1.1\n     where empno = :empno;\ncommit;\n```\n\nUpdate the salaries of all employees in job category, acc, using the value for a standard raise in the table dept:\n\n```\nupdate employee e from dept d\n     set salary = d.std_raise * e.salary\n     where e.jobcat = 'acc' and d.dname = e.dname;\ncommit;\n```\n\nUpdate the vendor address based on the attributes of the addr reference variable:\n\n```\nupdate vendor\n     set city = :addr.city, state = :addr.state\n     where vendorno = :vno;\ncommit;\n```\n\nUpdate the row pointed to by the open cursor, emp_cursor:\n\n```\nupdate emptable\n     set name = :namefield, age = :agefield\n     where current of emp_cursor;\ncommit;\n```"
        ]
    },
    {
        "instruction": "Describe how the `update personnel` SQL statement works in Actian 4GL SQL when applied to OpenROAD.",
        "input": "",
        "output": "The `update personnel` SQL statement, as shown in the provided example, updates rows in the personnel table in Actian 4GL SQL within the OpenROAD environment. Specifically, it increases the salary for each employee whose empno (employee number) matches the value specified by :empno. The updated salaries are calculated by multiplying the existing salaries by a factor of 1.1, which corresponds to a standard raise in this example. Once the update is complete, the changes are committed to the database.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->database_procedures",
        "task_description": "Explain the database procedures in Actian 4GL SQL and how they are used in OpenROAD.",
        "document": [
            "# Update Statement\n\nThis statement updates the values of the columns in a database table.\n\nThis statement has the following syntax:\n\n- Non-cursor version:\n  ```\n  [repeated] update tablename [corrname]\n       [from fromclause]\n       set columnname = dbexpression {, columnname =\n                 dbexpression}\n       [where searchcondition];\n  ```\n- Cursor version:\n  ```\n  update tablename set columnname = dbexpression\n       {, columnname = dbexpression} where current of\n            cursor_variable;\n  ```\n\nwhere fromclause has the following alternative syntaxes:\n```\nfrom tablename [corrname]{, tablename [corrname]}\nfrom :fromvariable\n```\n\nThe update statement modifies the values in columns in a database table.\n\nThe tablename identifies the table that you want to update and must match the table name specified in the open statement for the specified cursor.\n\nEach column that you include in the update statement must also have been specified in the for update clause of the open statement that opened the cursor.\n\nThe optional corrname defines a correlation name for the table. Correlation names provide a shorthand way to refer to tables in a query.\n\nThe optional repeated keyword directs the DBMS to encode and save the query execution plan for the statement. This is a performance enhancement if you intend to execute this statement more than once.\n\nNote: Do not use the repeated keyword if you place the entire where clause, searchcondition, in a single variable or if a table name or column name is represented by a dynamic name.\n\n## Parameters--Update Statement\n\nThis statement has the following parameters:\n\n- tablename: Specifies the name of the database table that you want to update. This is a dynamic name.\n- corrname: Specifies the correlation name for the table. This is a dynamic name. This parameter is used only in the non-cursor version.\n- columnname: Specifies the name of a particular column to be updated in the table. This is a dynamic name.\n- dbexpression: Specifies a database expression\n- searchcondition: Specifies a logical database expression of conditions that must be satisfied by all rows selected. You can use simple variables (preceded by colons) in a search condition wherever you can use a literal. Alternatively, you can place the entire search condition in a single varchar variable, and specify the search condition as the name of this variable (proceeded by a colon). This parameter is only used in the non-cursor version.\n- cursor_variable: Specifies the reference variable that points to the CursorObject for which the statement is issued. Used only in the cursor version.\n- fromvariable: Specifies the entire from clause as a single varchar variable, preeded by a colon. This is a dynamic name.\n\n### Set Clause\n\nThe set clause specifies the columns in the table that you want to update.\n\n### Where Clause\n\nIf you do not include a where clause, OpenROAD updates all of the rows in the table. If you include a where clause, OpenROAD updates only the rows in the table that satisfy searchcondition in the where clause.\n\nThe \"where current of\" clause directs OpenROAD to update the row on which the specified cursor is positioned. The cursor_variable must point to a CursorObject that you opened using a for update clause.\n\n## Update Mode\n\nThe update mode of the cursor, specified when you opened the cursor, affects how you can use the update statement. You can open a cursor for deferred or direct update.\n\n### Deferred Mode\n\nWith deferred mode cursors, you can perform only one operation against each row. This operation can be an update or a delete but not both. Similarly, you cannot use the repeated option with a deferred update cursor. Cursors that are opened for direct update do not have these restrictions. However, if the cursor is a direct update cursor and you perform two cursor updates that are not separated by a fetch statement, you can update the same row twice.\n\nAfter a successful update, OpenROAD sets the IIrowcount system variable to one. The cursor remains pointing to the same row (the State attribute of the CursorObject remains CS_CURRENT) and subsequent update or delete statements for the cursor take effect on the same row. If the update is not successful, OpenROAD sets IIrowcount to -1 or 0.\n\nIf the cursor is not pointing to a row, 4GL generates a runtime error message indicating that you must execute a fetch statement. If the row the cursor is pointing to has been deleted from the underlying database table (as the result, for example, of a non-cursor delete), no row is updated.\n\nIt is not necessary to commit after each cursor update. All the changes that you make are committed when you close the cursor. (Do not update the current row of a cursor, commit the change, and then continue in a loop in order to repeat the process. This process fails because the first commit statement closes the cursor.)\n\nYou must issue any update statements for a cursor in the same session in which you opened the cursor.\n\nFor more information about the update statement, see the Programming Guide.\n\n## Examples--Update Statement\n\nUpdate rows in the projects table with values from the current frame:",
            "Update rows in the projects table with values from the current frame:\n\n```\nrepeated update projects\n     set hours = :hours, duedate = :enddate\n     where name = :name;\ncommit;\n```\n\nUpdate the personnel table with a computed value:\n\n```\nupdate personnel\n     set sal = :salary * 1.1\n     where empno = :empno;\ncommit;\n```\n\nUpdate the salaries of all employees in job category, acc, using the value for a standard raise in the table dept:\n\n```\nupdate employee e from dept d\n     set salary = d.std_raise * e.salary\n     where e.jobcat = 'acc' and d.dname = e.dname;\ncommit;\n```\n\nUpdate the vendor address based on the attributes of the addr reference variable:\n\n```\nupdate vendor\n     set city = :addr.city, state = :addr.state\n     where vendorno = :vno;\ncommit;\n```\n\nUpdate the row pointed to by the open cursor, emp_cursor:\n\n```\nupdate emptable\n     set name = :namefield, age = :agefield\n     where current of emp_cursor;\ncommit;\n```"
        ]
    },
    {
        "instruction": "Can you provide an example of how to update multiple rows in Actian 4GL SQL based on a condition?",
        "input": "",
        "output": "To update multiple rows in Actian 4GL SQL based on a condition, we can use the `UPDATE` statement with the `WHERE` clause. Here's an example:\n```sql\nupdate projects set hours = :new_hours where status = 'Completed';\n```\nIn this example, all rows in the 'projects' table where the 'status' is 'Completed' will have their 'hours' column updated to a new value. The new value can be either a literal or an expression.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->database_procedures",
        "task_description": "Explain the database procedures in Actian 4GL SQL and how they are used in OpenROAD.",
        "document": [
            "# Update Statement\n\nThis statement updates the values of the columns in a database table.\n\nThis statement has the following syntax:\n\n- Non-cursor version:\n  ```\n  [repeated] update tablename [corrname]\n       [from fromclause]\n       set columnname = dbexpression {, columnname =\n                 dbexpression}\n       [where searchcondition];\n  ```\n- Cursor version:\n  ```\n  update tablename set columnname = dbexpression\n       {, columnname = dbexpression} where current of\n            cursor_variable;\n  ```\n\nwhere fromclause has the following alternative syntaxes:\n```\nfrom tablename [corrname]{, tablename [corrname]}\nfrom :fromvariable\n```\n\nThe update statement modifies the values in columns in a database table.\n\nThe tablename identifies the table that you want to update and must match the table name specified in the open statement for the specified cursor.\n\nEach column that you include in the update statement must also have been specified in the for update clause of the open statement that opened the cursor.\n\nThe optional corrname defines a correlation name for the table. Correlation names provide a shorthand way to refer to tables in a query.\n\nThe optional repeated keyword directs the DBMS to encode and save the query execution plan for the statement. This is a performance enhancement if you intend to execute this statement more than once.\n\nNote: Do not use the repeated keyword if you place the entire where clause, searchcondition, in a single variable or if a table name or column name is represented by a dynamic name.\n\n## Parameters--Update Statement\n\nThis statement has the following parameters:\n\n- tablename: Specifies the name of the database table that you want to update. This is a dynamic name.\n- corrname: Specifies the correlation name for the table. This is a dynamic name. This parameter is used only in the non-cursor version.\n- columnname: Specifies the name of a particular column to be updated in the table. This is a dynamic name.\n- dbexpression: Specifies a database expression\n- searchcondition: Specifies a logical database expression of conditions that must be satisfied by all rows selected. You can use simple variables (preceded by colons) in a search condition wherever you can use a literal. Alternatively, you can place the entire search condition in a single varchar variable, and specify the search condition as the name of this variable (proceeded by a colon). This parameter is only used in the non-cursor version.\n- cursor_variable: Specifies the reference variable that points to the CursorObject for which the statement is issued. Used only in the cursor version.\n- fromvariable: Specifies the entire from clause as a single varchar variable, preeded by a colon. This is a dynamic name.\n\n### Set Clause\n\nThe set clause specifies the columns in the table that you want to update.\n\n### Where Clause\n\nIf you do not include a where clause, OpenROAD updates all of the rows in the table. If you include a where clause, OpenROAD updates only the rows in the table that satisfy searchcondition in the where clause.\n\nThe \"where current of\" clause directs OpenROAD to update the row on which the specified cursor is positioned. The cursor_variable must point to a CursorObject that you opened using a for update clause.\n\n## Update Mode\n\nThe update mode of the cursor, specified when you opened the cursor, affects how you can use the update statement. You can open a cursor for deferred or direct update.\n\n### Deferred Mode\n\nWith deferred mode cursors, you can perform only one operation against each row. This operation can be an update or a delete but not both. Similarly, you cannot use the repeated option with a deferred update cursor. Cursors that are opened for direct update do not have these restrictions. However, if the cursor is a direct update cursor and you perform two cursor updates that are not separated by a fetch statement, you can update the same row twice.\n\nAfter a successful update, OpenROAD sets the IIrowcount system variable to one. The cursor remains pointing to the same row (the State attribute of the CursorObject remains CS_CURRENT) and subsequent update or delete statements for the cursor take effect on the same row. If the update is not successful, OpenROAD sets IIrowcount to -1 or 0.\n\nIf the cursor is not pointing to a row, 4GL generates a runtime error message indicating that you must execute a fetch statement. If the row the cursor is pointing to has been deleted from the underlying database table (as the result, for example, of a non-cursor delete), no row is updated.\n\nIt is not necessary to commit after each cursor update. All the changes that you make are committed when you close the cursor. (Do not update the current row of a cursor, commit the change, and then continue in a loop in order to repeat the process. This process fails because the first commit statement closes the cursor.)\n\nYou must issue any update statements for a cursor in the same session in which you opened the cursor.\n\nFor more information about the update statement, see the Programming Guide.\n\n## Examples--Update Statement\n\nUpdate rows in the projects table with values from the current frame:",
            "Update rows in the projects table with values from the current frame:\n\n```\nrepeated update projects\n     set hours = :hours, duedate = :enddate\n     where name = :name;\ncommit;\n```\n\nUpdate the personnel table with a computed value:\n\n```\nupdate personnel\n     set sal = :salary * 1.1\n     where empno = :empno;\ncommit;\n```\n\nUpdate the salaries of all employees in job category, acc, using the value for a standard raise in the table dept:\n\n```\nupdate employee e from dept d\n     set salary = d.std_raise * e.salary\n     where e.jobcat = 'acc' and d.dname = e.dname;\ncommit;\n```\n\nUpdate the vendor address based on the attributes of the addr reference variable:\n\n```\nupdate vendor\n     set city = :addr.city, state = :addr.state\n     where vendorno = :vno;\ncommit;\n```\n\nUpdate the row pointed to by the open cursor, emp_cursor:\n\n```\nupdate emptable\n     set name = :namefield, age = :agefield\n     where current of emp_cursor;\ncommit;\n```"
        ]
    },
    {
        "instruction": "Can you explain how to perform a join operation in Actian 4GL SQL and how it is different from SQL?",
        "input": "",
        "output": "In Actian 4GL SQL, the JOIN operation can be performed using the `WITH` statement or the `MERGE` statement. The syntax of both statements is similar to that of SQL, but there are some differences. Here's an example of a join operation using the `WITH` statement:\n```sql\nWITH emp_dept AS (\n    SELECT employee.empno, department.dname\n    FROM employee\n    INNER JOIN department ON employee.dname = department.dname\n)\nSELECT emp_dept.empno, emp_dept.dname, employee.salary\nFROM emp_dept\nJOIN employee ON emp_dept.empno = employee.empno;\n```\nIn this example, we are first creating a derived table `emp_dept` using the `WITH` statement that contains the 'empno' and 'dname' columns from both the 'employee' and 'department' tables. We then perform a join operation on this derived table with the employee table to fetch the 'salary' column as well.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->database_procedures",
        "task_description": "Explain the database procedures in Actian 4GL SQL and how they are used in OpenROAD.",
        "document": [
            "# Update Statement\n\nThis statement updates the values of the columns in a database table.\n\nThis statement has the following syntax:\n\n- Non-cursor version:\n  ```\n  [repeated] update tablename [corrname]\n       [from fromclause]\n       set columnname = dbexpression {, columnname =\n                 dbexpression}\n       [where searchcondition];\n  ```\n- Cursor version:\n  ```\n  update tablename set columnname = dbexpression\n       {, columnname = dbexpression} where current of\n            cursor_variable;\n  ```\n\nwhere fromclause has the following alternative syntaxes:\n```\nfrom tablename [corrname]{, tablename [corrname]}\nfrom :fromvariable\n```\n\nThe update statement modifies the values in columns in a database table.\n\nThe tablename identifies the table that you want to update and must match the table name specified in the open statement for the specified cursor.\n\nEach column that you include in the update statement must also have been specified in the for update clause of the open statement that opened the cursor.\n\nThe optional corrname defines a correlation name for the table. Correlation names provide a shorthand way to refer to tables in a query.\n\nThe optional repeated keyword directs the DBMS to encode and save the query execution plan for the statement. This is a performance enhancement if you intend to execute this statement more than once.\n\nNote: Do not use the repeated keyword if you place the entire where clause, searchcondition, in a single variable or if a table name or column name is represented by a dynamic name.\n\n## Parameters--Update Statement\n\nThis statement has the following parameters:\n\n- tablename: Specifies the name of the database table that you want to update. This is a dynamic name.\n- corrname: Specifies the correlation name for the table. This is a dynamic name. This parameter is used only in the non-cursor version.\n- columnname: Specifies the name of a particular column to be updated in the table. This is a dynamic name.\n- dbexpression: Specifies a database expression\n- searchcondition: Specifies a logical database expression of conditions that must be satisfied by all rows selected. You can use simple variables (preceded by colons) in a search condition wherever you can use a literal. Alternatively, you can place the entire search condition in a single varchar variable, and specify the search condition as the name of this variable (proceeded by a colon). This parameter is only used in the non-cursor version.\n- cursor_variable: Specifies the reference variable that points to the CursorObject for which the statement is issued. Used only in the cursor version.\n- fromvariable: Specifies the entire from clause as a single varchar variable, preeded by a colon. This is a dynamic name.\n\n### Set Clause\n\nThe set clause specifies the columns in the table that you want to update.\n\n### Where Clause\n\nIf you do not include a where clause, OpenROAD updates all of the rows in the table. If you include a where clause, OpenROAD updates only the rows in the table that satisfy searchcondition in the where clause.\n\nThe \"where current of\" clause directs OpenROAD to update the row on which the specified cursor is positioned. The cursor_variable must point to a CursorObject that you opened using a for update clause.\n\n## Update Mode\n\nThe update mode of the cursor, specified when you opened the cursor, affects how you can use the update statement. You can open a cursor for deferred or direct update.\n\n### Deferred Mode\n\nWith deferred mode cursors, you can perform only one operation against each row. This operation can be an update or a delete but not both. Similarly, you cannot use the repeated option with a deferred update cursor. Cursors that are opened for direct update do not have these restrictions. However, if the cursor is a direct update cursor and you perform two cursor updates that are not separated by a fetch statement, you can update the same row twice.\n\nAfter a successful update, OpenROAD sets the IIrowcount system variable to one. The cursor remains pointing to the same row (the State attribute of the CursorObject remains CS_CURRENT) and subsequent update or delete statements for the cursor take effect on the same row. If the update is not successful, OpenROAD sets IIrowcount to -1 or 0.\n\nIf the cursor is not pointing to a row, 4GL generates a runtime error message indicating that you must execute a fetch statement. If the row the cursor is pointing to has been deleted from the underlying database table (as the result, for example, of a non-cursor delete), no row is updated.\n\nIt is not necessary to commit after each cursor update. All the changes that you make are committed when you close the cursor. (Do not update the current row of a cursor, commit the change, and then continue in a loop in order to repeat the process. This process fails because the first commit statement closes the cursor.)\n\nYou must issue any update statements for a cursor in the same session in which you opened the cursor.\n\nFor more information about the update statement, see the Programming Guide.\n\n## Examples--Update Statement\n\nUpdate rows in the projects table with values from the current frame:",
            "Update rows in the projects table with values from the current frame:\n\n```\nrepeated update projects\n     set hours = :hours, duedate = :enddate\n     where name = :name;\ncommit;\n```\n\nUpdate the personnel table with a computed value:\n\n```\nupdate personnel\n     set sal = :salary * 1.1\n     where empno = :empno;\ncommit;\n```\n\nUpdate the salaries of all employees in job category, acc, using the value for a standard raise in the table dept:\n\n```\nupdate employee e from dept d\n     set salary = d.std_raise * e.salary\n     where e.jobcat = 'acc' and d.dname = e.dname;\ncommit;\n```\n\nUpdate the vendor address based on the attributes of the addr reference variable:\n\n```\nupdate vendor\n     set city = :addr.city, state = :addr.state\n     where vendorno = :vno;\ncommit;\n```\n\nUpdate the row pointed to by the open cursor, emp_cursor:\n\n```\nupdate emptable\n     set name = :namefield, age = :agefield\n     where current of emp_cursor;\ncommit;\n```"
        ]
    },
    {
        "instruction": "Explain the syntax of a simple Actian 4GL SQL update statement.",
        "input": "",
        "output": "A simple Actian 4GL SQL update statement consists of three main parts: the table that is being updated, the set clause specifying the column(s) and their new values, and the where clause specifying the condition(s) for selecting which rows to update. The syntax generally looks like this:\n```\nUPDATE table_name\nSET column1 = new_value1, column2 = new_value2, ...\nWHERE condition;\n```\nFor example, if you want to update the hours and duedate columns of the projects table where name is 'Project A':\n```\nupdate projects\n     set hours = 40, duedate = '2023-07-15'\n     where name = 'Project A';\n```",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->database_procedures",
        "task_description": "Explain the database procedures in Actian 4GL SQL and how they are used in OpenROAD.",
        "document": [
            "# Update Statement\n\nThis statement updates the values of the columns in a database table.\n\nThis statement has the following syntax:\n\n- Non-cursor version:\n  ```\n  [repeated] update tablename [corrname]\n       [from fromclause]\n       set columnname = dbexpression {, columnname =\n                 dbexpression}\n       [where searchcondition];\n  ```\n- Cursor version:\n  ```\n  update tablename set columnname = dbexpression\n       {, columnname = dbexpression} where current of\n            cursor_variable;\n  ```\n\nwhere fromclause has the following alternative syntaxes:\n```\nfrom tablename [corrname]{, tablename [corrname]}\nfrom :fromvariable\n```\n\nThe update statement modifies the values in columns in a database table.\n\nThe tablename identifies the table that you want to update and must match the table name specified in the open statement for the specified cursor.\n\nEach column that you include in the update statement must also have been specified in the for update clause of the open statement that opened the cursor.\n\nThe optional corrname defines a correlation name for the table. Correlation names provide a shorthand way to refer to tables in a query.\n\nThe optional repeated keyword directs the DBMS to encode and save the query execution plan for the statement. This is a performance enhancement if you intend to execute this statement more than once.\n\nNote: Do not use the repeated keyword if you place the entire where clause, searchcondition, in a single variable or if a table name or column name is represented by a dynamic name.\n\n## Parameters--Update Statement\n\nThis statement has the following parameters:\n\n- tablename: Specifies the name of the database table that you want to update. This is a dynamic name.\n- corrname: Specifies the correlation name for the table. This is a dynamic name. This parameter is used only in the non-cursor version.\n- columnname: Specifies the name of a particular column to be updated in the table. This is a dynamic name.\n- dbexpression: Specifies a database expression\n- searchcondition: Specifies a logical database expression of conditions that must be satisfied by all rows selected. You can use simple variables (preceded by colons) in a search condition wherever you can use a literal. Alternatively, you can place the entire search condition in a single varchar variable, and specify the search condition as the name of this variable (proceeded by a colon). This parameter is only used in the non-cursor version.\n- cursor_variable: Specifies the reference variable that points to the CursorObject for which the statement is issued. Used only in the cursor version.\n- fromvariable: Specifies the entire from clause as a single varchar variable, preeded by a colon. This is a dynamic name.\n\n### Set Clause\n\nThe set clause specifies the columns in the table that you want to update.\n\n### Where Clause\n\nIf you do not include a where clause, OpenROAD updates all of the rows in the table. If you include a where clause, OpenROAD updates only the rows in the table that satisfy searchcondition in the where clause.\n\nThe \"where current of\" clause directs OpenROAD to update the row on which the specified cursor is positioned. The cursor_variable must point to a CursorObject that you opened using a for update clause.\n\n## Update Mode\n\nThe update mode of the cursor, specified when you opened the cursor, affects how you can use the update statement. You can open a cursor for deferred or direct update.\n\n### Deferred Mode\n\nWith deferred mode cursors, you can perform only one operation against each row. This operation can be an update or a delete but not both. Similarly, you cannot use the repeated option with a deferred update cursor. Cursors that are opened for direct update do not have these restrictions. However, if the cursor is a direct update cursor and you perform two cursor updates that are not separated by a fetch statement, you can update the same row twice.\n\nAfter a successful update, OpenROAD sets the IIrowcount system variable to one. The cursor remains pointing to the same row (the State attribute of the CursorObject remains CS_CURRENT) and subsequent update or delete statements for the cursor take effect on the same row. If the update is not successful, OpenROAD sets IIrowcount to -1 or 0.\n\nIf the cursor is not pointing to a row, 4GL generates a runtime error message indicating that you must execute a fetch statement. If the row the cursor is pointing to has been deleted from the underlying database table (as the result, for example, of a non-cursor delete), no row is updated.\n\nIt is not necessary to commit after each cursor update. All the changes that you make are committed when you close the cursor. (Do not update the current row of a cursor, commit the change, and then continue in a loop in order to repeat the process. This process fails because the first commit statement closes the cursor.)\n\nYou must issue any update statements for a cursor in the same session in which you opened the cursor.\n\nFor more information about the update statement, see the Programming Guide.\n\n## Examples--Update Statement\n\nUpdate rows in the projects table with values from the current frame:",
            "Update rows in the projects table with values from the current frame:\n\n```\nrepeated update projects\n     set hours = :hours, duedate = :enddate\n     where name = :name;\ncommit;\n```\n\nUpdate the personnel table with a computed value:\n\n```\nupdate personnel\n     set sal = :salary * 1.1\n     where empno = :empno;\ncommit;\n```\n\nUpdate the salaries of all employees in job category, acc, using the value for a standard raise in the table dept:\n\n```\nupdate employee e from dept d\n     set salary = d.std_raise * e.salary\n     where e.jobcat = 'acc' and d.dname = e.dname;\ncommit;\n```\n\nUpdate the vendor address based on the attributes of the addr reference variable:\n\n```\nupdate vendor\n     set city = :addr.city, state = :addr.state\n     where vendorno = :vno;\ncommit;\n```\n\nUpdate the row pointed to by the open cursor, emp_cursor:\n\n```\nupdate emptable\n     set name = :namefield, age = :agefield\n     where current of emp_cursor;\ncommit;\n```"
        ]
    },
    {
        "instruction": "Explain how correlation names are used in Actian 4GL SQL update statement?",
        "input": "",
        "output": "Correlation names provide a shorthand way to refer to tables in a query within an Actian 4GL SQL update statement. They can be specified optionally with the 'corrname' parameter. For example, if you have two tables 'employees' and 'projects' and both tables are used in the update statement multiple times, instead of writing the table name every time you can use a correlation name to make your query more readable.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->database_procedures",
        "task_description": "Explain the database procedures in Actian 4GL SQL and how they are used in OpenROAD.",
        "document": [
            "# Update Statement\n\nThis statement updates the values of the columns in a database table.\n\nThis statement has the following syntax:\n\n- Non-cursor version:\n  ```\n  [repeated] update tablename [corrname]\n       [from fromclause]\n       set columnname = dbexpression {, columnname =\n                 dbexpression}\n       [where searchcondition];\n  ```\n- Cursor version:\n  ```\n  update tablename set columnname = dbexpression\n       {, columnname = dbexpression} where current of\n            cursor_variable;\n  ```\n\nwhere fromclause has the following alternative syntaxes:\n```\nfrom tablename [corrname]{, tablename [corrname]}\nfrom :fromvariable\n```\n\nThe update statement modifies the values in columns in a database table.\n\nThe tablename identifies the table that you want to update and must match the table name specified in the open statement for the specified cursor.\n\nEach column that you include in the update statement must also have been specified in the for update clause of the open statement that opened the cursor.\n\nThe optional corrname defines a correlation name for the table. Correlation names provide a shorthand way to refer to tables in a query.\n\nThe optional repeated keyword directs the DBMS to encode and save the query execution plan for the statement. This is a performance enhancement if you intend to execute this statement more than once.\n\nNote: Do not use the repeated keyword if you place the entire where clause, searchcondition, in a single variable or if a table name or column name is represented by a dynamic name.\n\n## Parameters--Update Statement\n\nThis statement has the following parameters:\n\n- tablename: Specifies the name of the database table that you want to update. This is a dynamic name.\n- corrname: Specifies the correlation name for the table. This is a dynamic name. This parameter is used only in the non-cursor version.\n- columnname: Specifies the name of a particular column to be updated in the table. This is a dynamic name.\n- dbexpression: Specifies a database expression\n- searchcondition: Specifies a logical database expression of conditions that must be satisfied by all rows selected. You can use simple variables (preceded by colons) in a search condition wherever you can use a literal. Alternatively, you can place the entire search condition in a single varchar variable, and specify the search condition as the name of this variable (proceeded by a colon). This parameter is only used in the non-cursor version.\n- cursor_variable: Specifies the reference variable that points to the CursorObject for which the statement is issued. Used only in the cursor version.\n- fromvariable: Specifies the entire from clause as a single varchar variable, preeded by a colon. This is a dynamic name.\n\n### Set Clause\n\nThe set clause specifies the columns in the table that you want to update.\n\n### Where Clause\n\nIf you do not include a where clause, OpenROAD updates all of the rows in the table. If you include a where clause, OpenROAD updates only the rows in the table that satisfy searchcondition in the where clause.\n\nThe \"where current of\" clause directs OpenROAD to update the row on which the specified cursor is positioned. The cursor_variable must point to a CursorObject that you opened using a for update clause.\n\n## Update Mode\n\nThe update mode of the cursor, specified when you opened the cursor, affects how you can use the update statement. You can open a cursor for deferred or direct update.\n\n### Deferred Mode\n\nWith deferred mode cursors, you can perform only one operation against each row. This operation can be an update or a delete but not both. Similarly, you cannot use the repeated option with a deferred update cursor. Cursors that are opened for direct update do not have these restrictions. However, if the cursor is a direct update cursor and you perform two cursor updates that are not separated by a fetch statement, you can update the same row twice.\n\nAfter a successful update, OpenROAD sets the IIrowcount system variable to one. The cursor remains pointing to the same row (the State attribute of the CursorObject remains CS_CURRENT) and subsequent update or delete statements for the cursor take effect on the same row. If the update is not successful, OpenROAD sets IIrowcount to -1 or 0.\n\nIf the cursor is not pointing to a row, 4GL generates a runtime error message indicating that you must execute a fetch statement. If the row the cursor is pointing to has been deleted from the underlying database table (as the result, for example, of a non-cursor delete), no row is updated.\n\nIt is not necessary to commit after each cursor update. All the changes that you make are committed when you close the cursor. (Do not update the current row of a cursor, commit the change, and then continue in a loop in order to repeat the process. This process fails because the first commit statement closes the cursor.)\n\nYou must issue any update statements for a cursor in the same session in which you opened the cursor.\n\nFor more information about the update statement, see the Programming Guide.\n\n## Examples--Update Statement\n\nUpdate rows in the projects table with values from the current frame:",
            "Update rows in the projects table with values from the current frame:\n\n```\nrepeated update projects\n     set hours = :hours, duedate = :enddate\n     where name = :name;\ncommit;\n```\n\nUpdate the personnel table with a computed value:\n\n```\nupdate personnel\n     set sal = :salary * 1.1\n     where empno = :empno;\ncommit;\n```\n\nUpdate the salaries of all employees in job category, acc, using the value for a standard raise in the table dept:\n\n```\nupdate employee e from dept d\n     set salary = d.std_raise * e.salary\n     where e.jobcat = 'acc' and d.dname = e.dname;\ncommit;\n```\n\nUpdate the vendor address based on the attributes of the addr reference variable:\n\n```\nupdate vendor\n     set city = :addr.city, state = :addr.state\n     where vendorno = :vno;\ncommit;\n```\n\nUpdate the row pointed to by the open cursor, emp_cursor:\n\n```\nupdate emptable\n     set name = :namefield, age = :agefield\n     where current of emp_cursor;\ncommit;\n```"
        ]
    },
    {
        "instruction": "Explain how to use a subquery in an update statement in Actian 4GL SQL?",
        "input": "",
        "output": "In Actian 4GL SQL, you can use subqueries within the update statement. The basic syntax is as follows:\n```sql\nupdate table_name set column1 = (subquery);\n```\nFor example, consider a scenario where you want to increment the salaries of employees who have higher salary than their managers in the 'department' table. Here's how you can achieve that using a subquery:\n```sql\nupdate employee e set salary = salary + 100\nwhere exists (select * from employee m where m.empno = e.manager and m.salary < e.salary);\n```\nIn this example, the subquery selects all rows from the 'employee' table where empno matches the manager of the current row in the update statement and salary is less than the salary of the employee whose record we are updating.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->database_procedures",
        "task_description": "Explain the database procedures in Actian 4GL SQL and how they are used in OpenROAD.",
        "document": [
            "# Update Statement\n\nThis statement updates the values of the columns in a database table.\n\nThis statement has the following syntax:\n\n- Non-cursor version:\n  ```\n  [repeated] update tablename [corrname]\n       [from fromclause]\n       set columnname = dbexpression {, columnname =\n                 dbexpression}\n       [where searchcondition];\n  ```\n- Cursor version:\n  ```\n  update tablename set columnname = dbexpression\n       {, columnname = dbexpression} where current of\n            cursor_variable;\n  ```\n\nwhere fromclause has the following alternative syntaxes:\n```\nfrom tablename [corrname]{, tablename [corrname]}\nfrom :fromvariable\n```\n\nThe update statement modifies the values in columns in a database table.\n\nThe tablename identifies the table that you want to update and must match the table name specified in the open statement for the specified cursor.\n\nEach column that you include in the update statement must also have been specified in the for update clause of the open statement that opened the cursor.\n\nThe optional corrname defines a correlation name for the table. Correlation names provide a shorthand way to refer to tables in a query.\n\nThe optional repeated keyword directs the DBMS to encode and save the query execution plan for the statement. This is a performance enhancement if you intend to execute this statement more than once.\n\nNote: Do not use the repeated keyword if you place the entire where clause, searchcondition, in a single variable or if a table name or column name is represented by a dynamic name.\n\n## Parameters--Update Statement\n\nThis statement has the following parameters:\n\n- tablename: Specifies the name of the database table that you want to update. This is a dynamic name.\n- corrname: Specifies the correlation name for the table. This is a dynamic name. This parameter is used only in the non-cursor version.\n- columnname: Specifies the name of a particular column to be updated in the table. This is a dynamic name.\n- dbexpression: Specifies a database expression\n- searchcondition: Specifies a logical database expression of conditions that must be satisfied by all rows selected. You can use simple variables (preceded by colons) in a search condition wherever you can use a literal. Alternatively, you can place the entire search condition in a single varchar variable, and specify the search condition as the name of this variable (proceeded by a colon). This parameter is only used in the non-cursor version.\n- cursor_variable: Specifies the reference variable that points to the CursorObject for which the statement is issued. Used only in the cursor version.\n- fromvariable: Specifies the entire from clause as a single varchar variable, preeded by a colon. This is a dynamic name.\n\n### Set Clause\n\nThe set clause specifies the columns in the table that you want to update.\n\n### Where Clause\n\nIf you do not include a where clause, OpenROAD updates all of the rows in the table. If you include a where clause, OpenROAD updates only the rows in the table that satisfy searchcondition in the where clause.\n\nThe \"where current of\" clause directs OpenROAD to update the row on which the specified cursor is positioned. The cursor_variable must point to a CursorObject that you opened using a for update clause.\n\n## Update Mode\n\nThe update mode of the cursor, specified when you opened the cursor, affects how you can use the update statement. You can open a cursor for deferred or direct update.\n\n### Deferred Mode\n\nWith deferred mode cursors, you can perform only one operation against each row. This operation can be an update or a delete but not both. Similarly, you cannot use the repeated option with a deferred update cursor. Cursors that are opened for direct update do not have these restrictions. However, if the cursor is a direct update cursor and you perform two cursor updates that are not separated by a fetch statement, you can update the same row twice.\n\nAfter a successful update, OpenROAD sets the IIrowcount system variable to one. The cursor remains pointing to the same row (the State attribute of the CursorObject remains CS_CURRENT) and subsequent update or delete statements for the cursor take effect on the same row. If the update is not successful, OpenROAD sets IIrowcount to -1 or 0.\n\nIf the cursor is not pointing to a row, 4GL generates a runtime error message indicating that you must execute a fetch statement. If the row the cursor is pointing to has been deleted from the underlying database table (as the result, for example, of a non-cursor delete), no row is updated.\n\nIt is not necessary to commit after each cursor update. All the changes that you make are committed when you close the cursor. (Do not update the current row of a cursor, commit the change, and then continue in a loop in order to repeat the process. This process fails because the first commit statement closes the cursor.)\n\nYou must issue any update statements for a cursor in the same session in which you opened the cursor.\n\nFor more information about the update statement, see the Programming Guide.\n\n## Examples--Update Statement\n\nUpdate rows in the projects table with values from the current frame:",
            "Update rows in the projects table with values from the current frame:\n\n```\nrepeated update projects\n     set hours = :hours, duedate = :enddate\n     where name = :name;\ncommit;\n```\n\nUpdate the personnel table with a computed value:\n\n```\nupdate personnel\n     set sal = :salary * 1.1\n     where empno = :empno;\ncommit;\n```\n\nUpdate the salaries of all employees in job category, acc, using the value for a standard raise in the table dept:\n\n```\nupdate employee e from dept d\n     set salary = d.std_raise * e.salary\n     where e.jobcat = 'acc' and d.dname = e.dname;\ncommit;\n```\n\nUpdate the vendor address based on the attributes of the addr reference variable:\n\n```\nupdate vendor\n     set city = :addr.city, state = :addr.state\n     where vendorno = :vno;\ncommit;\n```\n\nUpdate the row pointed to by the open cursor, emp_cursor:\n\n```\nupdate emptable\n     set name = :namefield, age = :agefield\n     where current of emp_cursor;\ncommit;\n```"
        ]
    },
    {
        "instruction": "How can we perform a multi-table update using Actian 4GL SQL?",
        "input": "",
        "output": "To perform a multi-table update in Actian 4GL SQL, you can use the merge statement. The merge statement combines the features of the insert, update, and delete statements to update one or more tables based on data in another table.\n\nHere's an example of updating multiple tables using the merge statement:\n```sql\nmerge into employee e1, department d1\nusing (select empno, deptno from employees) e2\non (e1.empno = e2.empno and e1.deptno = e2.deptno)\nwhen matched then update set e1.salary = e1.salary + 500\nwhen not matched then insert (empno, deptno, salary) values (e2.empno, e2.deptno, 4000);\n```\nIn this example, we are updating the 'employee' and 'department' tables based on a derived table containing empno and deptno columns. If there is a match in both tables, the salary of the employee is updated by 500. Otherwise, a new row is inserted into both tables with a fixed salary of 4000.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->database_procedures",
        "task_description": "Explain the database procedures in Actian 4GL SQL and how they are used in OpenROAD.",
        "document": [
            "# Update Statement\n\nThis statement updates the values of the columns in a database table.\n\nThis statement has the following syntax:\n\n- Non-cursor version:\n  ```\n  [repeated] update tablename [corrname]\n       [from fromclause]\n       set columnname = dbexpression {, columnname =\n                 dbexpression}\n       [where searchcondition];\n  ```\n- Cursor version:\n  ```\n  update tablename set columnname = dbexpression\n       {, columnname = dbexpression} where current of\n            cursor_variable;\n  ```\n\nwhere fromclause has the following alternative syntaxes:\n```\nfrom tablename [corrname]{, tablename [corrname]}\nfrom :fromvariable\n```\n\nThe update statement modifies the values in columns in a database table.\n\nThe tablename identifies the table that you want to update and must match the table name specified in the open statement for the specified cursor.\n\nEach column that you include in the update statement must also have been specified in the for update clause of the open statement that opened the cursor.\n\nThe optional corrname defines a correlation name for the table. Correlation names provide a shorthand way to refer to tables in a query.\n\nThe optional repeated keyword directs the DBMS to encode and save the query execution plan for the statement. This is a performance enhancement if you intend to execute this statement more than once.\n\nNote: Do not use the repeated keyword if you place the entire where clause, searchcondition, in a single variable or if a table name or column name is represented by a dynamic name.\n\n## Parameters--Update Statement\n\nThis statement has the following parameters:\n\n- tablename: Specifies the name of the database table that you want to update. This is a dynamic name.\n- corrname: Specifies the correlation name for the table. This is a dynamic name. This parameter is used only in the non-cursor version.\n- columnname: Specifies the name of a particular column to be updated in the table. This is a dynamic name.\n- dbexpression: Specifies a database expression\n- searchcondition: Specifies a logical database expression of conditions that must be satisfied by all rows selected. You can use simple variables (preceded by colons) in a search condition wherever you can use a literal. Alternatively, you can place the entire search condition in a single varchar variable, and specify the search condition as the name of this variable (proceeded by a colon). This parameter is only used in the non-cursor version.\n- cursor_variable: Specifies the reference variable that points to the CursorObject for which the statement is issued. Used only in the cursor version.\n- fromvariable: Specifies the entire from clause as a single varchar variable, preeded by a colon. This is a dynamic name.\n\n### Set Clause\n\nThe set clause specifies the columns in the table that you want to update.\n\n### Where Clause\n\nIf you do not include a where clause, OpenROAD updates all of the rows in the table. If you include a where clause, OpenROAD updates only the rows in the table that satisfy searchcondition in the where clause.\n\nThe \"where current of\" clause directs OpenROAD to update the row on which the specified cursor is positioned. The cursor_variable must point to a CursorObject that you opened using a for update clause.\n\n## Update Mode\n\nThe update mode of the cursor, specified when you opened the cursor, affects how you can use the update statement. You can open a cursor for deferred or direct update.\n\n### Deferred Mode\n\nWith deferred mode cursors, you can perform only one operation against each row. This operation can be an update or a delete but not both. Similarly, you cannot use the repeated option with a deferred update cursor. Cursors that are opened for direct update do not have these restrictions. However, if the cursor is a direct update cursor and you perform two cursor updates that are not separated by a fetch statement, you can update the same row twice.\n\nAfter a successful update, OpenROAD sets the IIrowcount system variable to one. The cursor remains pointing to the same row (the State attribute of the CursorObject remains CS_CURRENT) and subsequent update or delete statements for the cursor take effect on the same row. If the update is not successful, OpenROAD sets IIrowcount to -1 or 0.\n\nIf the cursor is not pointing to a row, 4GL generates a runtime error message indicating that you must execute a fetch statement. If the row the cursor is pointing to has been deleted from the underlying database table (as the result, for example, of a non-cursor delete), no row is updated.\n\nIt is not necessary to commit after each cursor update. All the changes that you make are committed when you close the cursor. (Do not update the current row of a cursor, commit the change, and then continue in a loop in order to repeat the process. This process fails because the first commit statement closes the cursor.)\n\nYou must issue any update statements for a cursor in the same session in which you opened the cursor.\n\nFor more information about the update statement, see the Programming Guide.\n\n## Examples--Update Statement\n\nUpdate rows in the projects table with values from the current frame:",
            "Update rows in the projects table with values from the current frame:\n\n```\nrepeated update projects\n     set hours = :hours, duedate = :enddate\n     where name = :name;\ncommit;\n```\n\nUpdate the personnel table with a computed value:\n\n```\nupdate personnel\n     set sal = :salary * 1.1\n     where empno = :empno;\ncommit;\n```\n\nUpdate the salaries of all employees in job category, acc, using the value for a standard raise in the table dept:\n\n```\nupdate employee e from dept d\n     set salary = d.std_raise * e.salary\n     where e.jobcat = 'acc' and d.dname = e.dname;\ncommit;\n```\n\nUpdate the vendor address based on the attributes of the addr reference variable:\n\n```\nupdate vendor\n     set city = :addr.city, state = :addr.state\n     where vendorno = :vno;\ncommit;\n```\n\nUpdate the row pointed to by the open cursor, emp_cursor:\n\n```\nupdate emptable\n     set name = :namefield, age = :agefield\n     where current of emp_cursor;\ncommit;\n```"
        ]
    },
    {
        "instruction": "How do you use the update statement with the join operation in Actian 4GL SQL for OpenROAD?",
        "input": "",
        "output": "In order to perform an update operation using the join operation in Actian 4GL SQL, follow these steps:\n\n1. Create a derived table from the join operation:\n```sql\ncreate derived table derived_table as\nselect a.column1, b.column2 from table1 a join table2 b on a.common_column = b.common_column;\n```\n\n2. Use the derived table for updating the target table:\n```sql\nupdate table3 t set column3 = (select column1 + column2 from derived_table d where t.id = d.id)\nwhere id in (select id from derived_table);\ncommit;\n```\n\n** Note: Replace `column1`, `column2`, `common_column`, `table1`, `table2`, `table3`, and the column names with appropriate table and column names based on your use case.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->database_procedures",
        "task_description": "Explain the database procedures in Actian 4GL SQL and how they are used in OpenROAD.",
        "document": [
            "# Update Statement\n\nThis statement updates the values of the columns in a database table.\n\nThis statement has the following syntax:\n\n- Non-cursor version:\n  ```\n  [repeated] update tablename [corrname]\n       [from fromclause]\n       set columnname = dbexpression {, columnname =\n                 dbexpression}\n       [where searchcondition];\n  ```\n- Cursor version:\n  ```\n  update tablename set columnname = dbexpression\n       {, columnname = dbexpression} where current of\n            cursor_variable;\n  ```\n\nwhere fromclause has the following alternative syntaxes:\n```\nfrom tablename [corrname]{, tablename [corrname]}\nfrom :fromvariable\n```\n\nThe update statement modifies the values in columns in a database table.\n\nThe tablename identifies the table that you want to update and must match the table name specified in the open statement for the specified cursor.\n\nEach column that you include in the update statement must also have been specified in the for update clause of the open statement that opened the cursor.\n\nThe optional corrname defines a correlation name for the table. Correlation names provide a shorthand way to refer to tables in a query.\n\nThe optional repeated keyword directs the DBMS to encode and save the query execution plan for the statement. This is a performance enhancement if you intend to execute this statement more than once.\n\nNote: Do not use the repeated keyword if you place the entire where clause, searchcondition, in a single variable or if a table name or column name is represented by a dynamic name.\n\n## Parameters--Update Statement\n\nThis statement has the following parameters:\n\n- tablename: Specifies the name of the database table that you want to update. This is a dynamic name.\n- corrname: Specifies the correlation name for the table. This is a dynamic name. This parameter is used only in the non-cursor version.\n- columnname: Specifies the name of a particular column to be updated in the table. This is a dynamic name.\n- dbexpression: Specifies a database expression\n- searchcondition: Specifies a logical database expression of conditions that must be satisfied by all rows selected. You can use simple variables (preceded by colons) in a search condition wherever you can use a literal. Alternatively, you can place the entire search condition in a single varchar variable, and specify the search condition as the name of this variable (proceeded by a colon). This parameter is only used in the non-cursor version.\n- cursor_variable: Specifies the reference variable that points to the CursorObject for which the statement is issued. Used only in the cursor version.\n- fromvariable: Specifies the entire from clause as a single varchar variable, preeded by a colon. This is a dynamic name.\n\n### Set Clause\n\nThe set clause specifies the columns in the table that you want to update.\n\n### Where Clause\n\nIf you do not include a where clause, OpenROAD updates all of the rows in the table. If you include a where clause, OpenROAD updates only the rows in the table that satisfy searchcondition in the where clause.\n\nThe \"where current of\" clause directs OpenROAD to update the row on which the specified cursor is positioned. The cursor_variable must point to a CursorObject that you opened using a for update clause.\n\n## Update Mode\n\nThe update mode of the cursor, specified when you opened the cursor, affects how you can use the update statement. You can open a cursor for deferred or direct update.\n\n### Deferred Mode\n\nWith deferred mode cursors, you can perform only one operation against each row. This operation can be an update or a delete but not both. Similarly, you cannot use the repeated option with a deferred update cursor. Cursors that are opened for direct update do not have these restrictions. However, if the cursor is a direct update cursor and you perform two cursor updates that are not separated by a fetch statement, you can update the same row twice.\n\nAfter a successful update, OpenROAD sets the IIrowcount system variable to one. The cursor remains pointing to the same row (the State attribute of the CursorObject remains CS_CURRENT) and subsequent update or delete statements for the cursor take effect on the same row. If the update is not successful, OpenROAD sets IIrowcount to -1 or 0.\n\nIf the cursor is not pointing to a row, 4GL generates a runtime error message indicating that you must execute a fetch statement. If the row the cursor is pointing to has been deleted from the underlying database table (as the result, for example, of a non-cursor delete), no row is updated.\n\nIt is not necessary to commit after each cursor update. All the changes that you make are committed when you close the cursor. (Do not update the current row of a cursor, commit the change, and then continue in a loop in order to repeat the process. This process fails because the first commit statement closes the cursor.)\n\nYou must issue any update statements for a cursor in the same session in which you opened the cursor.\n\nFor more information about the update statement, see the Programming Guide.\n\n## Examples--Update Statement\n\nUpdate rows in the projects table with values from the current frame:",
            "Update rows in the projects table with values from the current frame:\n\n```\nrepeated update projects\n     set hours = :hours, duedate = :enddate\n     where name = :name;\ncommit;\n```\n\nUpdate the personnel table with a computed value:\n\n```\nupdate personnel\n     set sal = :salary * 1.1\n     where empno = :empno;\ncommit;\n```\n\nUpdate the salaries of all employees in job category, acc, using the value for a standard raise in the table dept:\n\n```\nupdate employee e from dept d\n     set salary = d.std_raise * e.salary\n     where e.jobcat = 'acc' and d.dname = e.dname;\ncommit;\n```\n\nUpdate the vendor address based on the attributes of the addr reference variable:\n\n```\nupdate vendor\n     set city = :addr.city, state = :addr.state\n     where vendorno = :vno;\ncommit;\n```\n\nUpdate the row pointed to by the open cursor, emp_cursor:\n\n```\nupdate emptable\n     set name = :namefield, age = :agefield\n     where current of emp_cursor;\ncommit;\n```"
        ]
    },
    {
        "instruction": "Describe a real-world scenario where you might use a cursor version of the update statement in Actian 4GL SQL for OpenROAD.",
        "input": "",
        "output": "Consider a scenario where you have a table `employee_salary` with columns `emp_id`, `salary`, and `bonus`. The employee salary values are entered by different managers, so there might be inconsistencies in the formatting of bonuses (some might use commas while others might not). To rectify this issue, you can write a cursor version of the update statement to parse the bonus value, replace any comma with a decimal point and then update the table:\n```sql\ndeclare emp_cursor cursor for\n    select emp_id from employee_salary;\n\nopen emp_cursor;\nfetch next from emp_cursor into :emp_id;\nwhile not done do\n    update employee_salary set bonus = replace(replace(:bonus, '.', ','), ',', '.') where emp_id = :emp_id;\n    fetch next from emp_cursor into :emp_id;\nend while;\nclose emp_cursor;\ncommit;\n```",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->database_procedures",
        "task_description": "Explain the database procedures in Actian 4GL SQL and how they are used in OpenROAD.",
        "document": [
            "# Update Statement\n\nThis statement updates the values of the columns in a database table.\n\nThis statement has the following syntax:\n\n- Non-cursor version:\n  ```\n  [repeated] update tablename [corrname]\n       [from fromclause]\n       set columnname = dbexpression {, columnname =\n                 dbexpression}\n       [where searchcondition];\n  ```\n- Cursor version:\n  ```\n  update tablename set columnname = dbexpression\n       {, columnname = dbexpression} where current of\n            cursor_variable;\n  ```\n\nwhere fromclause has the following alternative syntaxes:\n```\nfrom tablename [corrname]{, tablename [corrname]}\nfrom :fromvariable\n```\n\nThe update statement modifies the values in columns in a database table.\n\nThe tablename identifies the table that you want to update and must match the table name specified in the open statement for the specified cursor.\n\nEach column that you include in the update statement must also have been specified in the for update clause of the open statement that opened the cursor.\n\nThe optional corrname defines a correlation name for the table. Correlation names provide a shorthand way to refer to tables in a query.\n\nThe optional repeated keyword directs the DBMS to encode and save the query execution plan for the statement. This is a performance enhancement if you intend to execute this statement more than once.\n\nNote: Do not use the repeated keyword if you place the entire where clause, searchcondition, in a single variable or if a table name or column name is represented by a dynamic name.\n\n## Parameters--Update Statement\n\nThis statement has the following parameters:\n\n- tablename: Specifies the name of the database table that you want to update. This is a dynamic name.\n- corrname: Specifies the correlation name for the table. This is a dynamic name. This parameter is used only in the non-cursor version.\n- columnname: Specifies the name of a particular column to be updated in the table. This is a dynamic name.\n- dbexpression: Specifies a database expression\n- searchcondition: Specifies a logical database expression of conditions that must be satisfied by all rows selected. You can use simple variables (preceded by colons) in a search condition wherever you can use a literal. Alternatively, you can place the entire search condition in a single varchar variable, and specify the search condition as the name of this variable (proceeded by a colon). This parameter is only used in the non-cursor version.\n- cursor_variable: Specifies the reference variable that points to the CursorObject for which the statement is issued. Used only in the cursor version.\n- fromvariable: Specifies the entire from clause as a single varchar variable, preeded by a colon. This is a dynamic name.\n\n### Set Clause\n\nThe set clause specifies the columns in the table that you want to update.\n\n### Where Clause\n\nIf you do not include a where clause, OpenROAD updates all of the rows in the table. If you include a where clause, OpenROAD updates only the rows in the table that satisfy searchcondition in the where clause.\n\nThe \"where current of\" clause directs OpenROAD to update the row on which the specified cursor is positioned. The cursor_variable must point to a CursorObject that you opened using a for update clause.\n\n## Update Mode\n\nThe update mode of the cursor, specified when you opened the cursor, affects how you can use the update statement. You can open a cursor for deferred or direct update.\n\n### Deferred Mode\n\nWith deferred mode cursors, you can perform only one operation against each row. This operation can be an update or a delete but not both. Similarly, you cannot use the repeated option with a deferred update cursor. Cursors that are opened for direct update do not have these restrictions. However, if the cursor is a direct update cursor and you perform two cursor updates that are not separated by a fetch statement, you can update the same row twice.\n\nAfter a successful update, OpenROAD sets the IIrowcount system variable to one. The cursor remains pointing to the same row (the State attribute of the CursorObject remains CS_CURRENT) and subsequent update or delete statements for the cursor take effect on the same row. If the update is not successful, OpenROAD sets IIrowcount to -1 or 0.\n\nIf the cursor is not pointing to a row, 4GL generates a runtime error message indicating that you must execute a fetch statement. If the row the cursor is pointing to has been deleted from the underlying database table (as the result, for example, of a non-cursor delete), no row is updated.\n\nIt is not necessary to commit after each cursor update. All the changes that you make are committed when you close the cursor. (Do not update the current row of a cursor, commit the change, and then continue in a loop in order to repeat the process. This process fails because the first commit statement closes the cursor.)\n\nYou must issue any update statements for a cursor in the same session in which you opened the cursor.\n\nFor more information about the update statement, see the Programming Guide.\n\n## Examples--Update Statement\n\nUpdate rows in the projects table with values from the current frame:",
            "Update rows in the projects table with values from the current frame:\n\n```\nrepeated update projects\n     set hours = :hours, duedate = :enddate\n     where name = :name;\ncommit;\n```\n\nUpdate the personnel table with a computed value:\n\n```\nupdate personnel\n     set sal = :salary * 1.1\n     where empno = :empno;\ncommit;\n```\n\nUpdate the salaries of all employees in job category, acc, using the value for a standard raise in the table dept:\n\n```\nupdate employee e from dept d\n     set salary = d.std_raise * e.salary\n     where e.jobcat = 'acc' and d.dname = e.dname;\ncommit;\n```\n\nUpdate the vendor address based on the attributes of the addr reference variable:\n\n```\nupdate vendor\n     set city = :addr.city, state = :addr.state\n     where vendorno = :vno;\ncommit;\n```\n\nUpdate the row pointed to by the open cursor, emp_cursor:\n\n```\nupdate emptable\n     set name = :namefield, age = :agefield\n     where current of emp_cursor;\ncommit;\n```"
        ]
    },
    {
        "instruction": "Describe how to update a table's rows based on conditions from another table using Actian 4GL SQL JOIN syntax.",
        "input": "",
        "output": "To update a table with values from another table based on specific conditions, you can utilize the UPDATE and JOIN syntax in Actian 4GL SQL. The following is an example of updating the employee table using the dept table to apply a standard raise for employees in job category acc:\n\n```\nupdate employee e\n     set salary = d.std_raise * e.salary\n     from dept d\n     where e.jobcat = 'acc' and d.dname = e.dname;\ncommit;\n```\nIn this example, the JOIN clause combines rows from both tables based on their matching conditions (job category and department name), making it possible to perform the desired update efficiently.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->database_procedures",
        "task_description": "Explain the database procedures in Actian 4GL SQL and how they are used in OpenROAD.",
        "document": [
            "# Update Statement\n\nThis statement updates the values of the columns in a database table.\n\nThis statement has the following syntax:\n\n- Non-cursor version:\n  ```\n  [repeated] update tablename [corrname]\n       [from fromclause]\n       set columnname = dbexpression {, columnname =\n                 dbexpression}\n       [where searchcondition];\n  ```\n- Cursor version:\n  ```\n  update tablename set columnname = dbexpression\n       {, columnname = dbexpression} where current of\n            cursor_variable;\n  ```\n\nwhere fromclause has the following alternative syntaxes:\n```\nfrom tablename [corrname]{, tablename [corrname]}\nfrom :fromvariable\n```\n\nThe update statement modifies the values in columns in a database table.\n\nThe tablename identifies the table that you want to update and must match the table name specified in the open statement for the specified cursor.\n\nEach column that you include in the update statement must also have been specified in the for update clause of the open statement that opened the cursor.\n\nThe optional corrname defines a correlation name for the table. Correlation names provide a shorthand way to refer to tables in a query.\n\nThe optional repeated keyword directs the DBMS to encode and save the query execution plan for the statement. This is a performance enhancement if you intend to execute this statement more than once.\n\nNote: Do not use the repeated keyword if you place the entire where clause, searchcondition, in a single variable or if a table name or column name is represented by a dynamic name.\n\n## Parameters--Update Statement\n\nThis statement has the following parameters:\n\n- tablename: Specifies the name of the database table that you want to update. This is a dynamic name.\n- corrname: Specifies the correlation name for the table. This is a dynamic name. This parameter is used only in the non-cursor version.\n- columnname: Specifies the name of a particular column to be updated in the table. This is a dynamic name.\n- dbexpression: Specifies a database expression\n- searchcondition: Specifies a logical database expression of conditions that must be satisfied by all rows selected. You can use simple variables (preceded by colons) in a search condition wherever you can use a literal. Alternatively, you can place the entire search condition in a single varchar variable, and specify the search condition as the name of this variable (proceeded by a colon). This parameter is only used in the non-cursor version.\n- cursor_variable: Specifies the reference variable that points to the CursorObject for which the statement is issued. Used only in the cursor version.\n- fromvariable: Specifies the entire from clause as a single varchar variable, preeded by a colon. This is a dynamic name.\n\n### Set Clause\n\nThe set clause specifies the columns in the table that you want to update.\n\n### Where Clause\n\nIf you do not include a where clause, OpenROAD updates all of the rows in the table. If you include a where clause, OpenROAD updates only the rows in the table that satisfy searchcondition in the where clause.\n\nThe \"where current of\" clause directs OpenROAD to update the row on which the specified cursor is positioned. The cursor_variable must point to a CursorObject that you opened using a for update clause.\n\n## Update Mode\n\nThe update mode of the cursor, specified when you opened the cursor, affects how you can use the update statement. You can open a cursor for deferred or direct update.\n\n### Deferred Mode\n\nWith deferred mode cursors, you can perform only one operation against each row. This operation can be an update or a delete but not both. Similarly, you cannot use the repeated option with a deferred update cursor. Cursors that are opened for direct update do not have these restrictions. However, if the cursor is a direct update cursor and you perform two cursor updates that are not separated by a fetch statement, you can update the same row twice.\n\nAfter a successful update, OpenROAD sets the IIrowcount system variable to one. The cursor remains pointing to the same row (the State attribute of the CursorObject remains CS_CURRENT) and subsequent update or delete statements for the cursor take effect on the same row. If the update is not successful, OpenROAD sets IIrowcount to -1 or 0.\n\nIf the cursor is not pointing to a row, 4GL generates a runtime error message indicating that you must execute a fetch statement. If the row the cursor is pointing to has been deleted from the underlying database table (as the result, for example, of a non-cursor delete), no row is updated.\n\nIt is not necessary to commit after each cursor update. All the changes that you make are committed when you close the cursor. (Do not update the current row of a cursor, commit the change, and then continue in a loop in order to repeat the process. This process fails because the first commit statement closes the cursor.)\n\nYou must issue any update statements for a cursor in the same session in which you opened the cursor.\n\nFor more information about the update statement, see the Programming Guide.\n\n## Examples--Update Statement\n\nUpdate rows in the projects table with values from the current frame:",
            "Update rows in the projects table with values from the current frame:\n\n```\nrepeated update projects\n     set hours = :hours, duedate = :enddate\n     where name = :name;\ncommit;\n```\n\nUpdate the personnel table with a computed value:\n\n```\nupdate personnel\n     set sal = :salary * 1.1\n     where empno = :empno;\ncommit;\n```\n\nUpdate the salaries of all employees in job category, acc, using the value for a standard raise in the table dept:\n\n```\nupdate employee e from dept d\n     set salary = d.std_raise * e.salary\n     where e.jobcat = 'acc' and d.dname = e.dname;\ncommit;\n```\n\nUpdate the vendor address based on the attributes of the addr reference variable:\n\n```\nupdate vendor\n     set city = :addr.city, state = :addr.state\n     where vendorno = :vno;\ncommit;\n```\n\nUpdate the row pointed to by the open cursor, emp_cursor:\n\n```\nupdate emptable\n     set name = :namefield, age = :agefield\n     where current of emp_cursor;\ncommit;\n```"
        ]
    },
    {
        "instruction": "What is the purpose of the set clause in an Actian 4GL SQL update statement?",
        "input": "",
        "output": "The set clause specifies the columns in the table that you want to update in an Actian 4GL SQL update statement. For example, if you have a table with columns 'name', 'age', and 'address' and you want to update the values for 'age' only, you would use the following syntax:\n```\nupdate employees set age = new_age where condition;\n```",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->database_procedures",
        "task_description": "Explain the database procedures in Actian 4GL SQL and how they are used in OpenROAD.",
        "document": [
            "# Update Statement\n\nThis statement updates the values of the columns in a database table.\n\nThis statement has the following syntax:\n\n- Non-cursor version:\n  ```\n  [repeated] update tablename [corrname]\n       [from fromclause]\n       set columnname = dbexpression {, columnname =\n                 dbexpression}\n       [where searchcondition];\n  ```\n- Cursor version:\n  ```\n  update tablename set columnname = dbexpression\n       {, columnname = dbexpression} where current of\n            cursor_variable;\n  ```\n\nwhere fromclause has the following alternative syntaxes:\n```\nfrom tablename [corrname]{, tablename [corrname]}\nfrom :fromvariable\n```\n\nThe update statement modifies the values in columns in a database table.\n\nThe tablename identifies the table that you want to update and must match the table name specified in the open statement for the specified cursor.\n\nEach column that you include in the update statement must also have been specified in the for update clause of the open statement that opened the cursor.\n\nThe optional corrname defines a correlation name for the table. Correlation names provide a shorthand way to refer to tables in a query.\n\nThe optional repeated keyword directs the DBMS to encode and save the query execution plan for the statement. This is a performance enhancement if you intend to execute this statement more than once.\n\nNote: Do not use the repeated keyword if you place the entire where clause, searchcondition, in a single variable or if a table name or column name is represented by a dynamic name.\n\n## Parameters--Update Statement\n\nThis statement has the following parameters:\n\n- tablename: Specifies the name of the database table that you want to update. This is a dynamic name.\n- corrname: Specifies the correlation name for the table. This is a dynamic name. This parameter is used only in the non-cursor version.\n- columnname: Specifies the name of a particular column to be updated in the table. This is a dynamic name.\n- dbexpression: Specifies a database expression\n- searchcondition: Specifies a logical database expression of conditions that must be satisfied by all rows selected. You can use simple variables (preceded by colons) in a search condition wherever you can use a literal. Alternatively, you can place the entire search condition in a single varchar variable, and specify the search condition as the name of this variable (proceeded by a colon). This parameter is only used in the non-cursor version.\n- cursor_variable: Specifies the reference variable that points to the CursorObject for which the statement is issued. Used only in the cursor version.\n- fromvariable: Specifies the entire from clause as a single varchar variable, preeded by a colon. This is a dynamic name.\n\n### Set Clause\n\nThe set clause specifies the columns in the table that you want to update.\n\n### Where Clause\n\nIf you do not include a where clause, OpenROAD updates all of the rows in the table. If you include a where clause, OpenROAD updates only the rows in the table that satisfy searchcondition in the where clause.\n\nThe \"where current of\" clause directs OpenROAD to update the row on which the specified cursor is positioned. The cursor_variable must point to a CursorObject that you opened using a for update clause.\n\n## Update Mode\n\nThe update mode of the cursor, specified when you opened the cursor, affects how you can use the update statement. You can open a cursor for deferred or direct update.\n\n### Deferred Mode\n\nWith deferred mode cursors, you can perform only one operation against each row. This operation can be an update or a delete but not both. Similarly, you cannot use the repeated option with a deferred update cursor. Cursors that are opened for direct update do not have these restrictions. However, if the cursor is a direct update cursor and you perform two cursor updates that are not separated by a fetch statement, you can update the same row twice.\n\nAfter a successful update, OpenROAD sets the IIrowcount system variable to one. The cursor remains pointing to the same row (the State attribute of the CursorObject remains CS_CURRENT) and subsequent update or delete statements for the cursor take effect on the same row. If the update is not successful, OpenROAD sets IIrowcount to -1 or 0.\n\nIf the cursor is not pointing to a row, 4GL generates a runtime error message indicating that you must execute a fetch statement. If the row the cursor is pointing to has been deleted from the underlying database table (as the result, for example, of a non-cursor delete), no row is updated.\n\nIt is not necessary to commit after each cursor update. All the changes that you make are committed when you close the cursor. (Do not update the current row of a cursor, commit the change, and then continue in a loop in order to repeat the process. This process fails because the first commit statement closes the cursor.)\n\nYou must issue any update statements for a cursor in the same session in which you opened the cursor.\n\nFor more information about the update statement, see the Programming Guide.\n\n## Examples--Update Statement\n\nUpdate rows in the projects table with values from the current frame:",
            "Update rows in the projects table with values from the current frame:\n\n```\nrepeated update projects\n     set hours = :hours, duedate = :enddate\n     where name = :name;\ncommit;\n```\n\nUpdate the personnel table with a computed value:\n\n```\nupdate personnel\n     set sal = :salary * 1.1\n     where empno = :empno;\ncommit;\n```\n\nUpdate the salaries of all employees in job category, acc, using the value for a standard raise in the table dept:\n\n```\nupdate employee e from dept d\n     set salary = d.std_raise * e.salary\n     where e.jobcat = 'acc' and d.dname = e.dname;\ncommit;\n```\n\nUpdate the vendor address based on the attributes of the addr reference variable:\n\n```\nupdate vendor\n     set city = :addr.city, state = :addr.state\n     where vendorno = :vno;\ncommit;\n```\n\nUpdate the row pointed to by the open cursor, emp_cursor:\n\n```\nupdate emptable\n     set name = :namefield, age = :agefield\n     where current of emp_cursor;\ncommit;\n```"
        ]
    },
    {
        "instruction": "Explain how to update multiple rows in a table using the Actian 4GL SQL UPDATE statement.",
        "input": "",
        "output": "To update multiple rows in a table using the Actian 4GL SQL UPDATE statement, you can omit the where clause or use a generic condition that applies to all rows you want to update. For example:\n```\nupdate employees set salary = salary * 1.10;\n```\nThis statement will increase the salary of all employees by 10%. If you want to update multiple rows based on specific conditions, you can use a WHERE clause.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->database_procedures",
        "task_description": "Explain the database procedures in Actian 4GL SQL and how they are used in OpenROAD.",
        "document": [
            "# Update Statement\n\nThis statement updates the values of the columns in a database table.\n\nThis statement has the following syntax:\n\n- Non-cursor version:\n  ```\n  [repeated] update tablename [corrname]\n       [from fromclause]\n       set columnname = dbexpression {, columnname =\n                 dbexpression}\n       [where searchcondition];\n  ```\n- Cursor version:\n  ```\n  update tablename set columnname = dbexpression\n       {, columnname = dbexpression} where current of\n            cursor_variable;\n  ```\n\nwhere fromclause has the following alternative syntaxes:\n```\nfrom tablename [corrname]{, tablename [corrname]}\nfrom :fromvariable\n```\n\nThe update statement modifies the values in columns in a database table.\n\nThe tablename identifies the table that you want to update and must match the table name specified in the open statement for the specified cursor.\n\nEach column that you include in the update statement must also have been specified in the for update clause of the open statement that opened the cursor.\n\nThe optional corrname defines a correlation name for the table. Correlation names provide a shorthand way to refer to tables in a query.\n\nThe optional repeated keyword directs the DBMS to encode and save the query execution plan for the statement. This is a performance enhancement if you intend to execute this statement more than once.\n\nNote: Do not use the repeated keyword if you place the entire where clause, searchcondition, in a single variable or if a table name or column name is represented by a dynamic name.\n\n## Parameters--Update Statement\n\nThis statement has the following parameters:\n\n- tablename: Specifies the name of the database table that you want to update. This is a dynamic name.\n- corrname: Specifies the correlation name for the table. This is a dynamic name. This parameter is used only in the non-cursor version.\n- columnname: Specifies the name of a particular column to be updated in the table. This is a dynamic name.\n- dbexpression: Specifies a database expression\n- searchcondition: Specifies a logical database expression of conditions that must be satisfied by all rows selected. You can use simple variables (preceded by colons) in a search condition wherever you can use a literal. Alternatively, you can place the entire search condition in a single varchar variable, and specify the search condition as the name of this variable (proceeded by a colon). This parameter is only used in the non-cursor version.\n- cursor_variable: Specifies the reference variable that points to the CursorObject for which the statement is issued. Used only in the cursor version.\n- fromvariable: Specifies the entire from clause as a single varchar variable, preeded by a colon. This is a dynamic name.\n\n### Set Clause\n\nThe set clause specifies the columns in the table that you want to update.\n\n### Where Clause\n\nIf you do not include a where clause, OpenROAD updates all of the rows in the table. If you include a where clause, OpenROAD updates only the rows in the table that satisfy searchcondition in the where clause.\n\nThe \"where current of\" clause directs OpenROAD to update the row on which the specified cursor is positioned. The cursor_variable must point to a CursorObject that you opened using a for update clause.\n\n## Update Mode\n\nThe update mode of the cursor, specified when you opened the cursor, affects how you can use the update statement. You can open a cursor for deferred or direct update.\n\n### Deferred Mode\n\nWith deferred mode cursors, you can perform only one operation against each row. This operation can be an update or a delete but not both. Similarly, you cannot use the repeated option with a deferred update cursor. Cursors that are opened for direct update do not have these restrictions. However, if the cursor is a direct update cursor and you perform two cursor updates that are not separated by a fetch statement, you can update the same row twice.\n\nAfter a successful update, OpenROAD sets the IIrowcount system variable to one. The cursor remains pointing to the same row (the State attribute of the CursorObject remains CS_CURRENT) and subsequent update or delete statements for the cursor take effect on the same row. If the update is not successful, OpenROAD sets IIrowcount to -1 or 0.\n\nIf the cursor is not pointing to a row, 4GL generates a runtime error message indicating that you must execute a fetch statement. If the row the cursor is pointing to has been deleted from the underlying database table (as the result, for example, of a non-cursor delete), no row is updated.\n\nIt is not necessary to commit after each cursor update. All the changes that you make are committed when you close the cursor. (Do not update the current row of a cursor, commit the change, and then continue in a loop in order to repeat the process. This process fails because the first commit statement closes the cursor.)\n\nYou must issue any update statements for a cursor in the same session in which you opened the cursor.\n\nFor more information about the update statement, see the Programming Guide.\n\n## Examples--Update Statement\n\nUpdate rows in the projects table with values from the current frame:",
            "Update rows in the projects table with values from the current frame:\n\n```\nrepeated update projects\n     set hours = :hours, duedate = :enddate\n     where name = :name;\ncommit;\n```\n\nUpdate the personnel table with a computed value:\n\n```\nupdate personnel\n     set sal = :salary * 1.1\n     where empno = :empno;\ncommit;\n```\n\nUpdate the salaries of all employees in job category, acc, using the value for a standard raise in the table dept:\n\n```\nupdate employee e from dept d\n     set salary = d.std_raise * e.salary\n     where e.jobcat = 'acc' and d.dname = e.dname;\ncommit;\n```\n\nUpdate the vendor address based on the attributes of the addr reference variable:\n\n```\nupdate vendor\n     set city = :addr.city, state = :addr.state\n     where vendorno = :vno;\ncommit;\n```\n\nUpdate the row pointed to by the open cursor, emp_cursor:\n\n```\nupdate emptable\n     set name = :namefield, age = :agefield\n     where current of emp_cursor;\ncommit;\n```"
        ]
    },
    {
        "instruction": "Describe the purpose and syntax of the Actian 4GL SQL `update` statement and provide an example that demonstrates its use in updating multiple rows.",
        "input": "",
        "output": "The Actian 4GL SQL `update` statement is used to modify one or more columns in a table by setting new values. The syntax of the update statement is as follows:\n```sql\nUPDATE table_name SET column1 = value1, column2 = value2, ... WHERE condition;\n```\nHere is an example of updating multiple rows in the `employee` table where the department ID is equal to 30:\n```sql\nUPDATE employee SET salary = salary * 1.1 WHERE deptid = 30;\n```\nIn this example, we are increasing all the salaries of employees who work in a department with an ID of 30 by 10%.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->database_procedures",
        "task_description": "Explain the database procedures in Actian 4GL SQL and how they are used in OpenROAD.",
        "document": [
            "# Update Statement\n\nThis statement updates the values of the columns in a database table.\n\nThis statement has the following syntax:\n\n- Non-cursor version:\n  ```\n  [repeated] update tablename [corrname]\n       [from fromclause]\n       set columnname = dbexpression {, columnname =\n                 dbexpression}\n       [where searchcondition];\n  ```\n- Cursor version:\n  ```\n  update tablename set columnname = dbexpression\n       {, columnname = dbexpression} where current of\n            cursor_variable;\n  ```\n\nwhere fromclause has the following alternative syntaxes:\n```\nfrom tablename [corrname]{, tablename [corrname]}\nfrom :fromvariable\n```\n\nThe update statement modifies the values in columns in a database table.\n\nThe tablename identifies the table that you want to update and must match the table name specified in the open statement for the specified cursor.\n\nEach column that you include in the update statement must also have been specified in the for update clause of the open statement that opened the cursor.\n\nThe optional corrname defines a correlation name for the table. Correlation names provide a shorthand way to refer to tables in a query.\n\nThe optional repeated keyword directs the DBMS to encode and save the query execution plan for the statement. This is a performance enhancement if you intend to execute this statement more than once.\n\nNote: Do not use the repeated keyword if you place the entire where clause, searchcondition, in a single variable or if a table name or column name is represented by a dynamic name.\n\n## Parameters--Update Statement\n\nThis statement has the following parameters:\n\n- tablename: Specifies the name of the database table that you want to update. This is a dynamic name.\n- corrname: Specifies the correlation name for the table. This is a dynamic name. This parameter is used only in the non-cursor version.\n- columnname: Specifies the name of a particular column to be updated in the table. This is a dynamic name.\n- dbexpression: Specifies a database expression\n- searchcondition: Specifies a logical database expression of conditions that must be satisfied by all rows selected. You can use simple variables (preceded by colons) in a search condition wherever you can use a literal. Alternatively, you can place the entire search condition in a single varchar variable, and specify the search condition as the name of this variable (proceeded by a colon). This parameter is only used in the non-cursor version.\n- cursor_variable: Specifies the reference variable that points to the CursorObject for which the statement is issued. Used only in the cursor version.\n- fromvariable: Specifies the entire from clause as a single varchar variable, preeded by a colon. This is a dynamic name.\n\n### Set Clause\n\nThe set clause specifies the columns in the table that you want to update.\n\n### Where Clause\n\nIf you do not include a where clause, OpenROAD updates all of the rows in the table. If you include a where clause, OpenROAD updates only the rows in the table that satisfy searchcondition in the where clause.\n\nThe \"where current of\" clause directs OpenROAD to update the row on which the specified cursor is positioned. The cursor_variable must point to a CursorObject that you opened using a for update clause.\n\n## Update Mode\n\nThe update mode of the cursor, specified when you opened the cursor, affects how you can use the update statement. You can open a cursor for deferred or direct update.\n\n### Deferred Mode\n\nWith deferred mode cursors, you can perform only one operation against each row. This operation can be an update or a delete but not both. Similarly, you cannot use the repeated option with a deferred update cursor. Cursors that are opened for direct update do not have these restrictions. However, if the cursor is a direct update cursor and you perform two cursor updates that are not separated by a fetch statement, you can update the same row twice.\n\nAfter a successful update, OpenROAD sets the IIrowcount system variable to one. The cursor remains pointing to the same row (the State attribute of the CursorObject remains CS_CURRENT) and subsequent update or delete statements for the cursor take effect on the same row. If the update is not successful, OpenROAD sets IIrowcount to -1 or 0.\n\nIf the cursor is not pointing to a row, 4GL generates a runtime error message indicating that you must execute a fetch statement. If the row the cursor is pointing to has been deleted from the underlying database table (as the result, for example, of a non-cursor delete), no row is updated.\n\nIt is not necessary to commit after each cursor update. All the changes that you make are committed when you close the cursor. (Do not update the current row of a cursor, commit the change, and then continue in a loop in order to repeat the process. This process fails because the first commit statement closes the cursor.)\n\nYou must issue any update statements for a cursor in the same session in which you opened the cursor.\n\nFor more information about the update statement, see the Programming Guide.\n\n## Examples--Update Statement\n\nUpdate rows in the projects table with values from the current frame:",
            "Update rows in the projects table with values from the current frame:\n\n```\nrepeated update projects\n     set hours = :hours, duedate = :enddate\n     where name = :name;\ncommit;\n```\n\nUpdate the personnel table with a computed value:\n\n```\nupdate personnel\n     set sal = :salary * 1.1\n     where empno = :empno;\ncommit;\n```\n\nUpdate the salaries of all employees in job category, acc, using the value for a standard raise in the table dept:\n\n```\nupdate employee e from dept d\n     set salary = d.std_raise * e.salary\n     where e.jobcat = 'acc' and d.dname = e.dname;\ncommit;\n```\n\nUpdate the vendor address based on the attributes of the addr reference variable:\n\n```\nupdate vendor\n     set city = :addr.city, state = :addr.state\n     where vendorno = :vno;\ncommit;\n```\n\nUpdate the row pointed to by the open cursor, emp_cursor:\n\n```\nupdate emptable\n     set name = :namefield, age = :agefield\n     where current of emp_cursor;\ncommit;\n```"
        ]
    },
    {
        "instruction": "How can I update the `address` field for all rows in the `vendors` table using the current values of a variable called `refAddr`?",
        "input": "",
        "output": "To update the `address` field for all rows in the `vendors` table using the current values of a variable called `refAddr`, you can use an update statement with a condition that matches all rows and sets the address value to the corresponding values from the reference variable:\n```sql\nUPDATE vendors SET city = :refAddr.city, state = :refAddr.state WHERE vendorno = <vendor number>;\n```\nIn this example, we are setting the `city` and `state` fields for all rows in the `vendors` table to the current values of the `city` and `state` attributes in the `refAddr` variable. We also specify a condition that matches all rows based on the vendor number.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->database_procedures",
        "task_description": "Explain the database procedures in Actian 4GL SQL and how they are used in OpenROAD.",
        "document": [
            "# Update Statement\n\nThis statement updates the values of the columns in a database table.\n\nThis statement has the following syntax:\n\n- Non-cursor version:\n  ```\n  [repeated] update tablename [corrname]\n       [from fromclause]\n       set columnname = dbexpression {, columnname =\n                 dbexpression}\n       [where searchcondition];\n  ```\n- Cursor version:\n  ```\n  update tablename set columnname = dbexpression\n       {, columnname = dbexpression} where current of\n            cursor_variable;\n  ```\n\nwhere fromclause has the following alternative syntaxes:\n```\nfrom tablename [corrname]{, tablename [corrname]}\nfrom :fromvariable\n```\n\nThe update statement modifies the values in columns in a database table.\n\nThe tablename identifies the table that you want to update and must match the table name specified in the open statement for the specified cursor.\n\nEach column that you include in the update statement must also have been specified in the for update clause of the open statement that opened the cursor.\n\nThe optional corrname defines a correlation name for the table. Correlation names provide a shorthand way to refer to tables in a query.\n\nThe optional repeated keyword directs the DBMS to encode and save the query execution plan for the statement. This is a performance enhancement if you intend to execute this statement more than once.\n\nNote: Do not use the repeated keyword if you place the entire where clause, searchcondition, in a single variable or if a table name or column name is represented by a dynamic name.\n\n## Parameters--Update Statement\n\nThis statement has the following parameters:\n\n- tablename: Specifies the name of the database table that you want to update. This is a dynamic name.\n- corrname: Specifies the correlation name for the table. This is a dynamic name. This parameter is used only in the non-cursor version.\n- columnname: Specifies the name of a particular column to be updated in the table. This is a dynamic name.\n- dbexpression: Specifies a database expression\n- searchcondition: Specifies a logical database expression of conditions that must be satisfied by all rows selected. You can use simple variables (preceded by colons) in a search condition wherever you can use a literal. Alternatively, you can place the entire search condition in a single varchar variable, and specify the search condition as the name of this variable (proceeded by a colon). This parameter is only used in the non-cursor version.\n- cursor_variable: Specifies the reference variable that points to the CursorObject for which the statement is issued. Used only in the cursor version.\n- fromvariable: Specifies the entire from clause as a single varchar variable, preeded by a colon. This is a dynamic name.\n\n### Set Clause\n\nThe set clause specifies the columns in the table that you want to update.\n\n### Where Clause\n\nIf you do not include a where clause, OpenROAD updates all of the rows in the table. If you include a where clause, OpenROAD updates only the rows in the table that satisfy searchcondition in the where clause.\n\nThe \"where current of\" clause directs OpenROAD to update the row on which the specified cursor is positioned. The cursor_variable must point to a CursorObject that you opened using a for update clause.\n\n## Update Mode\n\nThe update mode of the cursor, specified when you opened the cursor, affects how you can use the update statement. You can open a cursor for deferred or direct update.\n\n### Deferred Mode\n\nWith deferred mode cursors, you can perform only one operation against each row. This operation can be an update or a delete but not both. Similarly, you cannot use the repeated option with a deferred update cursor. Cursors that are opened for direct update do not have these restrictions. However, if the cursor is a direct update cursor and you perform two cursor updates that are not separated by a fetch statement, you can update the same row twice.\n\nAfter a successful update, OpenROAD sets the IIrowcount system variable to one. The cursor remains pointing to the same row (the State attribute of the CursorObject remains CS_CURRENT) and subsequent update or delete statements for the cursor take effect on the same row. If the update is not successful, OpenROAD sets IIrowcount to -1 or 0.\n\nIf the cursor is not pointing to a row, 4GL generates a runtime error message indicating that you must execute a fetch statement. If the row the cursor is pointing to has been deleted from the underlying database table (as the result, for example, of a non-cursor delete), no row is updated.\n\nIt is not necessary to commit after each cursor update. All the changes that you make are committed when you close the cursor. (Do not update the current row of a cursor, commit the change, and then continue in a loop in order to repeat the process. This process fails because the first commit statement closes the cursor.)\n\nYou must issue any update statements for a cursor in the same session in which you opened the cursor.\n\nFor more information about the update statement, see the Programming Guide.\n\n## Examples--Update Statement\n\nUpdate rows in the projects table with values from the current frame:",
            "Update rows in the projects table with values from the current frame:\n\n```\nrepeated update projects\n     set hours = :hours, duedate = :enddate\n     where name = :name;\ncommit;\n```\n\nUpdate the personnel table with a computed value:\n\n```\nupdate personnel\n     set sal = :salary * 1.1\n     where empno = :empno;\ncommit;\n```\n\nUpdate the salaries of all employees in job category, acc, using the value for a standard raise in the table dept:\n\n```\nupdate employee e from dept d\n     set salary = d.std_raise * e.salary\n     where e.jobcat = 'acc' and d.dname = e.dname;\ncommit;\n```\n\nUpdate the vendor address based on the attributes of the addr reference variable:\n\n```\nupdate vendor\n     set city = :addr.city, state = :addr.state\n     where vendorno = :vno;\ncommit;\n```\n\nUpdate the row pointed to by the open cursor, emp_cursor:\n\n```\nupdate emptable\n     set name = :namefield, age = :agefield\n     where current of emp_cursor;\ncommit;\n```"
        ]
    },
    {
        "instruction": "Explain how to update a specific row in Actian 4GL SQL using the update statement.",
        "input": "",
        "output": "To update a specific row in Actian 4GL SQL, you can use the `update` statement with a `where` clause that specifies the condition for the row you want to modify. Here's an example:\n```\nupdate employees set salary = 60000 where employee_id = 123;\n```\nIn this example, the `employees` table is being updated, and the `salary` column is being modified for the row where the `employee_id` equals `123`.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->database_procedures",
        "task_description": "Explain the database procedures in Actian 4GL SQL and how they are used in OpenROAD.",
        "document": [
            "# Update Statement\n\nThis statement updates the values of the columns in a database table.\n\nThis statement has the following syntax:\n\n- Non-cursor version:\n  ```\n  [repeated] update tablename [corrname]\n       [from fromclause]\n       set columnname = dbexpression {, columnname =\n                 dbexpression}\n       [where searchcondition];\n  ```\n- Cursor version:\n  ```\n  update tablename set columnname = dbexpression\n       {, columnname = dbexpression} where current of\n            cursor_variable;\n  ```\n\nwhere fromclause has the following alternative syntaxes:\n```\nfrom tablename [corrname]{, tablename [corrname]}\nfrom :fromvariable\n```\n\nThe update statement modifies the values in columns in a database table.\n\nThe tablename identifies the table that you want to update and must match the table name specified in the open statement for the specified cursor.\n\nEach column that you include in the update statement must also have been specified in the for update clause of the open statement that opened the cursor.\n\nThe optional corrname defines a correlation name for the table. Correlation names provide a shorthand way to refer to tables in a query.\n\nThe optional repeated keyword directs the DBMS to encode and save the query execution plan for the statement. This is a performance enhancement if you intend to execute this statement more than once.\n\nNote: Do not use the repeated keyword if you place the entire where clause, searchcondition, in a single variable or if a table name or column name is represented by a dynamic name.\n\n## Parameters--Update Statement\n\nThis statement has the following parameters:\n\n- tablename: Specifies the name of the database table that you want to update. This is a dynamic name.\n- corrname: Specifies the correlation name for the table. This is a dynamic name. This parameter is used only in the non-cursor version.\n- columnname: Specifies the name of a particular column to be updated in the table. This is a dynamic name.\n- dbexpression: Specifies a database expression\n- searchcondition: Specifies a logical database expression of conditions that must be satisfied by all rows selected. You can use simple variables (preceded by colons) in a search condition wherever you can use a literal. Alternatively, you can place the entire search condition in a single varchar variable, and specify the search condition as the name of this variable (proceeded by a colon). This parameter is only used in the non-cursor version.\n- cursor_variable: Specifies the reference variable that points to the CursorObject for which the statement is issued. Used only in the cursor version.\n- fromvariable: Specifies the entire from clause as a single varchar variable, preeded by a colon. This is a dynamic name.\n\n### Set Clause\n\nThe set clause specifies the columns in the table that you want to update.\n\n### Where Clause\n\nIf you do not include a where clause, OpenROAD updates all of the rows in the table. If you include a where clause, OpenROAD updates only the rows in the table that satisfy searchcondition in the where clause.\n\nThe \"where current of\" clause directs OpenROAD to update the row on which the specified cursor is positioned. The cursor_variable must point to a CursorObject that you opened using a for update clause.\n\n## Update Mode\n\nThe update mode of the cursor, specified when you opened the cursor, affects how you can use the update statement. You can open a cursor for deferred or direct update.\n\n### Deferred Mode\n\nWith deferred mode cursors, you can perform only one operation against each row. This operation can be an update or a delete but not both. Similarly, you cannot use the repeated option with a deferred update cursor. Cursors that are opened for direct update do not have these restrictions. However, if the cursor is a direct update cursor and you perform two cursor updates that are not separated by a fetch statement, you can update the same row twice.\n\nAfter a successful update, OpenROAD sets the IIrowcount system variable to one. The cursor remains pointing to the same row (the State attribute of the CursorObject remains CS_CURRENT) and subsequent update or delete statements for the cursor take effect on the same row. If the update is not successful, OpenROAD sets IIrowcount to -1 or 0.\n\nIf the cursor is not pointing to a row, 4GL generates a runtime error message indicating that you must execute a fetch statement. If the row the cursor is pointing to has been deleted from the underlying database table (as the result, for example, of a non-cursor delete), no row is updated.\n\nIt is not necessary to commit after each cursor update. All the changes that you make are committed when you close the cursor. (Do not update the current row of a cursor, commit the change, and then continue in a loop in order to repeat the process. This process fails because the first commit statement closes the cursor.)\n\nYou must issue any update statements for a cursor in the same session in which you opened the cursor.\n\nFor more information about the update statement, see the Programming Guide.\n\n## Examples--Update Statement\n\nUpdate rows in the projects table with values from the current frame:",
            "Update rows in the projects table with values from the current frame:\n\n```\nrepeated update projects\n     set hours = :hours, duedate = :enddate\n     where name = :name;\ncommit;\n```\n\nUpdate the personnel table with a computed value:\n\n```\nupdate personnel\n     set sal = :salary * 1.1\n     where empno = :empno;\ncommit;\n```\n\nUpdate the salaries of all employees in job category, acc, using the value for a standard raise in the table dept:\n\n```\nupdate employee e from dept d\n     set salary = d.std_raise * e.salary\n     where e.jobcat = 'acc' and d.dname = e.dname;\ncommit;\n```\n\nUpdate the vendor address based on the attributes of the addr reference variable:\n\n```\nupdate vendor\n     set city = :addr.city, state = :addr.state\n     where vendorno = :vno;\ncommit;\n```\n\nUpdate the row pointed to by the open cursor, emp_cursor:\n\n```\nupdate emptable\n     set name = :namefield, age = :agefield\n     where current of emp_cursor;\ncommit;\n```"
        ]
    },
    {
        "instruction": "What is the difference between direct update mode and deferred update mode in Actian 4GL SQL?",
        "input": "",
        "output": "In Actian 4GL SQL, cursors can be opened for either direct or deferred update mode. Direct update mode allows you to perform multiple operations (such as update, insert, and delete) against the same row without fetching it again. Deferred update mode, on the other hand, only allows one operation per row. Additionally, deferred update mode does not support the `REPEATED` keyword, which can be used for performance enhancement in direct update mode if the same statement is executed multiple times.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->database_procedures",
        "task_description": "Explain the database procedures in Actian 4GL SQL and how they are used in OpenROAD.",
        "document": [
            "# Update Statement\n\nThis statement updates the values of the columns in a database table.\n\nThis statement has the following syntax:\n\n- Non-cursor version:\n  ```\n  [repeated] update tablename [corrname]\n       [from fromclause]\n       set columnname = dbexpression {, columnname =\n                 dbexpression}\n       [where searchcondition];\n  ```\n- Cursor version:\n  ```\n  update tablename set columnname = dbexpression\n       {, columnname = dbexpression} where current of\n            cursor_variable;\n  ```\n\nwhere fromclause has the following alternative syntaxes:\n```\nfrom tablename [corrname]{, tablename [corrname]}\nfrom :fromvariable\n```\n\nThe update statement modifies the values in columns in a database table.\n\nThe tablename identifies the table that you want to update and must match the table name specified in the open statement for the specified cursor.\n\nEach column that you include in the update statement must also have been specified in the for update clause of the open statement that opened the cursor.\n\nThe optional corrname defines a correlation name for the table. Correlation names provide a shorthand way to refer to tables in a query.\n\nThe optional repeated keyword directs the DBMS to encode and save the query execution plan for the statement. This is a performance enhancement if you intend to execute this statement more than once.\n\nNote: Do not use the repeated keyword if you place the entire where clause, searchcondition, in a single variable or if a table name or column name is represented by a dynamic name.\n\n## Parameters--Update Statement\n\nThis statement has the following parameters:\n\n- tablename: Specifies the name of the database table that you want to update. This is a dynamic name.\n- corrname: Specifies the correlation name for the table. This is a dynamic name. This parameter is used only in the non-cursor version.\n- columnname: Specifies the name of a particular column to be updated in the table. This is a dynamic name.\n- dbexpression: Specifies a database expression\n- searchcondition: Specifies a logical database expression of conditions that must be satisfied by all rows selected. You can use simple variables (preceded by colons) in a search condition wherever you can use a literal. Alternatively, you can place the entire search condition in a single varchar variable, and specify the search condition as the name of this variable (proceeded by a colon). This parameter is only used in the non-cursor version.\n- cursor_variable: Specifies the reference variable that points to the CursorObject for which the statement is issued. Used only in the cursor version.\n- fromvariable: Specifies the entire from clause as a single varchar variable, preeded by a colon. This is a dynamic name.\n\n### Set Clause\n\nThe set clause specifies the columns in the table that you want to update.\n\n### Where Clause\n\nIf you do not include a where clause, OpenROAD updates all of the rows in the table. If you include a where clause, OpenROAD updates only the rows in the table that satisfy searchcondition in the where clause.\n\nThe \"where current of\" clause directs OpenROAD to update the row on which the specified cursor is positioned. The cursor_variable must point to a CursorObject that you opened using a for update clause.\n\n## Update Mode\n\nThe update mode of the cursor, specified when you opened the cursor, affects how you can use the update statement. You can open a cursor for deferred or direct update.\n\n### Deferred Mode\n\nWith deferred mode cursors, you can perform only one operation against each row. This operation can be an update or a delete but not both. Similarly, you cannot use the repeated option with a deferred update cursor. Cursors that are opened for direct update do not have these restrictions. However, if the cursor is a direct update cursor and you perform two cursor updates that are not separated by a fetch statement, you can update the same row twice.\n\nAfter a successful update, OpenROAD sets the IIrowcount system variable to one. The cursor remains pointing to the same row (the State attribute of the CursorObject remains CS_CURRENT) and subsequent update or delete statements for the cursor take effect on the same row. If the update is not successful, OpenROAD sets IIrowcount to -1 or 0.\n\nIf the cursor is not pointing to a row, 4GL generates a runtime error message indicating that you must execute a fetch statement. If the row the cursor is pointing to has been deleted from the underlying database table (as the result, for example, of a non-cursor delete), no row is updated.\n\nIt is not necessary to commit after each cursor update. All the changes that you make are committed when you close the cursor. (Do not update the current row of a cursor, commit the change, and then continue in a loop in order to repeat the process. This process fails because the first commit statement closes the cursor.)\n\nYou must issue any update statements for a cursor in the same session in which you opened the cursor.\n\nFor more information about the update statement, see the Programming Guide.\n\n## Examples--Update Statement\n\nUpdate rows in the projects table with values from the current frame:",
            "Update rows in the projects table with values from the current frame:\n\n```\nrepeated update projects\n     set hours = :hours, duedate = :enddate\n     where name = :name;\ncommit;\n```\n\nUpdate the personnel table with a computed value:\n\n```\nupdate personnel\n     set sal = :salary * 1.1\n     where empno = :empno;\ncommit;\n```\n\nUpdate the salaries of all employees in job category, acc, using the value for a standard raise in the table dept:\n\n```\nupdate employee e from dept d\n     set salary = d.std_raise * e.salary\n     where e.jobcat = 'acc' and d.dname = e.dname;\ncommit;\n```\n\nUpdate the vendor address based on the attributes of the addr reference variable:\n\n```\nupdate vendor\n     set city = :addr.city, state = :addr.state\n     where vendorno = :vno;\ncommit;\n```\n\nUpdate the row pointed to by the open cursor, emp_cursor:\n\n```\nupdate emptable\n     set name = :namefield, age = :agefield\n     where current of emp_cursor;\ncommit;\n```"
        ]
    },
    {
        "instruction": "Give an example of the syntax for using an update cursor to modify rows in a table in Actian 4GL SQL when working with OpenROAD.",
        "input": "",
        "output": "Here is an example of the syntax for using an update cursor to modify rows in a table in Actian 4GL SQL when working with OpenROAD:\n```\nOpen projects_cursor for update as projects;\nwhile (not eof(projects_cursor)) do begin\n  if (projects.project_status = 'In Progress') then\n    Update projects set project_priority = 'High' where current of projects_cursor;\n  end if;\n  fetch next from projects_cursor into projects;\nend while;\nclose projects_cursor;\n```\nIn this example, the cursor is named `projects_cursor`, and it is opened for updating a table called `projects`. The cursor is used to loop through each row in the table that satisfies a certain condition (project status of 'In Progress'). For each row, the `update` statement modifies the `project_priority` column to `'High'`.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->database_procedures",
        "task_description": "Explain the database procedures in Actian 4GL SQL and how they are used in OpenROAD.",
        "document": [
            "# Update Statement\n\nThis statement updates the values of the columns in a database table.\n\nThis statement has the following syntax:\n\n- Non-cursor version:\n  ```\n  [repeated] update tablename [corrname]\n       [from fromclause]\n       set columnname = dbexpression {, columnname =\n                 dbexpression}\n       [where searchcondition];\n  ```\n- Cursor version:\n  ```\n  update tablename set columnname = dbexpression\n       {, columnname = dbexpression} where current of\n            cursor_variable;\n  ```\n\nwhere fromclause has the following alternative syntaxes:\n```\nfrom tablename [corrname]{, tablename [corrname]}\nfrom :fromvariable\n```\n\nThe update statement modifies the values in columns in a database table.\n\nThe tablename identifies the table that you want to update and must match the table name specified in the open statement for the specified cursor.\n\nEach column that you include in the update statement must also have been specified in the for update clause of the open statement that opened the cursor.\n\nThe optional corrname defines a correlation name for the table. Correlation names provide a shorthand way to refer to tables in a query.\n\nThe optional repeated keyword directs the DBMS to encode and save the query execution plan for the statement. This is a performance enhancement if you intend to execute this statement more than once.\n\nNote: Do not use the repeated keyword if you place the entire where clause, searchcondition, in a single variable or if a table name or column name is represented by a dynamic name.\n\n## Parameters--Update Statement\n\nThis statement has the following parameters:\n\n- tablename: Specifies the name of the database table that you want to update. This is a dynamic name.\n- corrname: Specifies the correlation name for the table. This is a dynamic name. This parameter is used only in the non-cursor version.\n- columnname: Specifies the name of a particular column to be updated in the table. This is a dynamic name.\n- dbexpression: Specifies a database expression\n- searchcondition: Specifies a logical database expression of conditions that must be satisfied by all rows selected. You can use simple variables (preceded by colons) in a search condition wherever you can use a literal. Alternatively, you can place the entire search condition in a single varchar variable, and specify the search condition as the name of this variable (proceeded by a colon). This parameter is only used in the non-cursor version.\n- cursor_variable: Specifies the reference variable that points to the CursorObject for which the statement is issued. Used only in the cursor version.\n- fromvariable: Specifies the entire from clause as a single varchar variable, preeded by a colon. This is a dynamic name.\n\n### Set Clause\n\nThe set clause specifies the columns in the table that you want to update.\n\n### Where Clause\n\nIf you do not include a where clause, OpenROAD updates all of the rows in the table. If you include a where clause, OpenROAD updates only the rows in the table that satisfy searchcondition in the where clause.\n\nThe \"where current of\" clause directs OpenROAD to update the row on which the specified cursor is positioned. The cursor_variable must point to a CursorObject that you opened using a for update clause.\n\n## Update Mode\n\nThe update mode of the cursor, specified when you opened the cursor, affects how you can use the update statement. You can open a cursor for deferred or direct update.\n\n### Deferred Mode\n\nWith deferred mode cursors, you can perform only one operation against each row. This operation can be an update or a delete but not both. Similarly, you cannot use the repeated option with a deferred update cursor. Cursors that are opened for direct update do not have these restrictions. However, if the cursor is a direct update cursor and you perform two cursor updates that are not separated by a fetch statement, you can update the same row twice.\n\nAfter a successful update, OpenROAD sets the IIrowcount system variable to one. The cursor remains pointing to the same row (the State attribute of the CursorObject remains CS_CURRENT) and subsequent update or delete statements for the cursor take effect on the same row. If the update is not successful, OpenROAD sets IIrowcount to -1 or 0.\n\nIf the cursor is not pointing to a row, 4GL generates a runtime error message indicating that you must execute a fetch statement. If the row the cursor is pointing to has been deleted from the underlying database table (as the result, for example, of a non-cursor delete), no row is updated.\n\nIt is not necessary to commit after each cursor update. All the changes that you make are committed when you close the cursor. (Do not update the current row of a cursor, commit the change, and then continue in a loop in order to repeat the process. This process fails because the first commit statement closes the cursor.)\n\nYou must issue any update statements for a cursor in the same session in which you opened the cursor.\n\nFor more information about the update statement, see the Programming Guide.\n\n## Examples--Update Statement\n\nUpdate rows in the projects table with values from the current frame:",
            "Update rows in the projects table with values from the current frame:\n\n```\nrepeated update projects\n     set hours = :hours, duedate = :enddate\n     where name = :name;\ncommit;\n```\n\nUpdate the personnel table with a computed value:\n\n```\nupdate personnel\n     set sal = :salary * 1.1\n     where empno = :empno;\ncommit;\n```\n\nUpdate the salaries of all employees in job category, acc, using the value for a standard raise in the table dept:\n\n```\nupdate employee e from dept d\n     set salary = d.std_raise * e.salary\n     where e.jobcat = 'acc' and d.dname = e.dname;\ncommit;\n```\n\nUpdate the vendor address based on the attributes of the addr reference variable:\n\n```\nupdate vendor\n     set city = :addr.city, state = :addr.state\n     where vendorno = :vno;\ncommit;\n```\n\nUpdate the row pointed to by the open cursor, emp_cursor:\n\n```\nupdate emptable\n     set name = :namefield, age = :agefield\n     where current of emp_cursor;\ncommit;\n```"
        ]
    },
    {
        "instruction": "Explain how to update multiple columns using the `update` SQL statement in Actian 4GL SQL when working with OpenROAD.",
        "input": "",
        "output": "To update multiple columns using the `update` SQL statement in Actian 4GL SQL when working with OpenROAD, you can specify a comma-separated list of column names and corresponding new values within the `set` clause of the `update` statement. Here is an example:\n```\nUpdate employees set salary = 5000, department_id = 3 where employee_id = 123;\n```\nIn this example, both the `salary` and `department_id` columns are updated for the row with an `employee_id` of 123. The new values are `5000` and `3`, respectively.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->database_procedures",
        "task_description": "Explain the database procedures in Actian 4GL SQL and how they are used in OpenROAD.",
        "document": [
            "# Update Statement\n\nThis statement updates the values of the columns in a database table.\n\nThis statement has the following syntax:\n\n- Non-cursor version:\n  ```\n  [repeated] update tablename [corrname]\n       [from fromclause]\n       set columnname = dbexpression {, columnname =\n                 dbexpression}\n       [where searchcondition];\n  ```\n- Cursor version:\n  ```\n  update tablename set columnname = dbexpression\n       {, columnname = dbexpression} where current of\n            cursor_variable;\n  ```\n\nwhere fromclause has the following alternative syntaxes:\n```\nfrom tablename [corrname]{, tablename [corrname]}\nfrom :fromvariable\n```\n\nThe update statement modifies the values in columns in a database table.\n\nThe tablename identifies the table that you want to update and must match the table name specified in the open statement for the specified cursor.\n\nEach column that you include in the update statement must also have been specified in the for update clause of the open statement that opened the cursor.\n\nThe optional corrname defines a correlation name for the table. Correlation names provide a shorthand way to refer to tables in a query.\n\nThe optional repeated keyword directs the DBMS to encode and save the query execution plan for the statement. This is a performance enhancement if you intend to execute this statement more than once.\n\nNote: Do not use the repeated keyword if you place the entire where clause, searchcondition, in a single variable or if a table name or column name is represented by a dynamic name.\n\n## Parameters--Update Statement\n\nThis statement has the following parameters:\n\n- tablename: Specifies the name of the database table that you want to update. This is a dynamic name.\n- corrname: Specifies the correlation name for the table. This is a dynamic name. This parameter is used only in the non-cursor version.\n- columnname: Specifies the name of a particular column to be updated in the table. This is a dynamic name.\n- dbexpression: Specifies a database expression\n- searchcondition: Specifies a logical database expression of conditions that must be satisfied by all rows selected. You can use simple variables (preceded by colons) in a search condition wherever you can use a literal. Alternatively, you can place the entire search condition in a single varchar variable, and specify the search condition as the name of this variable (proceeded by a colon). This parameter is only used in the non-cursor version.\n- cursor_variable: Specifies the reference variable that points to the CursorObject for which the statement is issued. Used only in the cursor version.\n- fromvariable: Specifies the entire from clause as a single varchar variable, preeded by a colon. This is a dynamic name.\n\n### Set Clause\n\nThe set clause specifies the columns in the table that you want to update.\n\n### Where Clause\n\nIf you do not include a where clause, OpenROAD updates all of the rows in the table. If you include a where clause, OpenROAD updates only the rows in the table that satisfy searchcondition in the where clause.\n\nThe \"where current of\" clause directs OpenROAD to update the row on which the specified cursor is positioned. The cursor_variable must point to a CursorObject that you opened using a for update clause.\n\n## Update Mode\n\nThe update mode of the cursor, specified when you opened the cursor, affects how you can use the update statement. You can open a cursor for deferred or direct update.\n\n### Deferred Mode\n\nWith deferred mode cursors, you can perform only one operation against each row. This operation can be an update or a delete but not both. Similarly, you cannot use the repeated option with a deferred update cursor. Cursors that are opened for direct update do not have these restrictions. However, if the cursor is a direct update cursor and you perform two cursor updates that are not separated by a fetch statement, you can update the same row twice.\n\nAfter a successful update, OpenROAD sets the IIrowcount system variable to one. The cursor remains pointing to the same row (the State attribute of the CursorObject remains CS_CURRENT) and subsequent update or delete statements for the cursor take effect on the same row. If the update is not successful, OpenROAD sets IIrowcount to -1 or 0.\n\nIf the cursor is not pointing to a row, 4GL generates a runtime error message indicating that you must execute a fetch statement. If the row the cursor is pointing to has been deleted from the underlying database table (as the result, for example, of a non-cursor delete), no row is updated.\n\nIt is not necessary to commit after each cursor update. All the changes that you make are committed when you close the cursor. (Do not update the current row of a cursor, commit the change, and then continue in a loop in order to repeat the process. This process fails because the first commit statement closes the cursor.)\n\nYou must issue any update statements for a cursor in the same session in which you opened the cursor.\n\nFor more information about the update statement, see the Programming Guide.\n\n## Examples--Update Statement\n\nUpdate rows in the projects table with values from the current frame:",
            "Update rows in the projects table with values from the current frame:\n\n```\nrepeated update projects\n     set hours = :hours, duedate = :enddate\n     where name = :name;\ncommit;\n```\n\nUpdate the personnel table with a computed value:\n\n```\nupdate personnel\n     set sal = :salary * 1.1\n     where empno = :empno;\ncommit;\n```\n\nUpdate the salaries of all employees in job category, acc, using the value for a standard raise in the table dept:\n\n```\nupdate employee e from dept d\n     set salary = d.std_raise * e.salary\n     where e.jobcat = 'acc' and d.dname = e.dname;\ncommit;\n```\n\nUpdate the vendor address based on the attributes of the addr reference variable:\n\n```\nupdate vendor\n     set city = :addr.city, state = :addr.state\n     where vendorno = :vno;\ncommit;\n```\n\nUpdate the row pointed to by the open cursor, emp_cursor:\n\n```\nupdate emptable\n     set name = :namefield, age = :agefield\n     where current of emp_cursor;\ncommit;\n```"
        ]
    },
    {
        "instruction": "Can you provide an example of how to update multiple rows in Actian 4GL SQL using a single query?",
        "input": "",
        "output": "Yes, you can update multiple rows in Actian 4GL SQL by using the `REPEATED UPDATE` statement. Here's an example:\n\n```sql\nREPEATED UPDATE customers\n    SET city = :new_city\n    WHERE country = :country;\nCOMMIT;\n```\nIn this example, we are updating the 'city' column of all rows in the 'customers' table where the 'country' column is equal to a specified value. The `REPEATED UPDATE` statement is useful when you want to update multiple rows with the same value.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->database_procedures",
        "task_description": "Explain the database procedures in Actian 4GL SQL and how they are used in OpenROAD.",
        "document": [
            "# Update Statement\n\nThis statement updates the values of the columns in a database table.\n\nThis statement has the following syntax:\n\n- Non-cursor version:\n  ```\n  [repeated] update tablename [corrname]\n       [from fromclause]\n       set columnname = dbexpression {, columnname =\n                 dbexpression}\n       [where searchcondition];\n  ```\n- Cursor version:\n  ```\n  update tablename set columnname = dbexpression\n       {, columnname = dbexpression} where current of\n            cursor_variable;\n  ```\n\nwhere fromclause has the following alternative syntaxes:\n```\nfrom tablename [corrname]{, tablename [corrname]}\nfrom :fromvariable\n```\n\nThe update statement modifies the values in columns in a database table.\n\nThe tablename identifies the table that you want to update and must match the table name specified in the open statement for the specified cursor.\n\nEach column that you include in the update statement must also have been specified in the for update clause of the open statement that opened the cursor.\n\nThe optional corrname defines a correlation name for the table. Correlation names provide a shorthand way to refer to tables in a query.\n\nThe optional repeated keyword directs the DBMS to encode and save the query execution plan for the statement. This is a performance enhancement if you intend to execute this statement more than once.\n\nNote: Do not use the repeated keyword if you place the entire where clause, searchcondition, in a single variable or if a table name or column name is represented by a dynamic name.\n\n## Parameters--Update Statement\n\nThis statement has the following parameters:\n\n- tablename: Specifies the name of the database table that you want to update. This is a dynamic name.\n- corrname: Specifies the correlation name for the table. This is a dynamic name. This parameter is used only in the non-cursor version.\n- columnname: Specifies the name of a particular column to be updated in the table. This is a dynamic name.\n- dbexpression: Specifies a database expression\n- searchcondition: Specifies a logical database expression of conditions that must be satisfied by all rows selected. You can use simple variables (preceded by colons) in a search condition wherever you can use a literal. Alternatively, you can place the entire search condition in a single varchar variable, and specify the search condition as the name of this variable (proceeded by a colon). This parameter is only used in the non-cursor version.\n- cursor_variable: Specifies the reference variable that points to the CursorObject for which the statement is issued. Used only in the cursor version.\n- fromvariable: Specifies the entire from clause as a single varchar variable, preeded by a colon. This is a dynamic name.\n\n### Set Clause\n\nThe set clause specifies the columns in the table that you want to update.\n\n### Where Clause\n\nIf you do not include a where clause, OpenROAD updates all of the rows in the table. If you include a where clause, OpenROAD updates only the rows in the table that satisfy searchcondition in the where clause.\n\nThe \"where current of\" clause directs OpenROAD to update the row on which the specified cursor is positioned. The cursor_variable must point to a CursorObject that you opened using a for update clause.\n\n## Update Mode\n\nThe update mode of the cursor, specified when you opened the cursor, affects how you can use the update statement. You can open a cursor for deferred or direct update.\n\n### Deferred Mode\n\nWith deferred mode cursors, you can perform only one operation against each row. This operation can be an update or a delete but not both. Similarly, you cannot use the repeated option with a deferred update cursor. Cursors that are opened for direct update do not have these restrictions. However, if the cursor is a direct update cursor and you perform two cursor updates that are not separated by a fetch statement, you can update the same row twice.\n\nAfter a successful update, OpenROAD sets the IIrowcount system variable to one. The cursor remains pointing to the same row (the State attribute of the CursorObject remains CS_CURRENT) and subsequent update or delete statements for the cursor take effect on the same row. If the update is not successful, OpenROAD sets IIrowcount to -1 or 0.\n\nIf the cursor is not pointing to a row, 4GL generates a runtime error message indicating that you must execute a fetch statement. If the row the cursor is pointing to has been deleted from the underlying database table (as the result, for example, of a non-cursor delete), no row is updated.\n\nIt is not necessary to commit after each cursor update. All the changes that you make are committed when you close the cursor. (Do not update the current row of a cursor, commit the change, and then continue in a loop in order to repeat the process. This process fails because the first commit statement closes the cursor.)\n\nYou must issue any update statements for a cursor in the same session in which you opened the cursor.\n\nFor more information about the update statement, see the Programming Guide.\n\n## Examples--Update Statement\n\nUpdate rows in the projects table with values from the current frame:",
            "Update rows in the projects table with values from the current frame:\n\n```\nrepeated update projects\n     set hours = :hours, duedate = :enddate\n     where name = :name;\ncommit;\n```\n\nUpdate the personnel table with a computed value:\n\n```\nupdate personnel\n     set sal = :salary * 1.1\n     where empno = :empno;\ncommit;\n```\n\nUpdate the salaries of all employees in job category, acc, using the value for a standard raise in the table dept:\n\n```\nupdate employee e from dept d\n     set salary = d.std_raise * e.salary\n     where e.jobcat = 'acc' and d.dname = e.dname;\ncommit;\n```\n\nUpdate the vendor address based on the attributes of the addr reference variable:\n\n```\nupdate vendor\n     set city = :addr.city, state = :addr.state\n     where vendorno = :vno;\ncommit;\n```\n\nUpdate the row pointed to by the open cursor, emp_cursor:\n\n```\nupdate emptable\n     set name = :namefield, age = :agefield\n     where current of emp_cursor;\ncommit;\n```"
        ]
    },
    {
        "instruction": "Can you explain how to perform a conditional update using Actian 4GL SQL and provide an example?",
        "input": "",
        "output": "In Actian 4GL SQL, you can perform a conditional update by using the `IF` statement in your query. Here's an example:\n\n```sql\nUPDATE employee\n    SET salary = IF (salary < 30000, 30000, salary)\n    WHERE jobcat = 'acc';\nCOMMIT;\n```\nIn this example, we are updating the salary column of all employees whose job category is 'acc'. If their current salary is less than 30000, then it is set to 30000. Otherwise, the existing salary remains unchanged.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->database_procedures",
        "task_description": "Explain the database procedures in Actian 4GL SQL and how they are used in OpenROAD.",
        "document": [
            "# Update Statement\n\nThis statement updates the values of the columns in a database table.\n\nThis statement has the following syntax:\n\n- Non-cursor version:\n  ```\n  [repeated] update tablename [corrname]\n       [from fromclause]\n       set columnname = dbexpression {, columnname =\n                 dbexpression}\n       [where searchcondition];\n  ```\n- Cursor version:\n  ```\n  update tablename set columnname = dbexpression\n       {, columnname = dbexpression} where current of\n            cursor_variable;\n  ```\n\nwhere fromclause has the following alternative syntaxes:\n```\nfrom tablename [corrname]{, tablename [corrname]}\nfrom :fromvariable\n```\n\nThe update statement modifies the values in columns in a database table.\n\nThe tablename identifies the table that you want to update and must match the table name specified in the open statement for the specified cursor.\n\nEach column that you include in the update statement must also have been specified in the for update clause of the open statement that opened the cursor.\n\nThe optional corrname defines a correlation name for the table. Correlation names provide a shorthand way to refer to tables in a query.\n\nThe optional repeated keyword directs the DBMS to encode and save the query execution plan for the statement. This is a performance enhancement if you intend to execute this statement more than once.\n\nNote: Do not use the repeated keyword if you place the entire where clause, searchcondition, in a single variable or if a table name or column name is represented by a dynamic name.\n\n## Parameters--Update Statement\n\nThis statement has the following parameters:\n\n- tablename: Specifies the name of the database table that you want to update. This is a dynamic name.\n- corrname: Specifies the correlation name for the table. This is a dynamic name. This parameter is used only in the non-cursor version.\n- columnname: Specifies the name of a particular column to be updated in the table. This is a dynamic name.\n- dbexpression: Specifies a database expression\n- searchcondition: Specifies a logical database expression of conditions that must be satisfied by all rows selected. You can use simple variables (preceded by colons) in a search condition wherever you can use a literal. Alternatively, you can place the entire search condition in a single varchar variable, and specify the search condition as the name of this variable (proceeded by a colon). This parameter is only used in the non-cursor version.\n- cursor_variable: Specifies the reference variable that points to the CursorObject for which the statement is issued. Used only in the cursor version.\n- fromvariable: Specifies the entire from clause as a single varchar variable, preeded by a colon. This is a dynamic name.\n\n### Set Clause\n\nThe set clause specifies the columns in the table that you want to update.\n\n### Where Clause\n\nIf you do not include a where clause, OpenROAD updates all of the rows in the table. If you include a where clause, OpenROAD updates only the rows in the table that satisfy searchcondition in the where clause.\n\nThe \"where current of\" clause directs OpenROAD to update the row on which the specified cursor is positioned. The cursor_variable must point to a CursorObject that you opened using a for update clause.\n\n## Update Mode\n\nThe update mode of the cursor, specified when you opened the cursor, affects how you can use the update statement. You can open a cursor for deferred or direct update.\n\n### Deferred Mode\n\nWith deferred mode cursors, you can perform only one operation against each row. This operation can be an update or a delete but not both. Similarly, you cannot use the repeated option with a deferred update cursor. Cursors that are opened for direct update do not have these restrictions. However, if the cursor is a direct update cursor and you perform two cursor updates that are not separated by a fetch statement, you can update the same row twice.\n\nAfter a successful update, OpenROAD sets the IIrowcount system variable to one. The cursor remains pointing to the same row (the State attribute of the CursorObject remains CS_CURRENT) and subsequent update or delete statements for the cursor take effect on the same row. If the update is not successful, OpenROAD sets IIrowcount to -1 or 0.\n\nIf the cursor is not pointing to a row, 4GL generates a runtime error message indicating that you must execute a fetch statement. If the row the cursor is pointing to has been deleted from the underlying database table (as the result, for example, of a non-cursor delete), no row is updated.\n\nIt is not necessary to commit after each cursor update. All the changes that you make are committed when you close the cursor. (Do not update the current row of a cursor, commit the change, and then continue in a loop in order to repeat the process. This process fails because the first commit statement closes the cursor.)\n\nYou must issue any update statements for a cursor in the same session in which you opened the cursor.\n\nFor more information about the update statement, see the Programming Guide.\n\n## Examples--Update Statement\n\nUpdate rows in the projects table with values from the current frame:",
            "Update rows in the projects table with values from the current frame:\n\n```\nrepeated update projects\n     set hours = :hours, duedate = :enddate\n     where name = :name;\ncommit;\n```\n\nUpdate the personnel table with a computed value:\n\n```\nupdate personnel\n     set sal = :salary * 1.1\n     where empno = :empno;\ncommit;\n```\n\nUpdate the salaries of all employees in job category, acc, using the value for a standard raise in the table dept:\n\n```\nupdate employee e from dept d\n     set salary = d.std_raise * e.salary\n     where e.jobcat = 'acc' and d.dname = e.dname;\ncommit;\n```\n\nUpdate the vendor address based on the attributes of the addr reference variable:\n\n```\nupdate vendor\n     set city = :addr.city, state = :addr.state\n     where vendorno = :vno;\ncommit;\n```\n\nUpdate the row pointed to by the open cursor, emp_cursor:\n\n```\nupdate emptable\n     set name = :namefield, age = :agefield\n     where current of emp_cursor;\ncommit;\n```"
        ]
    },
    {
        "instruction": "Provide an example of updating multiple rows in Actian 4GL SQL using a subquery.",
        "input": "",
        "output": "Using a subquery to update multiple rows in Actian 4GL SQL is similar to updating rows based on a condition. Here's an example:\n```sql\nupdate projects p\nset hours = (select avg(hours) from projects where project_category = 'IT')\nwhere project_category = 'IT';\n```\nIn this example, we are updating the `hours` column of all rows in the 'projects' table that have a `project_category` of 'IT'. The new value for the `hours` column is obtained from the average `hours` value of all rows where the `project_category` is also 'IT'.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->database_procedures",
        "task_description": "Explain the database procedures in Actian 4GL SQL and how they are used in OpenROAD.",
        "document": [
            "# Update Statement\n\nThis statement updates the values of the columns in a database table.\n\nThis statement has the following syntax:\n\n- Non-cursor version:\n  ```\n  [repeated] update tablename [corrname]\n       [from fromclause]\n       set columnname = dbexpression {, columnname =\n                 dbexpression}\n       [where searchcondition];\n  ```\n- Cursor version:\n  ```\n  update tablename set columnname = dbexpression\n       {, columnname = dbexpression} where current of\n            cursor_variable;\n  ```\n\nwhere fromclause has the following alternative syntaxes:\n```\nfrom tablename [corrname]{, tablename [corrname]}\nfrom :fromvariable\n```\n\nThe update statement modifies the values in columns in a database table.\n\nThe tablename identifies the table that you want to update and must match the table name specified in the open statement for the specified cursor.\n\nEach column that you include in the update statement must also have been specified in the for update clause of the open statement that opened the cursor.\n\nThe optional corrname defines a correlation name for the table. Correlation names provide a shorthand way to refer to tables in a query.\n\nThe optional repeated keyword directs the DBMS to encode and save the query execution plan for the statement. This is a performance enhancement if you intend to execute this statement more than once.\n\nNote: Do not use the repeated keyword if you place the entire where clause, searchcondition, in a single variable or if a table name or column name is represented by a dynamic name.\n\n## Parameters--Update Statement\n\nThis statement has the following parameters:\n\n- tablename: Specifies the name of the database table that you want to update. This is a dynamic name.\n- corrname: Specifies the correlation name for the table. This is a dynamic name. This parameter is used only in the non-cursor version.\n- columnname: Specifies the name of a particular column to be updated in the table. This is a dynamic name.\n- dbexpression: Specifies a database expression\n- searchcondition: Specifies a logical database expression of conditions that must be satisfied by all rows selected. You can use simple variables (preceded by colons) in a search condition wherever you can use a literal. Alternatively, you can place the entire search condition in a single varchar variable, and specify the search condition as the name of this variable (proceeded by a colon). This parameter is only used in the non-cursor version.\n- cursor_variable: Specifies the reference variable that points to the CursorObject for which the statement is issued. Used only in the cursor version.\n- fromvariable: Specifies the entire from clause as a single varchar variable, preeded by a colon. This is a dynamic name.\n\n### Set Clause\n\nThe set clause specifies the columns in the table that you want to update.\n\n### Where Clause\n\nIf you do not include a where clause, OpenROAD updates all of the rows in the table. If you include a where clause, OpenROAD updates only the rows in the table that satisfy searchcondition in the where clause.\n\nThe \"where current of\" clause directs OpenROAD to update the row on which the specified cursor is positioned. The cursor_variable must point to a CursorObject that you opened using a for update clause.\n\n## Update Mode\n\nThe update mode of the cursor, specified when you opened the cursor, affects how you can use the update statement. You can open a cursor for deferred or direct update.\n\n### Deferred Mode\n\nWith deferred mode cursors, you can perform only one operation against each row. This operation can be an update or a delete but not both. Similarly, you cannot use the repeated option with a deferred update cursor. Cursors that are opened for direct update do not have these restrictions. However, if the cursor is a direct update cursor and you perform two cursor updates that are not separated by a fetch statement, you can update the same row twice.\n\nAfter a successful update, OpenROAD sets the IIrowcount system variable to one. The cursor remains pointing to the same row (the State attribute of the CursorObject remains CS_CURRENT) and subsequent update or delete statements for the cursor take effect on the same row. If the update is not successful, OpenROAD sets IIrowcount to -1 or 0.\n\nIf the cursor is not pointing to a row, 4GL generates a runtime error message indicating that you must execute a fetch statement. If the row the cursor is pointing to has been deleted from the underlying database table (as the result, for example, of a non-cursor delete), no row is updated.\n\nIt is not necessary to commit after each cursor update. All the changes that you make are committed when you close the cursor. (Do not update the current row of a cursor, commit the change, and then continue in a loop in order to repeat the process. This process fails because the first commit statement closes the cursor.)\n\nYou must issue any update statements for a cursor in the same session in which you opened the cursor.\n\nFor more information about the update statement, see the Programming Guide.\n\n## Examples--Update Statement\n\nUpdate rows in the projects table with values from the current frame:",
            "Update rows in the projects table with values from the current frame:\n\n```\nrepeated update projects\n     set hours = :hours, duedate = :enddate\n     where name = :name;\ncommit;\n```\n\nUpdate the personnel table with a computed value:\n\n```\nupdate personnel\n     set sal = :salary * 1.1\n     where empno = :empno;\ncommit;\n```\n\nUpdate the salaries of all employees in job category, acc, using the value for a standard raise in the table dept:\n\n```\nupdate employee e from dept d\n     set salary = d.std_raise * e.salary\n     where e.jobcat = 'acc' and d.dname = e.dname;\ncommit;\n```\n\nUpdate the vendor address based on the attributes of the addr reference variable:\n\n```\nupdate vendor\n     set city = :addr.city, state = :addr.state\n     where vendorno = :vno;\ncommit;\n```\n\nUpdate the row pointed to by the open cursor, emp_cursor:\n\n```\nupdate emptable\n     set name = :namefield, age = :agefield\n     where current of emp_cursor;\ncommit;\n```"
        ]
    },
    {
        "instruction": "Describe a scenario in which you would use a stored procedure to update rows based on multiple conditions in Actian 4GL SQL.",
        "input": "",
        "output": "A common scenario in which a stored procedure is used to update rows based on multiple conditions is when there are complex conditional logic and joins involved. Here's an example:\n```sql\nprocedure update_sales_commission()\nbegin\n  update sales s\n  join employees e on s.employee_id = e.id\n  set commission = (e.salary * s.sales_amount) / 100\n  where s.region = 'West' and s.quarter = 'Q3';\ncommit;\nend;\n```\nIn this example, we have a stored procedure called `update_sales_commission`. This procedure updates the commission of employees based on their sales in the West region during the third quarter. The logic involves joining the `sales` and `employees` tables, performing calculations on both, and applying conditions to filter the rows that should be updated.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->database_procedures",
        "task_description": "Explain the database procedures in Actian 4GL SQL and how they are used in OpenROAD.",
        "document": [
            "# Update Statement\n\nThis statement updates the values of the columns in a database table.\n\nThis statement has the following syntax:\n\n- Non-cursor version:\n  ```\n  [repeated] update tablename [corrname]\n       [from fromclause]\n       set columnname = dbexpression {, columnname =\n                 dbexpression}\n       [where searchcondition];\n  ```\n- Cursor version:\n  ```\n  update tablename set columnname = dbexpression\n       {, columnname = dbexpression} where current of\n            cursor_variable;\n  ```\n\nwhere fromclause has the following alternative syntaxes:\n```\nfrom tablename [corrname]{, tablename [corrname]}\nfrom :fromvariable\n```\n\nThe update statement modifies the values in columns in a database table.\n\nThe tablename identifies the table that you want to update and must match the table name specified in the open statement for the specified cursor.\n\nEach column that you include in the update statement must also have been specified in the for update clause of the open statement that opened the cursor.\n\nThe optional corrname defines a correlation name for the table. Correlation names provide a shorthand way to refer to tables in a query.\n\nThe optional repeated keyword directs the DBMS to encode and save the query execution plan for the statement. This is a performance enhancement if you intend to execute this statement more than once.\n\nNote: Do not use the repeated keyword if you place the entire where clause, searchcondition, in a single variable or if a table name or column name is represented by a dynamic name.\n\n## Parameters--Update Statement\n\nThis statement has the following parameters:\n\n- tablename: Specifies the name of the database table that you want to update. This is a dynamic name.\n- corrname: Specifies the correlation name for the table. This is a dynamic name. This parameter is used only in the non-cursor version.\n- columnname: Specifies the name of a particular column to be updated in the table. This is a dynamic name.\n- dbexpression: Specifies a database expression\n- searchcondition: Specifies a logical database expression of conditions that must be satisfied by all rows selected. You can use simple variables (preceded by colons) in a search condition wherever you can use a literal. Alternatively, you can place the entire search condition in a single varchar variable, and specify the search condition as the name of this variable (proceeded by a colon). This parameter is only used in the non-cursor version.\n- cursor_variable: Specifies the reference variable that points to the CursorObject for which the statement is issued. Used only in the cursor version.\n- fromvariable: Specifies the entire from clause as a single varchar variable, preeded by a colon. This is a dynamic name.\n\n### Set Clause\n\nThe set clause specifies the columns in the table that you want to update.\n\n### Where Clause\n\nIf you do not include a where clause, OpenROAD updates all of the rows in the table. If you include a where clause, OpenROAD updates only the rows in the table that satisfy searchcondition in the where clause.\n\nThe \"where current of\" clause directs OpenROAD to update the row on which the specified cursor is positioned. The cursor_variable must point to a CursorObject that you opened using a for update clause.\n\n## Update Mode\n\nThe update mode of the cursor, specified when you opened the cursor, affects how you can use the update statement. You can open a cursor for deferred or direct update.\n\n### Deferred Mode\n\nWith deferred mode cursors, you can perform only one operation against each row. This operation can be an update or a delete but not both. Similarly, you cannot use the repeated option with a deferred update cursor. Cursors that are opened for direct update do not have these restrictions. However, if the cursor is a direct update cursor and you perform two cursor updates that are not separated by a fetch statement, you can update the same row twice.\n\nAfter a successful update, OpenROAD sets the IIrowcount system variable to one. The cursor remains pointing to the same row (the State attribute of the CursorObject remains CS_CURRENT) and subsequent update or delete statements for the cursor take effect on the same row. If the update is not successful, OpenROAD sets IIrowcount to -1 or 0.\n\nIf the cursor is not pointing to a row, 4GL generates a runtime error message indicating that you must execute a fetch statement. If the row the cursor is pointing to has been deleted from the underlying database table (as the result, for example, of a non-cursor delete), no row is updated.\n\nIt is not necessary to commit after each cursor update. All the changes that you make are committed when you close the cursor. (Do not update the current row of a cursor, commit the change, and then continue in a loop in order to repeat the process. This process fails because the first commit statement closes the cursor.)\n\nYou must issue any update statements for a cursor in the same session in which you opened the cursor.\n\nFor more information about the update statement, see the Programming Guide.\n\n## Examples--Update Statement\n\nUpdate rows in the projects table with values from the current frame:",
            "Update rows in the projects table with values from the current frame:\n\n```\nrepeated update projects\n     set hours = :hours, duedate = :enddate\n     where name = :name;\ncommit;\n```\n\nUpdate the personnel table with a computed value:\n\n```\nupdate personnel\n     set sal = :salary * 1.1\n     where empno = :empno;\ncommit;\n```\n\nUpdate the salaries of all employees in job category, acc, using the value for a standard raise in the table dept:\n\n```\nupdate employee e from dept d\n     set salary = d.std_raise * e.salary\n     where e.jobcat = 'acc' and d.dname = e.dname;\ncommit;\n```\n\nUpdate the vendor address based on the attributes of the addr reference variable:\n\n```\nupdate vendor\n     set city = :addr.city, state = :addr.state\n     where vendorno = :vno;\ncommit;\n```\n\nUpdate the row pointed to by the open cursor, emp_cursor:\n\n```\nupdate emptable\n     set name = :namefield, age = :agefield\n     where current of emp_cursor;\ncommit;\n```"
        ]
    },
    {
        "instruction": "Explain how to use the set clause in Actian 4GL SQL update statement.",
        "input": "",
        "output": "The SET clause is used in Actian 4GL SQL UPDATE statement to specify the columns that need to be updated with new values during a database operation. It allows you to change multiple fields in the same row at once. Here's an example:\n```sql\nupdate employees set salary = 5000, age = 30 where employee_id = '001';\n```\nIn this case, the columns \"salary\" and \"age\" of a specific row will be updated with new values.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->database_procedures",
        "task_description": "Explain the database procedures in Actian 4GL SQL and how they are used in OpenROAD.",
        "document": [
            "# Update Statement\n\nThis statement updates the values of the columns in a database table.\n\nThis statement has the following syntax:\n\n- Non-cursor version:\n  ```\n  [repeated] update tablename [corrname]\n       [from fromclause]\n       set columnname = dbexpression {, columnname =\n                 dbexpression}\n       [where searchcondition];\n  ```\n- Cursor version:\n  ```\n  update tablename set columnname = dbexpression\n       {, columnname = dbexpression} where current of\n            cursor_variable;\n  ```\n\nwhere fromclause has the following alternative syntaxes:\n```\nfrom tablename [corrname]{, tablename [corrname]}\nfrom :fromvariable\n```\n\nThe update statement modifies the values in columns in a database table.\n\nThe tablename identifies the table that you want to update and must match the table name specified in the open statement for the specified cursor.\n\nEach column that you include in the update statement must also have been specified in the for update clause of the open statement that opened the cursor.\n\nThe optional corrname defines a correlation name for the table. Correlation names provide a shorthand way to refer to tables in a query.\n\nThe optional repeated keyword directs the DBMS to encode and save the query execution plan for the statement. This is a performance enhancement if you intend to execute this statement more than once.\n\nNote: Do not use the repeated keyword if you place the entire where clause, searchcondition, in a single variable or if a table name or column name is represented by a dynamic name.\n\n## Parameters--Update Statement\n\nThis statement has the following parameters:\n\n- tablename: Specifies the name of the database table that you want to update. This is a dynamic name.\n- corrname: Specifies the correlation name for the table. This is a dynamic name. This parameter is used only in the non-cursor version.\n- columnname: Specifies the name of a particular column to be updated in the table. This is a dynamic name.\n- dbexpression: Specifies a database expression\n- searchcondition: Specifies a logical database expression of conditions that must be satisfied by all rows selected. You can use simple variables (preceded by colons) in a search condition wherever you can use a literal. Alternatively, you can place the entire search condition in a single varchar variable, and specify the search condition as the name of this variable (proceeded by a colon). This parameter is only used in the non-cursor version.\n- cursor_variable: Specifies the reference variable that points to the CursorObject for which the statement is issued. Used only in the cursor version.\n- fromvariable: Specifies the entire from clause as a single varchar variable, preeded by a colon. This is a dynamic name.\n\n### Set Clause\n\nThe set clause specifies the columns in the table that you want to update.\n\n### Where Clause\n\nIf you do not include a where clause, OpenROAD updates all of the rows in the table. If you include a where clause, OpenROAD updates only the rows in the table that satisfy searchcondition in the where clause.\n\nThe \"where current of\" clause directs OpenROAD to update the row on which the specified cursor is positioned. The cursor_variable must point to a CursorObject that you opened using a for update clause.\n\n## Update Mode\n\nThe update mode of the cursor, specified when you opened the cursor, affects how you can use the update statement. You can open a cursor for deferred or direct update.\n\n### Deferred Mode\n\nWith deferred mode cursors, you can perform only one operation against each row. This operation can be an update or a delete but not both. Similarly, you cannot use the repeated option with a deferred update cursor. Cursors that are opened for direct update do not have these restrictions. However, if the cursor is a direct update cursor and you perform two cursor updates that are not separated by a fetch statement, you can update the same row twice.\n\nAfter a successful update, OpenROAD sets the IIrowcount system variable to one. The cursor remains pointing to the same row (the State attribute of the CursorObject remains CS_CURRENT) and subsequent update or delete statements for the cursor take effect on the same row. If the update is not successful, OpenROAD sets IIrowcount to -1 or 0.\n\nIf the cursor is not pointing to a row, 4GL generates a runtime error message indicating that you must execute a fetch statement. If the row the cursor is pointing to has been deleted from the underlying database table (as the result, for example, of a non-cursor delete), no row is updated.\n\nIt is not necessary to commit after each cursor update. All the changes that you make are committed when you close the cursor. (Do not update the current row of a cursor, commit the change, and then continue in a loop in order to repeat the process. This process fails because the first commit statement closes the cursor.)\n\nYou must issue any update statements for a cursor in the same session in which you opened the cursor.\n\nFor more information about the update statement, see the Programming Guide.\n\n## Examples--Update Statement\n\nUpdate rows in the projects table with values from the current frame:",
            "Update rows in the projects table with values from the current frame:\n\n```\nrepeated update projects\n     set hours = :hours, duedate = :enddate\n     where name = :name;\ncommit;\n```\n\nUpdate the personnel table with a computed value:\n\n```\nupdate personnel\n     set sal = :salary * 1.1\n     where empno = :empno;\ncommit;\n```\n\nUpdate the salaries of all employees in job category, acc, using the value for a standard raise in the table dept:\n\n```\nupdate employee e from dept d\n     set salary = d.std_raise * e.salary\n     where e.jobcat = 'acc' and d.dname = e.dname;\ncommit;\n```\n\nUpdate the vendor address based on the attributes of the addr reference variable:\n\n```\nupdate vendor\n     set city = :addr.city, state = :addr.state\n     where vendorno = :vno;\ncommit;\n```\n\nUpdate the row pointed to by the open cursor, emp_cursor:\n\n```\nupdate emptable\n     set name = :namefield, age = :agefield\n     where current of emp_cursor;\ncommit;\n```"
        ]
    },
    {
        "instruction": "How can we update rows in a database table using a cursor in Actian 4GL SQL?",
        "input": "",
        "output": "To update rows using a cursor, you first have to open the cursor and position it on the desired row. After that, you can use an UPDATE statement with \"where current of\" clause, as shown below:\n```sql\nupdate employees set salary = 5000 where current of cur_employees;\n```\nIn this example, 'cur_employees' is the cursor variable that was previously defined. Replace it with your own valid cursor variable name.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->database_procedures",
        "task_description": "Explain the database procedures in Actian 4GL SQL and how they are used in OpenROAD.",
        "document": [
            "# Update Statement\n\nThis statement updates the values of the columns in a database table.\n\nThis statement has the following syntax:\n\n- Non-cursor version:\n  ```\n  [repeated] update tablename [corrname]\n       [from fromclause]\n       set columnname = dbexpression {, columnname =\n                 dbexpression}\n       [where searchcondition];\n  ```\n- Cursor version:\n  ```\n  update tablename set columnname = dbexpression\n       {, columnname = dbexpression} where current of\n            cursor_variable;\n  ```\n\nwhere fromclause has the following alternative syntaxes:\n```\nfrom tablename [corrname]{, tablename [corrname]}\nfrom :fromvariable\n```\n\nThe update statement modifies the values in columns in a database table.\n\nThe tablename identifies the table that you want to update and must match the table name specified in the open statement for the specified cursor.\n\nEach column that you include in the update statement must also have been specified in the for update clause of the open statement that opened the cursor.\n\nThe optional corrname defines a correlation name for the table. Correlation names provide a shorthand way to refer to tables in a query.\n\nThe optional repeated keyword directs the DBMS to encode and save the query execution plan for the statement. This is a performance enhancement if you intend to execute this statement more than once.\n\nNote: Do not use the repeated keyword if you place the entire where clause, searchcondition, in a single variable or if a table name or column name is represented by a dynamic name.\n\n## Parameters--Update Statement\n\nThis statement has the following parameters:\n\n- tablename: Specifies the name of the database table that you want to update. This is a dynamic name.\n- corrname: Specifies the correlation name for the table. This is a dynamic name. This parameter is used only in the non-cursor version.\n- columnname: Specifies the name of a particular column to be updated in the table. This is a dynamic name.\n- dbexpression: Specifies a database expression\n- searchcondition: Specifies a logical database expression of conditions that must be satisfied by all rows selected. You can use simple variables (preceded by colons) in a search condition wherever you can use a literal. Alternatively, you can place the entire search condition in a single varchar variable, and specify the search condition as the name of this variable (proceeded by a colon). This parameter is only used in the non-cursor version.\n- cursor_variable: Specifies the reference variable that points to the CursorObject for which the statement is issued. Used only in the cursor version.\n- fromvariable: Specifies the entire from clause as a single varchar variable, preeded by a colon. This is a dynamic name.\n\n### Set Clause\n\nThe set clause specifies the columns in the table that you want to update.\n\n### Where Clause\n\nIf you do not include a where clause, OpenROAD updates all of the rows in the table. If you include a where clause, OpenROAD updates only the rows in the table that satisfy searchcondition in the where clause.\n\nThe \"where current of\" clause directs OpenROAD to update the row on which the specified cursor is positioned. The cursor_variable must point to a CursorObject that you opened using a for update clause.\n\n## Update Mode\n\nThe update mode of the cursor, specified when you opened the cursor, affects how you can use the update statement. You can open a cursor for deferred or direct update.\n\n### Deferred Mode\n\nWith deferred mode cursors, you can perform only one operation against each row. This operation can be an update or a delete but not both. Similarly, you cannot use the repeated option with a deferred update cursor. Cursors that are opened for direct update do not have these restrictions. However, if the cursor is a direct update cursor and you perform two cursor updates that are not separated by a fetch statement, you can update the same row twice.\n\nAfter a successful update, OpenROAD sets the IIrowcount system variable to one. The cursor remains pointing to the same row (the State attribute of the CursorObject remains CS_CURRENT) and subsequent update or delete statements for the cursor take effect on the same row. If the update is not successful, OpenROAD sets IIrowcount to -1 or 0.\n\nIf the cursor is not pointing to a row, 4GL generates a runtime error message indicating that you must execute a fetch statement. If the row the cursor is pointing to has been deleted from the underlying database table (as the result, for example, of a non-cursor delete), no row is updated.\n\nIt is not necessary to commit after each cursor update. All the changes that you make are committed when you close the cursor. (Do not update the current row of a cursor, commit the change, and then continue in a loop in order to repeat the process. This process fails because the first commit statement closes the cursor.)\n\nYou must issue any update statements for a cursor in the same session in which you opened the cursor.\n\nFor more information about the update statement, see the Programming Guide.\n\n## Examples--Update Statement\n\nUpdate rows in the projects table with values from the current frame:",
            "Update rows in the projects table with values from the current frame:\n\n```\nrepeated update projects\n     set hours = :hours, duedate = :enddate\n     where name = :name;\ncommit;\n```\n\nUpdate the personnel table with a computed value:\n\n```\nupdate personnel\n     set sal = :salary * 1.1\n     where empno = :empno;\ncommit;\n```\n\nUpdate the salaries of all employees in job category, acc, using the value for a standard raise in the table dept:\n\n```\nupdate employee e from dept d\n     set salary = d.std_raise * e.salary\n     where e.jobcat = 'acc' and d.dname = e.dname;\ncommit;\n```\n\nUpdate the vendor address based on the attributes of the addr reference variable:\n\n```\nupdate vendor\n     set city = :addr.city, state = :addr.state\n     where vendorno = :vno;\ncommit;\n```\n\nUpdate the row pointed to by the open cursor, emp_cursor:\n\n```\nupdate emptable\n     set name = :namefield, age = :agefield\n     where current of emp_cursor;\ncommit;\n```"
        ]
    }
]