[
    {
        "instruction": "Explain the difference between fixed-length and variable-length data formats in Actian 4GL SQL COPY statements.",
        "input": "",
        "output": "In Actian 4GL SQL COPY statements, fixed-length data formats have a predefined length for each field or column, while variable-length data formats allow the length of each field to vary. For example, byte(n) is a fixed-length format with a specified length n, whereas byte(0) is a variable-length format without a defined length. This difference in formatting can affect data processing and transfer speeds, as well as storage requirements.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "# Copy Statement\n\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\n\nThis statement has the following syntax:\n\n```sql\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\n```\n\n## Parameters--Copy Statement\n\nThis statement has the following parameters:\n\n- **table_name**: Specifies an existing table from which data is read or to which data is written.\n- **column_name**: Specifies the column from which data is read or to which data is written.\n- **format**: Specifies the format in which a value is stored in the file.\n- **filename**: Specifies the file from which data is read or to which data is written.\n- **type**: (Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\n\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\n\n- **with_clause**: Consists of the word with, followed by a comma-separated list of one or more of the following items:\n  - on_error = TERMINATE | CONTINUE\n  - error_count = n\n  - rollback = ENABLED | DISABLED\n  - log = 'filename'\n\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\n- allocation = n\n- extend = n\n- fillfactor = n (ISAM, Hash, and Btree only)\n- minpages = n (Hash only)\n- maxpages = n (Hash only)\n- leaffill = n (Btree only)\n- nonleaffill = n (Btree only)\n- row_estimate = n\n\n## Unformatted Copying\n\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\n\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\n\n```sql\ncopy table employee () into 'emp_name';\n```\n\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\n\nNote: An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\n\n## Formatted Copying\n\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\n\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\n\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\n\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\n\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).",
            "The values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.\n\nNote: If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\n\n```sql\ncopy table t (col1=c20, col2=c30, d0=nl) into 't.out':\n```\n\n## Bulk Copying\n\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\n\nThe requirements for performing a bulk copy are:\n\n- The table is not journaled\n- The table has no secondary indexes\n- For storage structures other than heap, the table is empty and occupies fewer than 18 pages\n\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\n\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\n\n## Column Formats for Copy\n\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\n\nNote: When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\n\n### Character (Text) Formats\n\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\n\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\n\nThe subtle differences between the various character formats are described in Copy Format Details.\n\n### Counted Character Formats\n\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\n\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\n\nNote: Nvarchar(0) is not a counted format.\n\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\n\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\n\n### Dummy Format\n\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\n\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\n\n### Unicode Formats\n\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\n\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\n\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\n\n### Binary Formats",
            "### Binary Formats\n\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\n\nCertainly. I'll convert the provided documentation into a Markdown (.md) file format, maintaining the content while adjusting only the formatting. Here's the result:\n\n### Copy Format Details\n\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\n- Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n- When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n- The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\n\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).",
            "| Format | How Stored (copy into) | How Read (copy from) |\n|--------|------------------------|----------------------|\n| boolean | Written as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format) | Same format as copy into |\n| byte(0) | Same as byte(n) where n is the display length of the corresponding table column. | Read as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. |\n| byte(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded. |\n| byte varying(0) | Same as byte varying(n) where n is the display length of the table column. | Read as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |\n| byte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |\n| C0 | Same as Cn where n is the display length of the corresponding table column | Read as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Any control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\. |\n| Cn | Written as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Any control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\. |\n| char(0) | Same as char(n) where n is the display length of the corresponding table column. | Read as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Unlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is. |\n| char(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding. Unlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Unlike C format, char does not convert control characters or tabs. File data is read as is. |\n| D0 | Instead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.) Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed. | Dummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value. Any \\ found in the input means that the next character is to be taken literally, and is not a delimiter. |\n| Dn | Dummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1. | Dummy field. N characters are read and discarded. Copy from does not allow a delimiter specification with a fixed-length dummy field. |\n| date | Written as a date. (A binary format) | Read as a date. (A binary format) |\n| decimal | Written as a decimal number. (A binary format.) | Read as a decimal number. (A binary format) |\n| float | Written as double\u2011precision floating point. (A binary format) | Read as double\u2011precision floating point. (A binary format) |\n| float4 | Written as single\u2011precision floating point. (A binary format) | Read as single\u2011precision floating point. (A binary format) |\n| integer | Written as integer of 4\u2011byte length. (A binary format) | Read as integer of 4\u2011byte length. (A binary format) |",
            "| integer1 | Written as integer of 1\u2011byte length. (A binary format) | Read as integer of 1\u2011byte length. (A binary format) |\n| long byte(0) | Identical to long varchar | Identical to long varchar |\n| long nvarchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). The maximum segment size for the long nvarchar segment is 32727 bytes. The UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment. If a delimiter is specified, it is written immediately following the last segment. | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| long varchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767. The following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long: 5 abcde10 abcdefghij 0 (with a space after the terminating 0 character) (In this example, the data that is in the originating table column is abcdeabcdefghij) | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| money | Written as a scaled floating point value (a money value). (A binary format) | Read as a scaled floating-point values (a money value). (A binary format) |\n| nchar(0) | Written as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value. | Read as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered. |\n| nvarchar(0) | Same as nchar(0) | Same as nchar(0) |\n| nchar(n) | Written as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| nvarchar(n) | Written as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding. The byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| smallint | Written as an integer of 2\u2011byte length. (A binary format.) | Read as integer of 2\u2011byte length. (A binary format) |\n| text(0) | Written as a variable length string. If a delimiter is specified, it is written after the value. If the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding. Copy into using text(0) format is the way to get variable width output with no padding. | Read as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value |\n| text(n) | Written as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding. | Reads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded. |\n| varchar(0) | Same as varchar(n), where n is the display length of the corresponding table column. | Read as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |",
            "| varchar(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length. | Read as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |",
            "Note: The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\n\nFor user-defined data types (UDTs), use char or varchar.\n\nCertainly. I'll create a single Markdown (.md) file based on the provided documentation, focusing on formatting the content without modifying it. Here's the Markdown version:\n\n### Delimiters in the Data File\n\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\n\n| Delimiter | Description |\n|-----------|-------------|\n| nl | Newline character |\n| tab | Tab character |\n| sp | Space |\n| csv | Comma separated values |\n| ssv | Semicolon separated values |\n| nul or null | Null/zero character |\n| comma | Comma |\n| colon | Colon |\n| dash | Dash |\n| lparen | Left parenthesis |\n| rparen | Right parenthesis |\n| X | Any non-numeric character |\n\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\n\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\n\n## CSV and SSV Delimiters\n\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\n\nThe rules for a CSV-delimited field are:\n\n- The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n- Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\n  ```\n  \"There is a double quote \"\" here\"\n  ```\n\n  is translated to the table value:\n\n  ```\n  There is a double quote \" here\n  ```\n\n  Whitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\n- Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\n\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\n\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \"counted\" formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)\n\nCopy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\n\n## With Null Clause for Copy\n\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\n\n### With Null (value) Clause\n\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\n\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.",
            "To prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\n\nFor example, this example of a value is incorrect:\n\n```\nc0comma with null(0)\n```\n\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\n\n```\nc0comma with null('0')\n```\n\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\n\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\n\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\n\n```sql\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\n```\n\nThe correct version specifies a 4-character format for the column.\n\n```sql\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\n```\n\n### With Null Clause Omitting Value\n\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\n\n## Filename Specification for Copy\n\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\n\nUNIX: For copy into, if the file already exists, copy overwrites it.\n\n## Windows File Types for Copy\n\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\n\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\n\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\n\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\n\nThe binary-copy forms (copy () from or copy () into) use binary mode.\n\nNote: Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.\n\nCopy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\n\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\n\n## With Clause for Copy\n\nValid with clause options for the copy statement are as follows:\n\n### On_error=TERMINATE|CONTINUE\n\nDirects copy to continue after encountering conversion errors.\n\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\n\nBy default, copy terminates when an error occurs while converting between table format and file format\n\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\n\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\n\n### Error_count=n\n\nSpecifies how many errors can occur before processing terminates.\n\nDefault: 1.\n\nIf on_error is set to continue, setting error_count has no effect.",
            "Default: 1.\n\nIf on_error is set to continue, setting error_count has no effect.\n\n### Log='filename'\n\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\n\nLogging works as follows:\n\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\n\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\n\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\n\n### Rollback=ENABLED|DISABLED\n\nEnables or disables rollback, as follows:\n\n- ENABLED: Directs the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\n- DISABLED: Retains the appended rows.\n\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\n\nDefault: ENABLED\n\nWhen copying to a file, the with rollback clause has no effect.\n\n### Row_estimate\n\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\n\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\n\n## Permissions\n\nTo use the copy statement, one of the following must apply:\n\n- You own the table.\n- The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n- You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\n\n## Locking\n\n- When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n- When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n- When performing a non-bulk copy into a table, the DBMS server takes an \"intent exclusive\" lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\n\n## Restrictions and Considerations\n\n- Copy cannot be used to add data to a view, index, or system catalog.\n- When copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\n- When copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\n- The copy statement does not fire any rules defined against the table.\n- Values cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\n- Copy treats a present-but-empty field in the data file as:\n  - A blank default for character-based columns\n  - A zero default for numeric columns\n  - December 31 00-1 for date and timestamp columns\n  - 00:00:00 for time columns (and the time component in a timestamp)",
            "For example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\n\n## Related Statements\n\n- Create Table Statement\n- Modify Statement\n\n## Examples--Copy Statement\n\nThe following examples illustrate the correct use of the copy statement:\n\n1. In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\n\n   ```\n   ename     char(15)\n   age       integer4\n   dept      char(10)\n   comment   varchar(20)\n   ```\n\n   The emp.txt file contains the following data:\n\n   ```\n   Jones,J. 32 Anytown,USA toy,00017A This is a comment\n   Smith,P. 41 New York,NY admin,00015 Another comment\n   ```\n\n   The following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\n   - A dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\n   - The department field is delimited by a comma.\n   - The comment field is a variable-length varchar field, preceded by a five-character length specifier.\n\n2. Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\n\n   ```sql\n   copy table employee (eno=integer2, ename=char(10),\n       age=integer2, job=integer2, sal=float4,\n       dept=integer2, xxx=d1)\n       from 'myfile.in';\n   ```\n\n3. Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\n\n   ```sql\n   copy table employee (ename=char(0)comma,\n       eno=char(0)comma, sal= char(0)nl)\n       into 'mfile.out';\n   ```\n\n   Joe Smith , 101, $25000.00\n   \n   Shirley Scott , 102, $30000.00\n\n4. The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\n\n   ```sql\n   copy table employee (ename = text(0)csv,\n       eno = text(0)csv, sal = text(0)csv)\n       into 'mfile.out';\n   ```\n    \n   Joe Smith,101,$25000.00\n   Shirley Scott,102,$30000.00\n\n5. Bulk copy the employee table into a file. The resulting data file contains binary data.\n\n   ```sql\n   copy table employee () into 'ourfile.dat';\n   ```\n\n6. Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\n\n   ```sql\n   copy table other_employee_table () from 'ourfile.dat';\n   ```\n\n7. Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\n\n   ```sql\n   copy table acct_recv\n       (acct_name=char(0)'%',\n       address='d0%',\n       credit=char(0)'%' with null('xx'),\n       debit=char(0)'%' with null('xx'),\n       acct_mngr=char(15),\n       xx=d0nl)\n       into 'qtr_result';\n   ```\n\n   Smith Corp%% $12345.00% $-67890.00%Jones\n   ABC Oil %% $54321.00% $-98765.00%Green\n   Spring Omc%%xx %xx %Namroc\n\n8. Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\n\n   ```sql\n   copy table gifts\n       (item_name=char(0)tab,\n       date_recd=char(0)tab,\n       sender=char(20)nl with null('anonymous'))\n       into 'giftdata';\n   ```\n\n   toaster 04-mar-1993 Nicholas\n   sled 10-oct-1993 anonymous\n   rocket 01-dec-1993 Francisco\n\n9. Create a table and load it using bulk copy, specifying structural options.\n\n   ```sql\n   create table mytable (name char 25, ...);\n   \n   modify mytable to hash;\n   \n   copy mytable() from 'myfile' with minpages = 16384,\n   maxpages = 16384, allocation = 16384;\n   ```"
        ]
    },
    {
        "instruction": "What are the requirements for performing a bulk copy operation in Actian 4GL SQL COPY statements?",
        "input": "",
        "output": "To perform a bulk copy in Actian 4GL SQL COPY statements, you must meet these requirements:\n\n- The table is not journaled\n- The table has no secondary indexes\n- For storage structures other than heap, the table is empty and occupies fewer than 18 pages\n\nIf all these conditions are met, data will be loaded using bulk copy, improving performance. Otherwise, data loading will proceed using a less rapid technique.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "# Copy Statement\n\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\n\nThis statement has the following syntax:\n\n```sql\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\n```\n\n## Parameters--Copy Statement\n\nThis statement has the following parameters:\n\n- **table_name**: Specifies an existing table from which data is read or to which data is written.\n- **column_name**: Specifies the column from which data is read or to which data is written.\n- **format**: Specifies the format in which a value is stored in the file.\n- **filename**: Specifies the file from which data is read or to which data is written.\n- **type**: (Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\n\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\n\n- **with_clause**: Consists of the word with, followed by a comma-separated list of one or more of the following items:\n  - on_error = TERMINATE | CONTINUE\n  - error_count = n\n  - rollback = ENABLED | DISABLED\n  - log = 'filename'\n\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\n- allocation = n\n- extend = n\n- fillfactor = n (ISAM, Hash, and Btree only)\n- minpages = n (Hash only)\n- maxpages = n (Hash only)\n- leaffill = n (Btree only)\n- nonleaffill = n (Btree only)\n- row_estimate = n\n\n## Unformatted Copying\n\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\n\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\n\n```sql\ncopy table employee () into 'emp_name';\n```\n\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\n\nNote: An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\n\n## Formatted Copying\n\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\n\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\n\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\n\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\n\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).",
            "The values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.\n\nNote: If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\n\n```sql\ncopy table t (col1=c20, col2=c30, d0=nl) into 't.out':\n```\n\n## Bulk Copying\n\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\n\nThe requirements for performing a bulk copy are:\n\n- The table is not journaled\n- The table has no secondary indexes\n- For storage structures other than heap, the table is empty and occupies fewer than 18 pages\n\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\n\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\n\n## Column Formats for Copy\n\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\n\nNote: When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\n\n### Character (Text) Formats\n\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\n\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\n\nThe subtle differences between the various character formats are described in Copy Format Details.\n\n### Counted Character Formats\n\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\n\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\n\nNote: Nvarchar(0) is not a counted format.\n\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\n\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\n\n### Dummy Format\n\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\n\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\n\n### Unicode Formats\n\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\n\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\n\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\n\n### Binary Formats",
            "### Binary Formats\n\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\n\nCertainly. I'll convert the provided documentation into a Markdown (.md) file format, maintaining the content while adjusting only the formatting. Here's the result:\n\n### Copy Format Details\n\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\n- Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n- When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n- The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\n\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).",
            "| Format | How Stored (copy into) | How Read (copy from) |\n|--------|------------------------|----------------------|\n| boolean | Written as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format) | Same format as copy into |\n| byte(0) | Same as byte(n) where n is the display length of the corresponding table column. | Read as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. |\n| byte(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded. |\n| byte varying(0) | Same as byte varying(n) where n is the display length of the table column. | Read as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |\n| byte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |\n| C0 | Same as Cn where n is the display length of the corresponding table column | Read as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Any control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\. |\n| Cn | Written as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Any control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\. |\n| char(0) | Same as char(n) where n is the display length of the corresponding table column. | Read as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Unlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is. |\n| char(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding. Unlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Unlike C format, char does not convert control characters or tabs. File data is read as is. |\n| D0 | Instead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.) Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed. | Dummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value. Any \\ found in the input means that the next character is to be taken literally, and is not a delimiter. |\n| Dn | Dummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1. | Dummy field. N characters are read and discarded. Copy from does not allow a delimiter specification with a fixed-length dummy field. |\n| date | Written as a date. (A binary format) | Read as a date. (A binary format) |\n| decimal | Written as a decimal number. (A binary format.) | Read as a decimal number. (A binary format) |\n| float | Written as double\u2011precision floating point. (A binary format) | Read as double\u2011precision floating point. (A binary format) |\n| float4 | Written as single\u2011precision floating point. (A binary format) | Read as single\u2011precision floating point. (A binary format) |\n| integer | Written as integer of 4\u2011byte length. (A binary format) | Read as integer of 4\u2011byte length. (A binary format) |",
            "| integer1 | Written as integer of 1\u2011byte length. (A binary format) | Read as integer of 1\u2011byte length. (A binary format) |\n| long byte(0) | Identical to long varchar | Identical to long varchar |\n| long nvarchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). The maximum segment size for the long nvarchar segment is 32727 bytes. The UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment. If a delimiter is specified, it is written immediately following the last segment. | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| long varchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767. The following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long: 5 abcde10 abcdefghij 0 (with a space after the terminating 0 character) (In this example, the data that is in the originating table column is abcdeabcdefghij) | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| money | Written as a scaled floating point value (a money value). (A binary format) | Read as a scaled floating-point values (a money value). (A binary format) |\n| nchar(0) | Written as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value. | Read as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered. |\n| nvarchar(0) | Same as nchar(0) | Same as nchar(0) |\n| nchar(n) | Written as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| nvarchar(n) | Written as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding. The byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| smallint | Written as an integer of 2\u2011byte length. (A binary format.) | Read as integer of 2\u2011byte length. (A binary format) |\n| text(0) | Written as a variable length string. If a delimiter is specified, it is written after the value. If the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding. Copy into using text(0) format is the way to get variable width output with no padding. | Read as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value |\n| text(n) | Written as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding. | Reads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded. |\n| varchar(0) | Same as varchar(n), where n is the display length of the corresponding table column. | Read as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |",
            "| varchar(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length. | Read as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |",
            "Note: The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\n\nFor user-defined data types (UDTs), use char or varchar.\n\nCertainly. I'll create a single Markdown (.md) file based on the provided documentation, focusing on formatting the content without modifying it. Here's the Markdown version:\n\n### Delimiters in the Data File\n\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\n\n| Delimiter | Description |\n|-----------|-------------|\n| nl | Newline character |\n| tab | Tab character |\n| sp | Space |\n| csv | Comma separated values |\n| ssv | Semicolon separated values |\n| nul or null | Null/zero character |\n| comma | Comma |\n| colon | Colon |\n| dash | Dash |\n| lparen | Left parenthesis |\n| rparen | Right parenthesis |\n| X | Any non-numeric character |\n\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\n\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\n\n## CSV and SSV Delimiters\n\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\n\nThe rules for a CSV-delimited field are:\n\n- The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n- Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\n  ```\n  \"There is a double quote \"\" here\"\n  ```\n\n  is translated to the table value:\n\n  ```\n  There is a double quote \" here\n  ```\n\n  Whitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\n- Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\n\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\n\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \"counted\" formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)\n\nCopy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\n\n## With Null Clause for Copy\n\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\n\n### With Null (value) Clause\n\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\n\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.",
            "To prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\n\nFor example, this example of a value is incorrect:\n\n```\nc0comma with null(0)\n```\n\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\n\n```\nc0comma with null('0')\n```\n\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\n\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\n\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\n\n```sql\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\n```\n\nThe correct version specifies a 4-character format for the column.\n\n```sql\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\n```\n\n### With Null Clause Omitting Value\n\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\n\n## Filename Specification for Copy\n\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\n\nUNIX: For copy into, if the file already exists, copy overwrites it.\n\n## Windows File Types for Copy\n\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\n\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\n\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\n\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\n\nThe binary-copy forms (copy () from or copy () into) use binary mode.\n\nNote: Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.\n\nCopy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\n\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\n\n## With Clause for Copy\n\nValid with clause options for the copy statement are as follows:\n\n### On_error=TERMINATE|CONTINUE\n\nDirects copy to continue after encountering conversion errors.\n\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\n\nBy default, copy terminates when an error occurs while converting between table format and file format\n\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\n\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\n\n### Error_count=n\n\nSpecifies how many errors can occur before processing terminates.\n\nDefault: 1.\n\nIf on_error is set to continue, setting error_count has no effect.",
            "Default: 1.\n\nIf on_error is set to continue, setting error_count has no effect.\n\n### Log='filename'\n\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\n\nLogging works as follows:\n\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\n\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\n\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\n\n### Rollback=ENABLED|DISABLED\n\nEnables or disables rollback, as follows:\n\n- ENABLED: Directs the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\n- DISABLED: Retains the appended rows.\n\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\n\nDefault: ENABLED\n\nWhen copying to a file, the with rollback clause has no effect.\n\n### Row_estimate\n\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\n\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\n\n## Permissions\n\nTo use the copy statement, one of the following must apply:\n\n- You own the table.\n- The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n- You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\n\n## Locking\n\n- When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n- When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n- When performing a non-bulk copy into a table, the DBMS server takes an \"intent exclusive\" lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\n\n## Restrictions and Considerations\n\n- Copy cannot be used to add data to a view, index, or system catalog.\n- When copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\n- When copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\n- The copy statement does not fire any rules defined against the table.\n- Values cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\n- Copy treats a present-but-empty field in the data file as:\n  - A blank default for character-based columns\n  - A zero default for numeric columns\n  - December 31 00-1 for date and timestamp columns\n  - 00:00:00 for time columns (and the time component in a timestamp)",
            "For example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\n\n## Related Statements\n\n- Create Table Statement\n- Modify Statement\n\n## Examples--Copy Statement\n\nThe following examples illustrate the correct use of the copy statement:\n\n1. In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\n\n   ```\n   ename     char(15)\n   age       integer4\n   dept      char(10)\n   comment   varchar(20)\n   ```\n\n   The emp.txt file contains the following data:\n\n   ```\n   Jones,J. 32 Anytown,USA toy,00017A This is a comment\n   Smith,P. 41 New York,NY admin,00015 Another comment\n   ```\n\n   The following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\n   - A dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\n   - The department field is delimited by a comma.\n   - The comment field is a variable-length varchar field, preceded by a five-character length specifier.\n\n2. Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\n\n   ```sql\n   copy table employee (eno=integer2, ename=char(10),\n       age=integer2, job=integer2, sal=float4,\n       dept=integer2, xxx=d1)\n       from 'myfile.in';\n   ```\n\n3. Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\n\n   ```sql\n   copy table employee (ename=char(0)comma,\n       eno=char(0)comma, sal= char(0)nl)\n       into 'mfile.out';\n   ```\n\n   Joe Smith , 101, $25000.00\n   \n   Shirley Scott , 102, $30000.00\n\n4. The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\n\n   ```sql\n   copy table employee (ename = text(0)csv,\n       eno = text(0)csv, sal = text(0)csv)\n       into 'mfile.out';\n   ```\n    \n   Joe Smith,101,$25000.00\n   Shirley Scott,102,$30000.00\n\n5. Bulk copy the employee table into a file. The resulting data file contains binary data.\n\n   ```sql\n   copy table employee () into 'ourfile.dat';\n   ```\n\n6. Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\n\n   ```sql\n   copy table other_employee_table () from 'ourfile.dat';\n   ```\n\n7. Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\n\n   ```sql\n   copy table acct_recv\n       (acct_name=char(0)'%',\n       address='d0%',\n       credit=char(0)'%' with null('xx'),\n       debit=char(0)'%' with null('xx'),\n       acct_mngr=char(15),\n       xx=d0nl)\n       into 'qtr_result';\n   ```\n\n   Smith Corp%% $12345.00% $-67890.00%Jones\n   ABC Oil %% $54321.00% $-98765.00%Green\n   Spring Omc%%xx %xx %Namroc\n\n8. Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\n\n   ```sql\n   copy table gifts\n       (item_name=char(0)tab,\n       date_recd=char(0)tab,\n       sender=char(20)nl with null('anonymous'))\n       into 'giftdata';\n   ```\n\n   toaster 04-mar-1993 Nicholas\n   sled 10-oct-1993 anonymous\n   rocket 01-dec-1993 Francisco\n\n9. Create a table and load it using bulk copy, specifying structural options.\n\n   ```sql\n   create table mytable (name char 25, ...);\n   \n   modify mytable to hash;\n   \n   copy mytable() from 'myfile' with minpages = 16384,\n   maxpages = 16384, allocation = 16384;\n   ```"
        ]
    },
    {
        "instruction": "What is the purpose of specifying a `format` parameter in Actian 4GL SQL COPY statements?",
        "input": "",
        "output": "The `format` parameter in Actian 4GL SQL COPY statements is used to define the format of data stored in an external file, ensuring proper conversion and import or export operations. The specified format helps the system understand how to interpret and handle data when reading from or writing to files.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "# Copy Statement\n\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\n\nThis statement has the following syntax:\n\n```sql\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\n```\n\n## Parameters--Copy Statement\n\nThis statement has the following parameters:\n\n- **table_name**: Specifies an existing table from which data is read or to which data is written.\n- **column_name**: Specifies the column from which data is read or to which data is written.\n- **format**: Specifies the format in which a value is stored in the file.\n- **filename**: Specifies the file from which data is read or to which data is written.\n- **type**: (Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\n\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\n\n- **with_clause**: Consists of the word with, followed by a comma-separated list of one or more of the following items:\n  - on_error = TERMINATE | CONTINUE\n  - error_count = n\n  - rollback = ENABLED | DISABLED\n  - log = 'filename'\n\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\n- allocation = n\n- extend = n\n- fillfactor = n (ISAM, Hash, and Btree only)\n- minpages = n (Hash only)\n- maxpages = n (Hash only)\n- leaffill = n (Btree only)\n- nonleaffill = n (Btree only)\n- row_estimate = n\n\n## Unformatted Copying\n\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\n\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\n\n```sql\ncopy table employee () into 'emp_name';\n```\n\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\n\nNote: An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\n\n## Formatted Copying\n\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\n\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\n\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\n\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\n\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).",
            "The values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.\n\nNote: If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\n\n```sql\ncopy table t (col1=c20, col2=c30, d0=nl) into 't.out':\n```\n\n## Bulk Copying\n\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\n\nThe requirements for performing a bulk copy are:\n\n- The table is not journaled\n- The table has no secondary indexes\n- For storage structures other than heap, the table is empty and occupies fewer than 18 pages\n\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\n\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\n\n## Column Formats for Copy\n\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\n\nNote: When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\n\n### Character (Text) Formats\n\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\n\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\n\nThe subtle differences between the various character formats are described in Copy Format Details.\n\n### Counted Character Formats\n\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\n\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\n\nNote: Nvarchar(0) is not a counted format.\n\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\n\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\n\n### Dummy Format\n\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\n\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\n\n### Unicode Formats\n\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\n\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\n\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\n\n### Binary Formats",
            "### Binary Formats\n\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\n\nCertainly. I'll convert the provided documentation into a Markdown (.md) file format, maintaining the content while adjusting only the formatting. Here's the result:\n\n### Copy Format Details\n\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\n- Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n- When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n- The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\n\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).",
            "| Format | How Stored (copy into) | How Read (copy from) |\n|--------|------------------------|----------------------|\n| boolean | Written as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format) | Same format as copy into |\n| byte(0) | Same as byte(n) where n is the display length of the corresponding table column. | Read as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. |\n| byte(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded. |\n| byte varying(0) | Same as byte varying(n) where n is the display length of the table column. | Read as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |\n| byte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |\n| C0 | Same as Cn where n is the display length of the corresponding table column | Read as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Any control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\. |\n| Cn | Written as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Any control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\. |\n| char(0) | Same as char(n) where n is the display length of the corresponding table column. | Read as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Unlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is. |\n| char(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding. Unlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Unlike C format, char does not convert control characters or tabs. File data is read as is. |\n| D0 | Instead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.) Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed. | Dummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value. Any \\ found in the input means that the next character is to be taken literally, and is not a delimiter. |\n| Dn | Dummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1. | Dummy field. N characters are read and discarded. Copy from does not allow a delimiter specification with a fixed-length dummy field. |\n| date | Written as a date. (A binary format) | Read as a date. (A binary format) |\n| decimal | Written as a decimal number. (A binary format.) | Read as a decimal number. (A binary format) |\n| float | Written as double\u2011precision floating point. (A binary format) | Read as double\u2011precision floating point. (A binary format) |\n| float4 | Written as single\u2011precision floating point. (A binary format) | Read as single\u2011precision floating point. (A binary format) |\n| integer | Written as integer of 4\u2011byte length. (A binary format) | Read as integer of 4\u2011byte length. (A binary format) |",
            "| integer1 | Written as integer of 1\u2011byte length. (A binary format) | Read as integer of 1\u2011byte length. (A binary format) |\n| long byte(0) | Identical to long varchar | Identical to long varchar |\n| long nvarchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). The maximum segment size for the long nvarchar segment is 32727 bytes. The UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment. If a delimiter is specified, it is written immediately following the last segment. | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| long varchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767. The following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long: 5 abcde10 abcdefghij 0 (with a space after the terminating 0 character) (In this example, the data that is in the originating table column is abcdeabcdefghij) | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| money | Written as a scaled floating point value (a money value). (A binary format) | Read as a scaled floating-point values (a money value). (A binary format) |\n| nchar(0) | Written as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value. | Read as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered. |\n| nvarchar(0) | Same as nchar(0) | Same as nchar(0) |\n| nchar(n) | Written as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| nvarchar(n) | Written as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding. The byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| smallint | Written as an integer of 2\u2011byte length. (A binary format.) | Read as integer of 2\u2011byte length. (A binary format) |\n| text(0) | Written as a variable length string. If a delimiter is specified, it is written after the value. If the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding. Copy into using text(0) format is the way to get variable width output with no padding. | Read as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value |\n| text(n) | Written as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding. | Reads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded. |\n| varchar(0) | Same as varchar(n), where n is the display length of the corresponding table column. | Read as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |",
            "| varchar(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length. | Read as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |",
            "Note: The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\n\nFor user-defined data types (UDTs), use char or varchar.\n\nCertainly. I'll create a single Markdown (.md) file based on the provided documentation, focusing on formatting the content without modifying it. Here's the Markdown version:\n\n### Delimiters in the Data File\n\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\n\n| Delimiter | Description |\n|-----------|-------------|\n| nl | Newline character |\n| tab | Tab character |\n| sp | Space |\n| csv | Comma separated values |\n| ssv | Semicolon separated values |\n| nul or null | Null/zero character |\n| comma | Comma |\n| colon | Colon |\n| dash | Dash |\n| lparen | Left parenthesis |\n| rparen | Right parenthesis |\n| X | Any non-numeric character |\n\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\n\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\n\n## CSV and SSV Delimiters\n\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\n\nThe rules for a CSV-delimited field are:\n\n- The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n- Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\n  ```\n  \"There is a double quote \"\" here\"\n  ```\n\n  is translated to the table value:\n\n  ```\n  There is a double quote \" here\n  ```\n\n  Whitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\n- Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\n\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\n\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \"counted\" formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)\n\nCopy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\n\n## With Null Clause for Copy\n\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\n\n### With Null (value) Clause\n\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\n\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.",
            "To prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\n\nFor example, this example of a value is incorrect:\n\n```\nc0comma with null(0)\n```\n\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\n\n```\nc0comma with null('0')\n```\n\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\n\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\n\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\n\n```sql\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\n```\n\nThe correct version specifies a 4-character format for the column.\n\n```sql\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\n```\n\n### With Null Clause Omitting Value\n\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\n\n## Filename Specification for Copy\n\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\n\nUNIX: For copy into, if the file already exists, copy overwrites it.\n\n## Windows File Types for Copy\n\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\n\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\n\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\n\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\n\nThe binary-copy forms (copy () from or copy () into) use binary mode.\n\nNote: Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.\n\nCopy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\n\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\n\n## With Clause for Copy\n\nValid with clause options for the copy statement are as follows:\n\n### On_error=TERMINATE|CONTINUE\n\nDirects copy to continue after encountering conversion errors.\n\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\n\nBy default, copy terminates when an error occurs while converting between table format and file format\n\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\n\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\n\n### Error_count=n\n\nSpecifies how many errors can occur before processing terminates.\n\nDefault: 1.\n\nIf on_error is set to continue, setting error_count has no effect.",
            "Default: 1.\n\nIf on_error is set to continue, setting error_count has no effect.\n\n### Log='filename'\n\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\n\nLogging works as follows:\n\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\n\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\n\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\n\n### Rollback=ENABLED|DISABLED\n\nEnables or disables rollback, as follows:\n\n- ENABLED: Directs the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\n- DISABLED: Retains the appended rows.\n\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\n\nDefault: ENABLED\n\nWhen copying to a file, the with rollback clause has no effect.\n\n### Row_estimate\n\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\n\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\n\n## Permissions\n\nTo use the copy statement, one of the following must apply:\n\n- You own the table.\n- The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n- You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\n\n## Locking\n\n- When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n- When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n- When performing a non-bulk copy into a table, the DBMS server takes an \"intent exclusive\" lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\n\n## Restrictions and Considerations\n\n- Copy cannot be used to add data to a view, index, or system catalog.\n- When copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\n- When copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\n- The copy statement does not fire any rules defined against the table.\n- Values cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\n- Copy treats a present-but-empty field in the data file as:\n  - A blank default for character-based columns\n  - A zero default for numeric columns\n  - December 31 00-1 for date and timestamp columns\n  - 00:00:00 for time columns (and the time component in a timestamp)",
            "For example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\n\n## Related Statements\n\n- Create Table Statement\n- Modify Statement\n\n## Examples--Copy Statement\n\nThe following examples illustrate the correct use of the copy statement:\n\n1. In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\n\n   ```\n   ename     char(15)\n   age       integer4\n   dept      char(10)\n   comment   varchar(20)\n   ```\n\n   The emp.txt file contains the following data:\n\n   ```\n   Jones,J. 32 Anytown,USA toy,00017A This is a comment\n   Smith,P. 41 New York,NY admin,00015 Another comment\n   ```\n\n   The following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\n   - A dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\n   - The department field is delimited by a comma.\n   - The comment field is a variable-length varchar field, preceded by a five-character length specifier.\n\n2. Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\n\n   ```sql\n   copy table employee (eno=integer2, ename=char(10),\n       age=integer2, job=integer2, sal=float4,\n       dept=integer2, xxx=d1)\n       from 'myfile.in';\n   ```\n\n3. Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\n\n   ```sql\n   copy table employee (ename=char(0)comma,\n       eno=char(0)comma, sal= char(0)nl)\n       into 'mfile.out';\n   ```\n\n   Joe Smith , 101, $25000.00\n   \n   Shirley Scott , 102, $30000.00\n\n4. The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\n\n   ```sql\n   copy table employee (ename = text(0)csv,\n       eno = text(0)csv, sal = text(0)csv)\n       into 'mfile.out';\n   ```\n    \n   Joe Smith,101,$25000.00\n   Shirley Scott,102,$30000.00\n\n5. Bulk copy the employee table into a file. The resulting data file contains binary data.\n\n   ```sql\n   copy table employee () into 'ourfile.dat';\n   ```\n\n6. Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\n\n   ```sql\n   copy table other_employee_table () from 'ourfile.dat';\n   ```\n\n7. Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\n\n   ```sql\n   copy table acct_recv\n       (acct_name=char(0)'%',\n       address='d0%',\n       credit=char(0)'%' with null('xx'),\n       debit=char(0)'%' with null('xx'),\n       acct_mngr=char(15),\n       xx=d0nl)\n       into 'qtr_result';\n   ```\n\n   Smith Corp%% $12345.00% $-67890.00%Jones\n   ABC Oil %% $54321.00% $-98765.00%Green\n   Spring Omc%%xx %xx %Namroc\n\n8. Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\n\n   ```sql\n   copy table gifts\n       (item_name=char(0)tab,\n       date_recd=char(0)tab,\n       sender=char(20)nl with null('anonymous'))\n       into 'giftdata';\n   ```\n\n   toaster 04-mar-1993 Nicholas\n   sled 10-oct-1993 anonymous\n   rocket 01-dec-1993 Francisco\n\n9. Create a table and load it using bulk copy, specifying structural options.\n\n   ```sql\n   create table mytable (name char 25, ...);\n   \n   modify mytable to hash;\n   \n   copy mytable() from 'myfile' with minpages = 16384,\n   maxpages = 16384, allocation = 16384;\n   ```"
        ]
    },
    {
        "instruction": "Explain the usage of `d1` in Actian 4GL SQL COPY statements with an example.",
        "input": "",
        "output": "In Actian 4GL, the `d1` is a dummy column used during data import processes when there's no matching column for some data fields in the source file but there still needs to be a column to read all records without errors. An example of its usage can be seen in the second example provided in the document:\n```sql\ncopy table employee (eno=integer2, ename=char(10),\nage=integer2, dept=char(10) , xxx=d1 )\n    from 'myfile.in';\n```\nIn this case, the `d1` column is added as a placeholder for the missing \"city\" field in the source file, allowing the import of the rest of data into the employee table successfully.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "# Copy Statement\n\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\n\nThis statement has the following syntax:\n\n```sql\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\n```\n\n## Parameters--Copy Statement\n\nThis statement has the following parameters:\n\n- **table_name**: Specifies an existing table from which data is read or to which data is written.\n- **column_name**: Specifies the column from which data is read or to which data is written.\n- **format**: Specifies the format in which a value is stored in the file.\n- **filename**: Specifies the file from which data is read or to which data is written.\n- **type**: (Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\n\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\n\n- **with_clause**: Consists of the word with, followed by a comma-separated list of one or more of the following items:\n  - on_error = TERMINATE | CONTINUE\n  - error_count = n\n  - rollback = ENABLED | DISABLED\n  - log = 'filename'\n\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\n- allocation = n\n- extend = n\n- fillfactor = n (ISAM, Hash, and Btree only)\n- minpages = n (Hash only)\n- maxpages = n (Hash only)\n- leaffill = n (Btree only)\n- nonleaffill = n (Btree only)\n- row_estimate = n\n\n## Unformatted Copying\n\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\n\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\n\n```sql\ncopy table employee () into 'emp_name';\n```\n\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\n\nNote: An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\n\n## Formatted Copying\n\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\n\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\n\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\n\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\n\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).",
            "The values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.\n\nNote: If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\n\n```sql\ncopy table t (col1=c20, col2=c30, d0=nl) into 't.out':\n```\n\n## Bulk Copying\n\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\n\nThe requirements for performing a bulk copy are:\n\n- The table is not journaled\n- The table has no secondary indexes\n- For storage structures other than heap, the table is empty and occupies fewer than 18 pages\n\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\n\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\n\n## Column Formats for Copy\n\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\n\nNote: When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\n\n### Character (Text) Formats\n\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\n\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\n\nThe subtle differences between the various character formats are described in Copy Format Details.\n\n### Counted Character Formats\n\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\n\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\n\nNote: Nvarchar(0) is not a counted format.\n\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\n\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\n\n### Dummy Format\n\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\n\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\n\n### Unicode Formats\n\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\n\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\n\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\n\n### Binary Formats",
            "### Binary Formats\n\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\n\nCertainly. I'll convert the provided documentation into a Markdown (.md) file format, maintaining the content while adjusting only the formatting. Here's the result:\n\n### Copy Format Details\n\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\n- Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n- When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n- The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\n\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).",
            "| Format | How Stored (copy into) | How Read (copy from) |\n|--------|------------------------|----------------------|\n| boolean | Written as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format) | Same format as copy into |\n| byte(0) | Same as byte(n) where n is the display length of the corresponding table column. | Read as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. |\n| byte(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded. |\n| byte varying(0) | Same as byte varying(n) where n is the display length of the table column. | Read as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |\n| byte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |\n| C0 | Same as Cn where n is the display length of the corresponding table column | Read as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Any control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\. |\n| Cn | Written as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Any control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\. |\n| char(0) | Same as char(n) where n is the display length of the corresponding table column. | Read as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Unlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is. |\n| char(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding. Unlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Unlike C format, char does not convert control characters or tabs. File data is read as is. |\n| D0 | Instead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.) Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed. | Dummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value. Any \\ found in the input means that the next character is to be taken literally, and is not a delimiter. |\n| Dn | Dummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1. | Dummy field. N characters are read and discarded. Copy from does not allow a delimiter specification with a fixed-length dummy field. |\n| date | Written as a date. (A binary format) | Read as a date. (A binary format) |\n| decimal | Written as a decimal number. (A binary format.) | Read as a decimal number. (A binary format) |\n| float | Written as double\u2011precision floating point. (A binary format) | Read as double\u2011precision floating point. (A binary format) |\n| float4 | Written as single\u2011precision floating point. (A binary format) | Read as single\u2011precision floating point. (A binary format) |\n| integer | Written as integer of 4\u2011byte length. (A binary format) | Read as integer of 4\u2011byte length. (A binary format) |",
            "| integer1 | Written as integer of 1\u2011byte length. (A binary format) | Read as integer of 1\u2011byte length. (A binary format) |\n| long byte(0) | Identical to long varchar | Identical to long varchar |\n| long nvarchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). The maximum segment size for the long nvarchar segment is 32727 bytes. The UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment. If a delimiter is specified, it is written immediately following the last segment. | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| long varchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767. The following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long: 5 abcde10 abcdefghij 0 (with a space after the terminating 0 character) (In this example, the data that is in the originating table column is abcdeabcdefghij) | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| money | Written as a scaled floating point value (a money value). (A binary format) | Read as a scaled floating-point values (a money value). (A binary format) |\n| nchar(0) | Written as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value. | Read as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered. |\n| nvarchar(0) | Same as nchar(0) | Same as nchar(0) |\n| nchar(n) | Written as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| nvarchar(n) | Written as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding. The byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| smallint | Written as an integer of 2\u2011byte length. (A binary format.) | Read as integer of 2\u2011byte length. (A binary format) |\n| text(0) | Written as a variable length string. If a delimiter is specified, it is written after the value. If the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding. Copy into using text(0) format is the way to get variable width output with no padding. | Read as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value |\n| text(n) | Written as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding. | Reads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded. |\n| varchar(0) | Same as varchar(n), where n is the display length of the corresponding table column. | Read as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |",
            "| varchar(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length. | Read as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |",
            "Note: The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\n\nFor user-defined data types (UDTs), use char or varchar.\n\nCertainly. I'll create a single Markdown (.md) file based on the provided documentation, focusing on formatting the content without modifying it. Here's the Markdown version:\n\n### Delimiters in the Data File\n\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\n\n| Delimiter | Description |\n|-----------|-------------|\n| nl | Newline character |\n| tab | Tab character |\n| sp | Space |\n| csv | Comma separated values |\n| ssv | Semicolon separated values |\n| nul or null | Null/zero character |\n| comma | Comma |\n| colon | Colon |\n| dash | Dash |\n| lparen | Left parenthesis |\n| rparen | Right parenthesis |\n| X | Any non-numeric character |\n\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\n\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\n\n## CSV and SSV Delimiters\n\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\n\nThe rules for a CSV-delimited field are:\n\n- The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n- Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\n  ```\n  \"There is a double quote \"\" here\"\n  ```\n\n  is translated to the table value:\n\n  ```\n  There is a double quote \" here\n  ```\n\n  Whitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\n- Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\n\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\n\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \"counted\" formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)\n\nCopy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\n\n## With Null Clause for Copy\n\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\n\n### With Null (value) Clause\n\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\n\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.",
            "To prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\n\nFor example, this example of a value is incorrect:\n\n```\nc0comma with null(0)\n```\n\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\n\n```\nc0comma with null('0')\n```\n\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\n\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\n\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\n\n```sql\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\n```\n\nThe correct version specifies a 4-character format for the column.\n\n```sql\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\n```\n\n### With Null Clause Omitting Value\n\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\n\n## Filename Specification for Copy\n\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\n\nUNIX: For copy into, if the file already exists, copy overwrites it.\n\n## Windows File Types for Copy\n\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\n\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\n\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\n\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\n\nThe binary-copy forms (copy () from or copy () into) use binary mode.\n\nNote: Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.\n\nCopy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\n\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\n\n## With Clause for Copy\n\nValid with clause options for the copy statement are as follows:\n\n### On_error=TERMINATE|CONTINUE\n\nDirects copy to continue after encountering conversion errors.\n\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\n\nBy default, copy terminates when an error occurs while converting between table format and file format\n\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\n\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\n\n### Error_count=n\n\nSpecifies how many errors can occur before processing terminates.\n\nDefault: 1.\n\nIf on_error is set to continue, setting error_count has no effect.",
            "Default: 1.\n\nIf on_error is set to continue, setting error_count has no effect.\n\n### Log='filename'\n\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\n\nLogging works as follows:\n\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\n\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\n\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\n\n### Rollback=ENABLED|DISABLED\n\nEnables or disables rollback, as follows:\n\n- ENABLED: Directs the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\n- DISABLED: Retains the appended rows.\n\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\n\nDefault: ENABLED\n\nWhen copying to a file, the with rollback clause has no effect.\n\n### Row_estimate\n\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\n\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\n\n## Permissions\n\nTo use the copy statement, one of the following must apply:\n\n- You own the table.\n- The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n- You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\n\n## Locking\n\n- When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n- When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n- When performing a non-bulk copy into a table, the DBMS server takes an \"intent exclusive\" lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\n\n## Restrictions and Considerations\n\n- Copy cannot be used to add data to a view, index, or system catalog.\n- When copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\n- When copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\n- The copy statement does not fire any rules defined against the table.\n- Values cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\n- Copy treats a present-but-empty field in the data file as:\n  - A blank default for character-based columns\n  - A zero default for numeric columns\n  - December 31 00-1 for date and timestamp columns\n  - 00:00:00 for time columns (and the time component in a timestamp)",
            "For example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\n\n## Related Statements\n\n- Create Table Statement\n- Modify Statement\n\n## Examples--Copy Statement\n\nThe following examples illustrate the correct use of the copy statement:\n\n1. In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\n\n   ```\n   ename     char(15)\n   age       integer4\n   dept      char(10)\n   comment   varchar(20)\n   ```\n\n   The emp.txt file contains the following data:\n\n   ```\n   Jones,J. 32 Anytown,USA toy,00017A This is a comment\n   Smith,P. 41 New York,NY admin,00015 Another comment\n   ```\n\n   The following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\n   - A dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\n   - The department field is delimited by a comma.\n   - The comment field is a variable-length varchar field, preceded by a five-character length specifier.\n\n2. Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\n\n   ```sql\n   copy table employee (eno=integer2, ename=char(10),\n       age=integer2, job=integer2, sal=float4,\n       dept=integer2, xxx=d1)\n       from 'myfile.in';\n   ```\n\n3. Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\n\n   ```sql\n   copy table employee (ename=char(0)comma,\n       eno=char(0)comma, sal= char(0)nl)\n       into 'mfile.out';\n   ```\n\n   Joe Smith , 101, $25000.00\n   \n   Shirley Scott , 102, $30000.00\n\n4. The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\n\n   ```sql\n   copy table employee (ename = text(0)csv,\n       eno = text(0)csv, sal = text(0)csv)\n       into 'mfile.out';\n   ```\n    \n   Joe Smith,101,$25000.00\n   Shirley Scott,102,$30000.00\n\n5. Bulk copy the employee table into a file. The resulting data file contains binary data.\n\n   ```sql\n   copy table employee () into 'ourfile.dat';\n   ```\n\n6. Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\n\n   ```sql\n   copy table other_employee_table () from 'ourfile.dat';\n   ```\n\n7. Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\n\n   ```sql\n   copy table acct_recv\n       (acct_name=char(0)'%',\n       address='d0%',\n       credit=char(0)'%' with null('xx'),\n       debit=char(0)'%' with null('xx'),\n       acct_mngr=char(15),\n       xx=d0nl)\n       into 'qtr_result';\n   ```\n\n   Smith Corp%% $12345.00% $-67890.00%Jones\n   ABC Oil %% $54321.00% $-98765.00%Green\n   Spring Omc%%xx %xx %Namroc\n\n8. Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\n\n   ```sql\n   copy table gifts\n       (item_name=char(0)tab,\n       date_recd=char(0)tab,\n       sender=char(20)nl with null('anonymous'))\n       into 'giftdata';\n   ```\n\n   toaster 04-mar-1993 Nicholas\n   sled 10-oct-1993 anonymous\n   rocket 01-dec-1993 Francisco\n\n9. Create a table and load it using bulk copy, specifying structural options.\n\n   ```sql\n   create table mytable (name char 25, ...);\n   \n   modify mytable to hash;\n   \n   copy mytable() from 'myfile' with minpages = 16384,\n   maxpages = 16384, allocation = 16384;\n   ```"
        ]
    },
    {
        "instruction": "What encoding is used for long varchar and long nvarchar data segments in Actian 4GL SQL COPY statements?",
        "input": "",
        "output": "Both long varchar and long nvarchar data segments in Actian 4GL SQL COPY statements are written using UTF-8 encoding. The data is divided into segments, each containing an integer specifying the length of the segment followed by the specified number of bytes for that segment.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "# Copy Statement\n\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\n\nThis statement has the following syntax:\n\n```sql\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\n```\n\n## Parameters--Copy Statement\n\nThis statement has the following parameters:\n\n- **table_name**: Specifies an existing table from which data is read or to which data is written.\n- **column_name**: Specifies the column from which data is read or to which data is written.\n- **format**: Specifies the format in which a value is stored in the file.\n- **filename**: Specifies the file from which data is read or to which data is written.\n- **type**: (Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\n\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\n\n- **with_clause**: Consists of the word with, followed by a comma-separated list of one or more of the following items:\n  - on_error = TERMINATE | CONTINUE\n  - error_count = n\n  - rollback = ENABLED | DISABLED\n  - log = 'filename'\n\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\n- allocation = n\n- extend = n\n- fillfactor = n (ISAM, Hash, and Btree only)\n- minpages = n (Hash only)\n- maxpages = n (Hash only)\n- leaffill = n (Btree only)\n- nonleaffill = n (Btree only)\n- row_estimate = n\n\n## Unformatted Copying\n\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\n\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\n\n```sql\ncopy table employee () into 'emp_name';\n```\n\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\n\nNote: An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\n\n## Formatted Copying\n\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\n\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\n\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\n\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\n\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).",
            "The values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.\n\nNote: If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\n\n```sql\ncopy table t (col1=c20, col2=c30, d0=nl) into 't.out':\n```\n\n## Bulk Copying\n\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\n\nThe requirements for performing a bulk copy are:\n\n- The table is not journaled\n- The table has no secondary indexes\n- For storage structures other than heap, the table is empty and occupies fewer than 18 pages\n\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\n\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\n\n## Column Formats for Copy\n\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\n\nNote: When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\n\n### Character (Text) Formats\n\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\n\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\n\nThe subtle differences between the various character formats are described in Copy Format Details.\n\n### Counted Character Formats\n\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\n\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\n\nNote: Nvarchar(0) is not a counted format.\n\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\n\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\n\n### Dummy Format\n\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\n\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\n\n### Unicode Formats\n\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\n\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\n\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\n\n### Binary Formats",
            "### Binary Formats\n\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\n\nCertainly. I'll convert the provided documentation into a Markdown (.md) file format, maintaining the content while adjusting only the formatting. Here's the result:\n\n### Copy Format Details\n\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\n- Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n- When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n- The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\n\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).",
            "| Format | How Stored (copy into) | How Read (copy from) |\n|--------|------------------------|----------------------|\n| boolean | Written as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format) | Same format as copy into |\n| byte(0) | Same as byte(n) where n is the display length of the corresponding table column. | Read as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. |\n| byte(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded. |\n| byte varying(0) | Same as byte varying(n) where n is the display length of the table column. | Read as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |\n| byte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |\n| C0 | Same as Cn where n is the display length of the corresponding table column | Read as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Any control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\. |\n| Cn | Written as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Any control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\. |\n| char(0) | Same as char(n) where n is the display length of the corresponding table column. | Read as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Unlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is. |\n| char(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding. Unlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Unlike C format, char does not convert control characters or tabs. File data is read as is. |\n| D0 | Instead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.) Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed. | Dummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value. Any \\ found in the input means that the next character is to be taken literally, and is not a delimiter. |\n| Dn | Dummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1. | Dummy field. N characters are read and discarded. Copy from does not allow a delimiter specification with a fixed-length dummy field. |\n| date | Written as a date. (A binary format) | Read as a date. (A binary format) |\n| decimal | Written as a decimal number. (A binary format.) | Read as a decimal number. (A binary format) |\n| float | Written as double\u2011precision floating point. (A binary format) | Read as double\u2011precision floating point. (A binary format) |\n| float4 | Written as single\u2011precision floating point. (A binary format) | Read as single\u2011precision floating point. (A binary format) |\n| integer | Written as integer of 4\u2011byte length. (A binary format) | Read as integer of 4\u2011byte length. (A binary format) |",
            "| integer1 | Written as integer of 1\u2011byte length. (A binary format) | Read as integer of 1\u2011byte length. (A binary format) |\n| long byte(0) | Identical to long varchar | Identical to long varchar |\n| long nvarchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). The maximum segment size for the long nvarchar segment is 32727 bytes. The UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment. If a delimiter is specified, it is written immediately following the last segment. | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| long varchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767. The following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long: 5 abcde10 abcdefghij 0 (with a space after the terminating 0 character) (In this example, the data that is in the originating table column is abcdeabcdefghij) | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| money | Written as a scaled floating point value (a money value). (A binary format) | Read as a scaled floating-point values (a money value). (A binary format) |\n| nchar(0) | Written as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value. | Read as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered. |\n| nvarchar(0) | Same as nchar(0) | Same as nchar(0) |\n| nchar(n) | Written as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| nvarchar(n) | Written as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding. The byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| smallint | Written as an integer of 2\u2011byte length. (A binary format.) | Read as integer of 2\u2011byte length. (A binary format) |\n| text(0) | Written as a variable length string. If a delimiter is specified, it is written after the value. If the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding. Copy into using text(0) format is the way to get variable width output with no padding. | Read as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value |\n| text(n) | Written as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding. | Reads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded. |\n| varchar(0) | Same as varchar(n), where n is the display length of the corresponding table column. | Read as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |",
            "| varchar(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length. | Read as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |",
            "Note: The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\n\nFor user-defined data types (UDTs), use char or varchar.\n\nCertainly. I'll create a single Markdown (.md) file based on the provided documentation, focusing on formatting the content without modifying it. Here's the Markdown version:\n\n### Delimiters in the Data File\n\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\n\n| Delimiter | Description |\n|-----------|-------------|\n| nl | Newline character |\n| tab | Tab character |\n| sp | Space |\n| csv | Comma separated values |\n| ssv | Semicolon separated values |\n| nul or null | Null/zero character |\n| comma | Comma |\n| colon | Colon |\n| dash | Dash |\n| lparen | Left parenthesis |\n| rparen | Right parenthesis |\n| X | Any non-numeric character |\n\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\n\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\n\n## CSV and SSV Delimiters\n\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\n\nThe rules for a CSV-delimited field are:\n\n- The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n- Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\n  ```\n  \"There is a double quote \"\" here\"\n  ```\n\n  is translated to the table value:\n\n  ```\n  There is a double quote \" here\n  ```\n\n  Whitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\n- Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\n\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\n\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \"counted\" formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)\n\nCopy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\n\n## With Null Clause for Copy\n\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\n\n### With Null (value) Clause\n\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\n\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.",
            "To prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\n\nFor example, this example of a value is incorrect:\n\n```\nc0comma with null(0)\n```\n\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\n\n```\nc0comma with null('0')\n```\n\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\n\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\n\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\n\n```sql\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\n```\n\nThe correct version specifies a 4-character format for the column.\n\n```sql\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\n```\n\n### With Null Clause Omitting Value\n\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\n\n## Filename Specification for Copy\n\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\n\nUNIX: For copy into, if the file already exists, copy overwrites it.\n\n## Windows File Types for Copy\n\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\n\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\n\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\n\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\n\nThe binary-copy forms (copy () from or copy () into) use binary mode.\n\nNote: Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.\n\nCopy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\n\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\n\n## With Clause for Copy\n\nValid with clause options for the copy statement are as follows:\n\n### On_error=TERMINATE|CONTINUE\n\nDirects copy to continue after encountering conversion errors.\n\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\n\nBy default, copy terminates when an error occurs while converting between table format and file format\n\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\n\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\n\n### Error_count=n\n\nSpecifies how many errors can occur before processing terminates.\n\nDefault: 1.\n\nIf on_error is set to continue, setting error_count has no effect.",
            "Default: 1.\n\nIf on_error is set to continue, setting error_count has no effect.\n\n### Log='filename'\n\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\n\nLogging works as follows:\n\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\n\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\n\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\n\n### Rollback=ENABLED|DISABLED\n\nEnables or disables rollback, as follows:\n\n- ENABLED: Directs the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\n- DISABLED: Retains the appended rows.\n\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\n\nDefault: ENABLED\n\nWhen copying to a file, the with rollback clause has no effect.\n\n### Row_estimate\n\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\n\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\n\n## Permissions\n\nTo use the copy statement, one of the following must apply:\n\n- You own the table.\n- The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n- You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\n\n## Locking\n\n- When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n- When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n- When performing a non-bulk copy into a table, the DBMS server takes an \"intent exclusive\" lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\n\n## Restrictions and Considerations\n\n- Copy cannot be used to add data to a view, index, or system catalog.\n- When copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\n- When copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\n- The copy statement does not fire any rules defined against the table.\n- Values cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\n- Copy treats a present-but-empty field in the data file as:\n  - A blank default for character-based columns\n  - A zero default for numeric columns\n  - December 31 00-1 for date and timestamp columns\n  - 00:00:00 for time columns (and the time component in a timestamp)",
            "For example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\n\n## Related Statements\n\n- Create Table Statement\n- Modify Statement\n\n## Examples--Copy Statement\n\nThe following examples illustrate the correct use of the copy statement:\n\n1. In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\n\n   ```\n   ename     char(15)\n   age       integer4\n   dept      char(10)\n   comment   varchar(20)\n   ```\n\n   The emp.txt file contains the following data:\n\n   ```\n   Jones,J. 32 Anytown,USA toy,00017A This is a comment\n   Smith,P. 41 New York,NY admin,00015 Another comment\n   ```\n\n   The following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\n   - A dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\n   - The department field is delimited by a comma.\n   - The comment field is a variable-length varchar field, preceded by a five-character length specifier.\n\n2. Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\n\n   ```sql\n   copy table employee (eno=integer2, ename=char(10),\n       age=integer2, job=integer2, sal=float4,\n       dept=integer2, xxx=d1)\n       from 'myfile.in';\n   ```\n\n3. Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\n\n   ```sql\n   copy table employee (ename=char(0)comma,\n       eno=char(0)comma, sal= char(0)nl)\n       into 'mfile.out';\n   ```\n\n   Joe Smith , 101, $25000.00\n   \n   Shirley Scott , 102, $30000.00\n\n4. The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\n\n   ```sql\n   copy table employee (ename = text(0)csv,\n       eno = text(0)csv, sal = text(0)csv)\n       into 'mfile.out';\n   ```\n    \n   Joe Smith,101,$25000.00\n   Shirley Scott,102,$30000.00\n\n5. Bulk copy the employee table into a file. The resulting data file contains binary data.\n\n   ```sql\n   copy table employee () into 'ourfile.dat';\n   ```\n\n6. Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\n\n   ```sql\n   copy table other_employee_table () from 'ourfile.dat';\n   ```\n\n7. Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\n\n   ```sql\n   copy table acct_recv\n       (acct_name=char(0)'%',\n       address='d0%',\n       credit=char(0)'%' with null('xx'),\n       debit=char(0)'%' with null('xx'),\n       acct_mngr=char(15),\n       xx=d0nl)\n       into 'qtr_result';\n   ```\n\n   Smith Corp%% $12345.00% $-67890.00%Jones\n   ABC Oil %% $54321.00% $-98765.00%Green\n   Spring Omc%%xx %xx %Namroc\n\n8. Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\n\n   ```sql\n   copy table gifts\n       (item_name=char(0)tab,\n       date_recd=char(0)tab,\n       sender=char(20)nl with null('anonymous'))\n       into 'giftdata';\n   ```\n\n   toaster 04-mar-1993 Nicholas\n   sled 10-oct-1993 anonymous\n   rocket 01-dec-1993 Francisco\n\n9. Create a table and load it using bulk copy, specifying structural options.\n\n   ```sql\n   create table mytable (name char 25, ...);\n   \n   modify mytable to hash;\n   \n   copy mytable() from 'myfile' with minpages = 16384,\n   maxpages = 16384, allocation = 16384;\n   ```"
        ]
    },
    {
        "instruction": "Explain the use of delimiters when working with CSV-delimited fields in Actian 4GL SQL COPY statements.",
        "input": "",
        "output": "Delimiters are characters that separate fields and mark the end of records in CSV-delimited files. In Actian 4GL SQL COPY statements, they are used to define the structure of CSV data files during import or export operations. For a field delimited by a comma, it is enclosed in quotes if it contains any comma, newline, or double quote, with special handling for quote characters within the quoted string. Semicolon works exactly the same way as comma, but for SSV-delimiters.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "# Copy Statement\n\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\n\nThis statement has the following syntax:\n\n```sql\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\n```\n\n## Parameters--Copy Statement\n\nThis statement has the following parameters:\n\n- **table_name**: Specifies an existing table from which data is read or to which data is written.\n- **column_name**: Specifies the column from which data is read or to which data is written.\n- **format**: Specifies the format in which a value is stored in the file.\n- **filename**: Specifies the file from which data is read or to which data is written.\n- **type**: (Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\n\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\n\n- **with_clause**: Consists of the word with, followed by a comma-separated list of one or more of the following items:\n  - on_error = TERMINATE | CONTINUE\n  - error_count = n\n  - rollback = ENABLED | DISABLED\n  - log = 'filename'\n\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\n- allocation = n\n- extend = n\n- fillfactor = n (ISAM, Hash, and Btree only)\n- minpages = n (Hash only)\n- maxpages = n (Hash only)\n- leaffill = n (Btree only)\n- nonleaffill = n (Btree only)\n- row_estimate = n\n\n## Unformatted Copying\n\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\n\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\n\n```sql\ncopy table employee () into 'emp_name';\n```\n\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\n\nNote: An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\n\n## Formatted Copying\n\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\n\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\n\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\n\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\n\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).",
            "The values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.\n\nNote: If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\n\n```sql\ncopy table t (col1=c20, col2=c30, d0=nl) into 't.out':\n```\n\n## Bulk Copying\n\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\n\nThe requirements for performing a bulk copy are:\n\n- The table is not journaled\n- The table has no secondary indexes\n- For storage structures other than heap, the table is empty and occupies fewer than 18 pages\n\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\n\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\n\n## Column Formats for Copy\n\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\n\nNote: When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\n\n### Character (Text) Formats\n\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\n\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\n\nThe subtle differences between the various character formats are described in Copy Format Details.\n\n### Counted Character Formats\n\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\n\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\n\nNote: Nvarchar(0) is not a counted format.\n\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\n\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\n\n### Dummy Format\n\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\n\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\n\n### Unicode Formats\n\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\n\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\n\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\n\n### Binary Formats",
            "### Binary Formats\n\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\n\nCertainly. I'll convert the provided documentation into a Markdown (.md) file format, maintaining the content while adjusting only the formatting. Here's the result:\n\n### Copy Format Details\n\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\n- Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n- When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n- The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\n\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).",
            "| Format | How Stored (copy into) | How Read (copy from) |\n|--------|------------------------|----------------------|\n| boolean | Written as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format) | Same format as copy into |\n| byte(0) | Same as byte(n) where n is the display length of the corresponding table column. | Read as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. |\n| byte(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded. |\n| byte varying(0) | Same as byte varying(n) where n is the display length of the table column. | Read as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |\n| byte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |\n| C0 | Same as Cn where n is the display length of the corresponding table column | Read as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Any control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\. |\n| Cn | Written as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Any control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\. |\n| char(0) | Same as char(n) where n is the display length of the corresponding table column. | Read as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Unlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is. |\n| char(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding. Unlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Unlike C format, char does not convert control characters or tabs. File data is read as is. |\n| D0 | Instead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.) Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed. | Dummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value. Any \\ found in the input means that the next character is to be taken literally, and is not a delimiter. |\n| Dn | Dummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1. | Dummy field. N characters are read and discarded. Copy from does not allow a delimiter specification with a fixed-length dummy field. |\n| date | Written as a date. (A binary format) | Read as a date. (A binary format) |\n| decimal | Written as a decimal number. (A binary format.) | Read as a decimal number. (A binary format) |\n| float | Written as double\u2011precision floating point. (A binary format) | Read as double\u2011precision floating point. (A binary format) |\n| float4 | Written as single\u2011precision floating point. (A binary format) | Read as single\u2011precision floating point. (A binary format) |\n| integer | Written as integer of 4\u2011byte length. (A binary format) | Read as integer of 4\u2011byte length. (A binary format) |",
            "| integer1 | Written as integer of 1\u2011byte length. (A binary format) | Read as integer of 1\u2011byte length. (A binary format) |\n| long byte(0) | Identical to long varchar | Identical to long varchar |\n| long nvarchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). The maximum segment size for the long nvarchar segment is 32727 bytes. The UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment. If a delimiter is specified, it is written immediately following the last segment. | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| long varchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767. The following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long: 5 abcde10 abcdefghij 0 (with a space after the terminating 0 character) (In this example, the data that is in the originating table column is abcdeabcdefghij) | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| money | Written as a scaled floating point value (a money value). (A binary format) | Read as a scaled floating-point values (a money value). (A binary format) |\n| nchar(0) | Written as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value. | Read as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered. |\n| nvarchar(0) | Same as nchar(0) | Same as nchar(0) |\n| nchar(n) | Written as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| nvarchar(n) | Written as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding. The byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| smallint | Written as an integer of 2\u2011byte length. (A binary format.) | Read as integer of 2\u2011byte length. (A binary format) |\n| text(0) | Written as a variable length string. If a delimiter is specified, it is written after the value. If the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding. Copy into using text(0) format is the way to get variable width output with no padding. | Read as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value |\n| text(n) | Written as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding. | Reads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded. |\n| varchar(0) | Same as varchar(n), where n is the display length of the corresponding table column. | Read as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |",
            "| varchar(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length. | Read as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |",
            "Note: The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\n\nFor user-defined data types (UDTs), use char or varchar.\n\nCertainly. I'll create a single Markdown (.md) file based on the provided documentation, focusing on formatting the content without modifying it. Here's the Markdown version:\n\n### Delimiters in the Data File\n\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\n\n| Delimiter | Description |\n|-----------|-------------|\n| nl | Newline character |\n| tab | Tab character |\n| sp | Space |\n| csv | Comma separated values |\n| ssv | Semicolon separated values |\n| nul or null | Null/zero character |\n| comma | Comma |\n| colon | Colon |\n| dash | Dash |\n| lparen | Left parenthesis |\n| rparen | Right parenthesis |\n| X | Any non-numeric character |\n\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\n\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\n\n## CSV and SSV Delimiters\n\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\n\nThe rules for a CSV-delimited field are:\n\n- The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n- Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\n  ```\n  \"There is a double quote \"\" here\"\n  ```\n\n  is translated to the table value:\n\n  ```\n  There is a double quote \" here\n  ```\n\n  Whitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\n- Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\n\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\n\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \"counted\" formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)\n\nCopy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\n\n## With Null Clause for Copy\n\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\n\n### With Null (value) Clause\n\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\n\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.",
            "To prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\n\nFor example, this example of a value is incorrect:\n\n```\nc0comma with null(0)\n```\n\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\n\n```\nc0comma with null('0')\n```\n\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\n\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\n\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\n\n```sql\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\n```\n\nThe correct version specifies a 4-character format for the column.\n\n```sql\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\n```\n\n### With Null Clause Omitting Value\n\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\n\n## Filename Specification for Copy\n\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\n\nUNIX: For copy into, if the file already exists, copy overwrites it.\n\n## Windows File Types for Copy\n\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\n\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\n\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\n\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\n\nThe binary-copy forms (copy () from or copy () into) use binary mode.\n\nNote: Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.\n\nCopy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\n\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\n\n## With Clause for Copy\n\nValid with clause options for the copy statement are as follows:\n\n### On_error=TERMINATE|CONTINUE\n\nDirects copy to continue after encountering conversion errors.\n\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\n\nBy default, copy terminates when an error occurs while converting between table format and file format\n\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\n\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\n\n### Error_count=n\n\nSpecifies how many errors can occur before processing terminates.\n\nDefault: 1.\n\nIf on_error is set to continue, setting error_count has no effect.",
            "Default: 1.\n\nIf on_error is set to continue, setting error_count has no effect.\n\n### Log='filename'\n\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\n\nLogging works as follows:\n\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\n\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\n\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\n\n### Rollback=ENABLED|DISABLED\n\nEnables or disables rollback, as follows:\n\n- ENABLED: Directs the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\n- DISABLED: Retains the appended rows.\n\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\n\nDefault: ENABLED\n\nWhen copying to a file, the with rollback clause has no effect.\n\n### Row_estimate\n\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\n\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\n\n## Permissions\n\nTo use the copy statement, one of the following must apply:\n\n- You own the table.\n- The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n- You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\n\n## Locking\n\n- When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n- When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n- When performing a non-bulk copy into a table, the DBMS server takes an \"intent exclusive\" lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\n\n## Restrictions and Considerations\n\n- Copy cannot be used to add data to a view, index, or system catalog.\n- When copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\n- When copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\n- The copy statement does not fire any rules defined against the table.\n- Values cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\n- Copy treats a present-but-empty field in the data file as:\n  - A blank default for character-based columns\n  - A zero default for numeric columns\n  - December 31 00-1 for date and timestamp columns\n  - 00:00:00 for time columns (and the time component in a timestamp)",
            "For example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\n\n## Related Statements\n\n- Create Table Statement\n- Modify Statement\n\n## Examples--Copy Statement\n\nThe following examples illustrate the correct use of the copy statement:\n\n1. In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\n\n   ```\n   ename     char(15)\n   age       integer4\n   dept      char(10)\n   comment   varchar(20)\n   ```\n\n   The emp.txt file contains the following data:\n\n   ```\n   Jones,J. 32 Anytown,USA toy,00017A This is a comment\n   Smith,P. 41 New York,NY admin,00015 Another comment\n   ```\n\n   The following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\n   - A dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\n   - The department field is delimited by a comma.\n   - The comment field is a variable-length varchar field, preceded by a five-character length specifier.\n\n2. Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\n\n   ```sql\n   copy table employee (eno=integer2, ename=char(10),\n       age=integer2, job=integer2, sal=float4,\n       dept=integer2, xxx=d1)\n       from 'myfile.in';\n   ```\n\n3. Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\n\n   ```sql\n   copy table employee (ename=char(0)comma,\n       eno=char(0)comma, sal= char(0)nl)\n       into 'mfile.out';\n   ```\n\n   Joe Smith , 101, $25000.00\n   \n   Shirley Scott , 102, $30000.00\n\n4. The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\n\n   ```sql\n   copy table employee (ename = text(0)csv,\n       eno = text(0)csv, sal = text(0)csv)\n       into 'mfile.out';\n   ```\n    \n   Joe Smith,101,$25000.00\n   Shirley Scott,102,$30000.00\n\n5. Bulk copy the employee table into a file. The resulting data file contains binary data.\n\n   ```sql\n   copy table employee () into 'ourfile.dat';\n   ```\n\n6. Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\n\n   ```sql\n   copy table other_employee_table () from 'ourfile.dat';\n   ```\n\n7. Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\n\n   ```sql\n   copy table acct_recv\n       (acct_name=char(0)'%',\n       address='d0%',\n       credit=char(0)'%' with null('xx'),\n       debit=char(0)'%' with null('xx'),\n       acct_mngr=char(15),\n       xx=d0nl)\n       into 'qtr_result';\n   ```\n\n   Smith Corp%% $12345.00% $-67890.00%Jones\n   ABC Oil %% $54321.00% $-98765.00%Green\n   Spring Omc%%xx %xx %Namroc\n\n8. Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\n\n   ```sql\n   copy table gifts\n       (item_name=char(0)tab,\n       date_recd=char(0)tab,\n       sender=char(20)nl with null('anonymous'))\n       into 'giftdata';\n   ```\n\n   toaster 04-mar-1993 Nicholas\n   sled 10-oct-1993 anonymous\n   rocket 01-dec-1993 Francisco\n\n9. Create a table and load it using bulk copy, specifying structural options.\n\n   ```sql\n   create table mytable (name char 25, ...);\n   \n   modify mytable to hash;\n   \n   copy mytable() from 'myfile' with minpages = 16384,\n   maxpages = 16384, allocation = 16384;\n   ```"
        ]
    },
    {
        "instruction": "Provide an example of the Actian 4GL SQL COPY `FROM` statement using the `WITH NULL` clause and the CSV delimiter with double quotes and a user-defined marker value for nulls.",
        "input": "",
        "output": "Assuming we have the following table named \"employees\":\n\n```sql\nCREATE TABLE employees (\n    employee_id INTEGER,\n    first_name CHAR(20),\n    last_name CHAR(20),\n    salary DECIMAL(18, 2) NOT NULL,\n    department_name CHAR(50),\n    comments TEXT\n);\n```\n\nand we want to import a CSV file named \"employees.csv\" with null values represented by the string `'N/A'`. The Actian 4GL SQL COPY statement would look like:\n\n```sql\nCOPY employees\nFROM 'employees.csv' (delimiter ',', with null ('N/A'))\nINTO '.'\n```\n\nThe CSV file \"employees.csv\" should contain columns in the following format:\n\n```\n123,John,'Doe','50000.00','Sales',\n456,Jane,'Smith','35000.00','Marketing','N/A'\n...\n```",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "# Copy Statement\n\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\n\nThis statement has the following syntax:\n\n```sql\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\n```\n\n## Parameters--Copy Statement\n\nThis statement has the following parameters:\n\n- **table_name**: Specifies an existing table from which data is read or to which data is written.\n- **column_name**: Specifies the column from which data is read or to which data is written.\n- **format**: Specifies the format in which a value is stored in the file.\n- **filename**: Specifies the file from which data is read or to which data is written.\n- **type**: (Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\n\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\n\n- **with_clause**: Consists of the word with, followed by a comma-separated list of one or more of the following items:\n  - on_error = TERMINATE | CONTINUE\n  - error_count = n\n  - rollback = ENABLED | DISABLED\n  - log = 'filename'\n\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\n- allocation = n\n- extend = n\n- fillfactor = n (ISAM, Hash, and Btree only)\n- minpages = n (Hash only)\n- maxpages = n (Hash only)\n- leaffill = n (Btree only)\n- nonleaffill = n (Btree only)\n- row_estimate = n\n\n## Unformatted Copying\n\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\n\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\n\n```sql\ncopy table employee () into 'emp_name';\n```\n\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\n\nNote: An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\n\n## Formatted Copying\n\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\n\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\n\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\n\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\n\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).",
            "The values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.\n\nNote: If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\n\n```sql\ncopy table t (col1=c20, col2=c30, d0=nl) into 't.out':\n```\n\n## Bulk Copying\n\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\n\nThe requirements for performing a bulk copy are:\n\n- The table is not journaled\n- The table has no secondary indexes\n- For storage structures other than heap, the table is empty and occupies fewer than 18 pages\n\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\n\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\n\n## Column Formats for Copy\n\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\n\nNote: When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\n\n### Character (Text) Formats\n\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\n\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\n\nThe subtle differences between the various character formats are described in Copy Format Details.\n\n### Counted Character Formats\n\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\n\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\n\nNote: Nvarchar(0) is not a counted format.\n\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\n\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\n\n### Dummy Format\n\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\n\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\n\n### Unicode Formats\n\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\n\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\n\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\n\n### Binary Formats",
            "### Binary Formats\n\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\n\nCertainly. I'll convert the provided documentation into a Markdown (.md) file format, maintaining the content while adjusting only the formatting. Here's the result:\n\n### Copy Format Details\n\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\n- Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n- When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n- The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\n\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).",
            "| Format | How Stored (copy into) | How Read (copy from) |\n|--------|------------------------|----------------------|\n| boolean | Written as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format) | Same format as copy into |\n| byte(0) | Same as byte(n) where n is the display length of the corresponding table column. | Read as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. |\n| byte(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded. |\n| byte varying(0) | Same as byte varying(n) where n is the display length of the table column. | Read as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |\n| byte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |\n| C0 | Same as Cn where n is the display length of the corresponding table column | Read as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Any control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\. |\n| Cn | Written as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Any control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\. |\n| char(0) | Same as char(n) where n is the display length of the corresponding table column. | Read as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Unlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is. |\n| char(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding. Unlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Unlike C format, char does not convert control characters or tabs. File data is read as is. |\n| D0 | Instead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.) Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed. | Dummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value. Any \\ found in the input means that the next character is to be taken literally, and is not a delimiter. |\n| Dn | Dummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1. | Dummy field. N characters are read and discarded. Copy from does not allow a delimiter specification with a fixed-length dummy field. |\n| date | Written as a date. (A binary format) | Read as a date. (A binary format) |\n| decimal | Written as a decimal number. (A binary format.) | Read as a decimal number. (A binary format) |\n| float | Written as double\u2011precision floating point. (A binary format) | Read as double\u2011precision floating point. (A binary format) |\n| float4 | Written as single\u2011precision floating point. (A binary format) | Read as single\u2011precision floating point. (A binary format) |\n| integer | Written as integer of 4\u2011byte length. (A binary format) | Read as integer of 4\u2011byte length. (A binary format) |",
            "| integer1 | Written as integer of 1\u2011byte length. (A binary format) | Read as integer of 1\u2011byte length. (A binary format) |\n| long byte(0) | Identical to long varchar | Identical to long varchar |\n| long nvarchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). The maximum segment size for the long nvarchar segment is 32727 bytes. The UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment. If a delimiter is specified, it is written immediately following the last segment. | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| long varchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767. The following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long: 5 abcde10 abcdefghij 0 (with a space after the terminating 0 character) (In this example, the data that is in the originating table column is abcdeabcdefghij) | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| money | Written as a scaled floating point value (a money value). (A binary format) | Read as a scaled floating-point values (a money value). (A binary format) |\n| nchar(0) | Written as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value. | Read as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered. |\n| nvarchar(0) | Same as nchar(0) | Same as nchar(0) |\n| nchar(n) | Written as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| nvarchar(n) | Written as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding. The byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| smallint | Written as an integer of 2\u2011byte length. (A binary format.) | Read as integer of 2\u2011byte length. (A binary format) |\n| text(0) | Written as a variable length string. If a delimiter is specified, it is written after the value. If the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding. Copy into using text(0) format is the way to get variable width output with no padding. | Read as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value |\n| text(n) | Written as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding. | Reads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded. |\n| varchar(0) | Same as varchar(n), where n is the display length of the corresponding table column. | Read as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |",
            "| varchar(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length. | Read as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |",
            "Note: The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\n\nFor user-defined data types (UDTs), use char or varchar.\n\nCertainly. I'll create a single Markdown (.md) file based on the provided documentation, focusing on formatting the content without modifying it. Here's the Markdown version:\n\n### Delimiters in the Data File\n\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\n\n| Delimiter | Description |\n|-----------|-------------|\n| nl | Newline character |\n| tab | Tab character |\n| sp | Space |\n| csv | Comma separated values |\n| ssv | Semicolon separated values |\n| nul or null | Null/zero character |\n| comma | Comma |\n| colon | Colon |\n| dash | Dash |\n| lparen | Left parenthesis |\n| rparen | Right parenthesis |\n| X | Any non-numeric character |\n\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\n\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\n\n## CSV and SSV Delimiters\n\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\n\nThe rules for a CSV-delimited field are:\n\n- The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n- Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\n  ```\n  \"There is a double quote \"\" here\"\n  ```\n\n  is translated to the table value:\n\n  ```\n  There is a double quote \" here\n  ```\n\n  Whitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\n- Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\n\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\n\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \"counted\" formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)\n\nCopy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\n\n## With Null Clause for Copy\n\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\n\n### With Null (value) Clause\n\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\n\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.",
            "To prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\n\nFor example, this example of a value is incorrect:\n\n```\nc0comma with null(0)\n```\n\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\n\n```\nc0comma with null('0')\n```\n\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\n\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\n\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\n\n```sql\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\n```\n\nThe correct version specifies a 4-character format for the column.\n\n```sql\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\n```\n\n### With Null Clause Omitting Value\n\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\n\n## Filename Specification for Copy\n\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\n\nUNIX: For copy into, if the file already exists, copy overwrites it.\n\n## Windows File Types for Copy\n\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\n\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\n\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\n\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\n\nThe binary-copy forms (copy () from or copy () into) use binary mode.\n\nNote: Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.\n\nCopy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\n\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\n\n## With Clause for Copy\n\nValid with clause options for the copy statement are as follows:\n\n### On_error=TERMINATE|CONTINUE\n\nDirects copy to continue after encountering conversion errors.\n\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\n\nBy default, copy terminates when an error occurs while converting between table format and file format\n\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\n\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\n\n### Error_count=n\n\nSpecifies how many errors can occur before processing terminates.\n\nDefault: 1.\n\nIf on_error is set to continue, setting error_count has no effect.",
            "Default: 1.\n\nIf on_error is set to continue, setting error_count has no effect.\n\n### Log='filename'\n\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\n\nLogging works as follows:\n\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\n\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\n\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\n\n### Rollback=ENABLED|DISABLED\n\nEnables or disables rollback, as follows:\n\n- ENABLED: Directs the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\n- DISABLED: Retains the appended rows.\n\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\n\nDefault: ENABLED\n\nWhen copying to a file, the with rollback clause has no effect.\n\n### Row_estimate\n\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\n\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\n\n## Permissions\n\nTo use the copy statement, one of the following must apply:\n\n- You own the table.\n- The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n- You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\n\n## Locking\n\n- When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n- When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n- When performing a non-bulk copy into a table, the DBMS server takes an \"intent exclusive\" lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\n\n## Restrictions and Considerations\n\n- Copy cannot be used to add data to a view, index, or system catalog.\n- When copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\n- When copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\n- The copy statement does not fire any rules defined against the table.\n- Values cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\n- Copy treats a present-but-empty field in the data file as:\n  - A blank default for character-based columns\n  - A zero default for numeric columns\n  - December 31 00-1 for date and timestamp columns\n  - 00:00:00 for time columns (and the time component in a timestamp)",
            "For example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\n\n## Related Statements\n\n- Create Table Statement\n- Modify Statement\n\n## Examples--Copy Statement\n\nThe following examples illustrate the correct use of the copy statement:\n\n1. In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\n\n   ```\n   ename     char(15)\n   age       integer4\n   dept      char(10)\n   comment   varchar(20)\n   ```\n\n   The emp.txt file contains the following data:\n\n   ```\n   Jones,J. 32 Anytown,USA toy,00017A This is a comment\n   Smith,P. 41 New York,NY admin,00015 Another comment\n   ```\n\n   The following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\n   - A dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\n   - The department field is delimited by a comma.\n   - The comment field is a variable-length varchar field, preceded by a five-character length specifier.\n\n2. Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\n\n   ```sql\n   copy table employee (eno=integer2, ename=char(10),\n       age=integer2, job=integer2, sal=float4,\n       dept=integer2, xxx=d1)\n       from 'myfile.in';\n   ```\n\n3. Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\n\n   ```sql\n   copy table employee (ename=char(0)comma,\n       eno=char(0)comma, sal= char(0)nl)\n       into 'mfile.out';\n   ```\n\n   Joe Smith , 101, $25000.00\n   \n   Shirley Scott , 102, $30000.00\n\n4. The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\n\n   ```sql\n   copy table employee (ename = text(0)csv,\n       eno = text(0)csv, sal = text(0)csv)\n       into 'mfile.out';\n   ```\n    \n   Joe Smith,101,$25000.00\n   Shirley Scott,102,$30000.00\n\n5. Bulk copy the employee table into a file. The resulting data file contains binary data.\n\n   ```sql\n   copy table employee () into 'ourfile.dat';\n   ```\n\n6. Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\n\n   ```sql\n   copy table other_employee_table () from 'ourfile.dat';\n   ```\n\n7. Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\n\n   ```sql\n   copy table acct_recv\n       (acct_name=char(0)'%',\n       address='d0%',\n       credit=char(0)'%' with null('xx'),\n       debit=char(0)'%' with null('xx'),\n       acct_mngr=char(15),\n       xx=d0nl)\n       into 'qtr_result';\n   ```\n\n   Smith Corp%% $12345.00% $-67890.00%Jones\n   ABC Oil %% $54321.00% $-98765.00%Green\n   Spring Omc%%xx %xx %Namroc\n\n8. Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\n\n   ```sql\n   copy table gifts\n       (item_name=char(0)tab,\n       date_recd=char(0)tab,\n       sender=char(20)nl with null('anonymous'))\n       into 'giftdata';\n   ```\n\n   toaster 04-mar-1993 Nicholas\n   sled 10-oct-1993 anonymous\n   rocket 01-dec-1993 Francisco\n\n9. Create a table and load it using bulk copy, specifying structural options.\n\n   ```sql\n   create table mytable (name char 25, ...);\n   \n   modify mytable to hash;\n   \n   copy mytable() from 'myfile' with minpages = 16384,\n   maxpages = 16384, allocation = 16384;\n   ```"
        ]
    },
    {
        "instruction": "Describe the role of the `COMMA` delimiter in Actian 4GL SQL COPY statements.",
        "input": "",
        "output": "In Actian 4GL SQL COPY statements, the comma delimiter is used to separate column values within a row when exporting data to a CSV file. When importing data from a CSV file, the comma is used to specify the column separator for each record being loaded into a table.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "# Copy Statement\n\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\n\nThis statement has the following syntax:\n\n```sql\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\n```\n\n## Parameters--Copy Statement\n\nThis statement has the following parameters:\n\n- **table_name**: Specifies an existing table from which data is read or to which data is written.\n- **column_name**: Specifies the column from which data is read or to which data is written.\n- **format**: Specifies the format in which a value is stored in the file.\n- **filename**: Specifies the file from which data is read or to which data is written.\n- **type**: (Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\n\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\n\n- **with_clause**: Consists of the word with, followed by a comma-separated list of one or more of the following items:\n  - on_error = TERMINATE | CONTINUE\n  - error_count = n\n  - rollback = ENABLED | DISABLED\n  - log = 'filename'\n\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\n- allocation = n\n- extend = n\n- fillfactor = n (ISAM, Hash, and Btree only)\n- minpages = n (Hash only)\n- maxpages = n (Hash only)\n- leaffill = n (Btree only)\n- nonleaffill = n (Btree only)\n- row_estimate = n\n\n## Unformatted Copying\n\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\n\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\n\n```sql\ncopy table employee () into 'emp_name';\n```\n\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\n\nNote: An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\n\n## Formatted Copying\n\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\n\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\n\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\n\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\n\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).",
            "The values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.\n\nNote: If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\n\n```sql\ncopy table t (col1=c20, col2=c30, d0=nl) into 't.out':\n```\n\n## Bulk Copying\n\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\n\nThe requirements for performing a bulk copy are:\n\n- The table is not journaled\n- The table has no secondary indexes\n- For storage structures other than heap, the table is empty and occupies fewer than 18 pages\n\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\n\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\n\n## Column Formats for Copy\n\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\n\nNote: When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\n\n### Character (Text) Formats\n\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\n\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\n\nThe subtle differences between the various character formats are described in Copy Format Details.\n\n### Counted Character Formats\n\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\n\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\n\nNote: Nvarchar(0) is not a counted format.\n\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\n\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\n\n### Dummy Format\n\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\n\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\n\n### Unicode Formats\n\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\n\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\n\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\n\n### Binary Formats",
            "### Binary Formats\n\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\n\nCertainly. I'll convert the provided documentation into a Markdown (.md) file format, maintaining the content while adjusting only the formatting. Here's the result:\n\n### Copy Format Details\n\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\n- Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n- When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n- The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\n\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).",
            "| Format | How Stored (copy into) | How Read (copy from) |\n|--------|------------------------|----------------------|\n| boolean | Written as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format) | Same format as copy into |\n| byte(0) | Same as byte(n) where n is the display length of the corresponding table column. | Read as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. |\n| byte(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded. |\n| byte varying(0) | Same as byte varying(n) where n is the display length of the table column. | Read as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |\n| byte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |\n| C0 | Same as Cn where n is the display length of the corresponding table column | Read as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Any control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\. |\n| Cn | Written as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Any control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\. |\n| char(0) | Same as char(n) where n is the display length of the corresponding table column. | Read as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Unlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is. |\n| char(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding. Unlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Unlike C format, char does not convert control characters or tabs. File data is read as is. |\n| D0 | Instead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.) Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed. | Dummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value. Any \\ found in the input means that the next character is to be taken literally, and is not a delimiter. |\n| Dn | Dummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1. | Dummy field. N characters are read and discarded. Copy from does not allow a delimiter specification with a fixed-length dummy field. |\n| date | Written as a date. (A binary format) | Read as a date. (A binary format) |\n| decimal | Written as a decimal number. (A binary format.) | Read as a decimal number. (A binary format) |\n| float | Written as double\u2011precision floating point. (A binary format) | Read as double\u2011precision floating point. (A binary format) |\n| float4 | Written as single\u2011precision floating point. (A binary format) | Read as single\u2011precision floating point. (A binary format) |\n| integer | Written as integer of 4\u2011byte length. (A binary format) | Read as integer of 4\u2011byte length. (A binary format) |",
            "| integer1 | Written as integer of 1\u2011byte length. (A binary format) | Read as integer of 1\u2011byte length. (A binary format) |\n| long byte(0) | Identical to long varchar | Identical to long varchar |\n| long nvarchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). The maximum segment size for the long nvarchar segment is 32727 bytes. The UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment. If a delimiter is specified, it is written immediately following the last segment. | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| long varchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767. The following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long: 5 abcde10 abcdefghij 0 (with a space after the terminating 0 character) (In this example, the data that is in the originating table column is abcdeabcdefghij) | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| money | Written as a scaled floating point value (a money value). (A binary format) | Read as a scaled floating-point values (a money value). (A binary format) |\n| nchar(0) | Written as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value. | Read as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered. |\n| nvarchar(0) | Same as nchar(0) | Same as nchar(0) |\n| nchar(n) | Written as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| nvarchar(n) | Written as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding. The byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| smallint | Written as an integer of 2\u2011byte length. (A binary format.) | Read as integer of 2\u2011byte length. (A binary format) |\n| text(0) | Written as a variable length string. If a delimiter is specified, it is written after the value. If the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding. Copy into using text(0) format is the way to get variable width output with no padding. | Read as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value |\n| text(n) | Written as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding. | Reads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded. |\n| varchar(0) | Same as varchar(n), where n is the display length of the corresponding table column. | Read as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |",
            "| varchar(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length. | Read as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |",
            "Note: The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\n\nFor user-defined data types (UDTs), use char or varchar.\n\nCertainly. I'll create a single Markdown (.md) file based on the provided documentation, focusing on formatting the content without modifying it. Here's the Markdown version:\n\n### Delimiters in the Data File\n\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\n\n| Delimiter | Description |\n|-----------|-------------|\n| nl | Newline character |\n| tab | Tab character |\n| sp | Space |\n| csv | Comma separated values |\n| ssv | Semicolon separated values |\n| nul or null | Null/zero character |\n| comma | Comma |\n| colon | Colon |\n| dash | Dash |\n| lparen | Left parenthesis |\n| rparen | Right parenthesis |\n| X | Any non-numeric character |\n\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\n\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\n\n## CSV and SSV Delimiters\n\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\n\nThe rules for a CSV-delimited field are:\n\n- The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n- Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\n  ```\n  \"There is a double quote \"\" here\"\n  ```\n\n  is translated to the table value:\n\n  ```\n  There is a double quote \" here\n  ```\n\n  Whitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\n- Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\n\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\n\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \"counted\" formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)\n\nCopy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\n\n## With Null Clause for Copy\n\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\n\n### With Null (value) Clause\n\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\n\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.",
            "To prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\n\nFor example, this example of a value is incorrect:\n\n```\nc0comma with null(0)\n```\n\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\n\n```\nc0comma with null('0')\n```\n\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\n\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\n\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\n\n```sql\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\n```\n\nThe correct version specifies a 4-character format for the column.\n\n```sql\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\n```\n\n### With Null Clause Omitting Value\n\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\n\n## Filename Specification for Copy\n\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\n\nUNIX: For copy into, if the file already exists, copy overwrites it.\n\n## Windows File Types for Copy\n\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\n\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\n\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\n\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\n\nThe binary-copy forms (copy () from or copy () into) use binary mode.\n\nNote: Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.\n\nCopy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\n\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\n\n## With Clause for Copy\n\nValid with clause options for the copy statement are as follows:\n\n### On_error=TERMINATE|CONTINUE\n\nDirects copy to continue after encountering conversion errors.\n\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\n\nBy default, copy terminates when an error occurs while converting between table format and file format\n\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\n\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\n\n### Error_count=n\n\nSpecifies how many errors can occur before processing terminates.\n\nDefault: 1.\n\nIf on_error is set to continue, setting error_count has no effect.",
            "Default: 1.\n\nIf on_error is set to continue, setting error_count has no effect.\n\n### Log='filename'\n\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\n\nLogging works as follows:\n\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\n\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\n\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\n\n### Rollback=ENABLED|DISABLED\n\nEnables or disables rollback, as follows:\n\n- ENABLED: Directs the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\n- DISABLED: Retains the appended rows.\n\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\n\nDefault: ENABLED\n\nWhen copying to a file, the with rollback clause has no effect.\n\n### Row_estimate\n\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\n\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\n\n## Permissions\n\nTo use the copy statement, one of the following must apply:\n\n- You own the table.\n- The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n- You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\n\n## Locking\n\n- When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n- When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n- When performing a non-bulk copy into a table, the DBMS server takes an \"intent exclusive\" lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\n\n## Restrictions and Considerations\n\n- Copy cannot be used to add data to a view, index, or system catalog.\n- When copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\n- When copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\n- The copy statement does not fire any rules defined against the table.\n- Values cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\n- Copy treats a present-but-empty field in the data file as:\n  - A blank default for character-based columns\n  - A zero default for numeric columns\n  - December 31 00-1 for date and timestamp columns\n  - 00:00:00 for time columns (and the time component in a timestamp)",
            "For example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\n\n## Related Statements\n\n- Create Table Statement\n- Modify Statement\n\n## Examples--Copy Statement\n\nThe following examples illustrate the correct use of the copy statement:\n\n1. In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\n\n   ```\n   ename     char(15)\n   age       integer4\n   dept      char(10)\n   comment   varchar(20)\n   ```\n\n   The emp.txt file contains the following data:\n\n   ```\n   Jones,J. 32 Anytown,USA toy,00017A This is a comment\n   Smith,P. 41 New York,NY admin,00015 Another comment\n   ```\n\n   The following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\n   - A dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\n   - The department field is delimited by a comma.\n   - The comment field is a variable-length varchar field, preceded by a five-character length specifier.\n\n2. Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\n\n   ```sql\n   copy table employee (eno=integer2, ename=char(10),\n       age=integer2, job=integer2, sal=float4,\n       dept=integer2, xxx=d1)\n       from 'myfile.in';\n   ```\n\n3. Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\n\n   ```sql\n   copy table employee (ename=char(0)comma,\n       eno=char(0)comma, sal= char(0)nl)\n       into 'mfile.out';\n   ```\n\n   Joe Smith , 101, $25000.00\n   \n   Shirley Scott , 102, $30000.00\n\n4. The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\n\n   ```sql\n   copy table employee (ename = text(0)csv,\n       eno = text(0)csv, sal = text(0)csv)\n       into 'mfile.out';\n   ```\n    \n   Joe Smith,101,$25000.00\n   Shirley Scott,102,$30000.00\n\n5. Bulk copy the employee table into a file. The resulting data file contains binary data.\n\n   ```sql\n   copy table employee () into 'ourfile.dat';\n   ```\n\n6. Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\n\n   ```sql\n   copy table other_employee_table () from 'ourfile.dat';\n   ```\n\n7. Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\n\n   ```sql\n   copy table acct_recv\n       (acct_name=char(0)'%',\n       address='d0%',\n       credit=char(0)'%' with null('xx'),\n       debit=char(0)'%' with null('xx'),\n       acct_mngr=char(15),\n       xx=d0nl)\n       into 'qtr_result';\n   ```\n\n   Smith Corp%% $12345.00% $-67890.00%Jones\n   ABC Oil %% $54321.00% $-98765.00%Green\n   Spring Omc%%xx %xx %Namroc\n\n8. Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\n\n   ```sql\n   copy table gifts\n       (item_name=char(0)tab,\n       date_recd=char(0)tab,\n       sender=char(20)nl with null('anonymous'))\n       into 'giftdata';\n   ```\n\n   toaster 04-mar-1993 Nicholas\n   sled 10-oct-1993 anonymous\n   rocket 01-dec-1993 Francisco\n\n9. Create a table and load it using bulk copy, specifying structural options.\n\n   ```sql\n   create table mytable (name char 25, ...);\n   \n   modify mytable to hash;\n   \n   copy mytable() from 'myfile' with minpages = 16384,\n   maxpages = 16384, allocation = 16384;\n   ```"
        ]
    },
    {
        "instruction": "How can you import binary data (rather than character data) using Actian 4GL SQL COPY statements?",
        "input": "",
        "output": "To import binary data, you should use the following syntax:\n```sql\nCOPY table_name FROM 'datafile.bin' [USING options];\n```\nReplace `table_name` with the name of the database table to receive the imported binary data and `datafile.bin` with the path to the binary file containing the data you want to import. As with other COPY statements, `USING options` is optional and can include specifications for the format or behavior of the imported data.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "# Copy Statement\n\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\n\nThis statement has the following syntax:\n\n```sql\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\n```\n\n## Parameters--Copy Statement\n\nThis statement has the following parameters:\n\n- **table_name**: Specifies an existing table from which data is read or to which data is written.\n- **column_name**: Specifies the column from which data is read or to which data is written.\n- **format**: Specifies the format in which a value is stored in the file.\n- **filename**: Specifies the file from which data is read or to which data is written.\n- **type**: (Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\n\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\n\n- **with_clause**: Consists of the word with, followed by a comma-separated list of one or more of the following items:\n  - on_error = TERMINATE | CONTINUE\n  - error_count = n\n  - rollback = ENABLED | DISABLED\n  - log = 'filename'\n\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\n- allocation = n\n- extend = n\n- fillfactor = n (ISAM, Hash, and Btree only)\n- minpages = n (Hash only)\n- maxpages = n (Hash only)\n- leaffill = n (Btree only)\n- nonleaffill = n (Btree only)\n- row_estimate = n\n\n## Unformatted Copying\n\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\n\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\n\n```sql\ncopy table employee () into 'emp_name';\n```\n\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\n\nNote: An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\n\n## Formatted Copying\n\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\n\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\n\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\n\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\n\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).",
            "The values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.\n\nNote: If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\n\n```sql\ncopy table t (col1=c20, col2=c30, d0=nl) into 't.out':\n```\n\n## Bulk Copying\n\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\n\nThe requirements for performing a bulk copy are:\n\n- The table is not journaled\n- The table has no secondary indexes\n- For storage structures other than heap, the table is empty and occupies fewer than 18 pages\n\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\n\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\n\n## Column Formats for Copy\n\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\n\nNote: When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\n\n### Character (Text) Formats\n\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\n\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\n\nThe subtle differences between the various character formats are described in Copy Format Details.\n\n### Counted Character Formats\n\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\n\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\n\nNote: Nvarchar(0) is not a counted format.\n\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\n\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\n\n### Dummy Format\n\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\n\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\n\n### Unicode Formats\n\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\n\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\n\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\n\n### Binary Formats",
            "### Binary Formats\n\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\n\nCertainly. I'll convert the provided documentation into a Markdown (.md) file format, maintaining the content while adjusting only the formatting. Here's the result:\n\n### Copy Format Details\n\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\n- Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n- When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n- The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\n\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).",
            "| Format | How Stored (copy into) | How Read (copy from) |\n|--------|------------------------|----------------------|\n| boolean | Written as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format) | Same format as copy into |\n| byte(0) | Same as byte(n) where n is the display length of the corresponding table column. | Read as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. |\n| byte(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded. |\n| byte varying(0) | Same as byte varying(n) where n is the display length of the table column. | Read as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |\n| byte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |\n| C0 | Same as Cn where n is the display length of the corresponding table column | Read as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Any control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\. |\n| Cn | Written as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Any control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\. |\n| char(0) | Same as char(n) where n is the display length of the corresponding table column. | Read as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Unlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is. |\n| char(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding. Unlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Unlike C format, char does not convert control characters or tabs. File data is read as is. |\n| D0 | Instead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.) Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed. | Dummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value. Any \\ found in the input means that the next character is to be taken literally, and is not a delimiter. |\n| Dn | Dummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1. | Dummy field. N characters are read and discarded. Copy from does not allow a delimiter specification with a fixed-length dummy field. |\n| date | Written as a date. (A binary format) | Read as a date. (A binary format) |\n| decimal | Written as a decimal number. (A binary format.) | Read as a decimal number. (A binary format) |\n| float | Written as double\u2011precision floating point. (A binary format) | Read as double\u2011precision floating point. (A binary format) |\n| float4 | Written as single\u2011precision floating point. (A binary format) | Read as single\u2011precision floating point. (A binary format) |\n| integer | Written as integer of 4\u2011byte length. (A binary format) | Read as integer of 4\u2011byte length. (A binary format) |",
            "| integer1 | Written as integer of 1\u2011byte length. (A binary format) | Read as integer of 1\u2011byte length. (A binary format) |\n| long byte(0) | Identical to long varchar | Identical to long varchar |\n| long nvarchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). The maximum segment size for the long nvarchar segment is 32727 bytes. The UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment. If a delimiter is specified, it is written immediately following the last segment. | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| long varchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767. The following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long: 5 abcde10 abcdefghij 0 (with a space after the terminating 0 character) (In this example, the data that is in the originating table column is abcdeabcdefghij) | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| money | Written as a scaled floating point value (a money value). (A binary format) | Read as a scaled floating-point values (a money value). (A binary format) |\n| nchar(0) | Written as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value. | Read as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered. |\n| nvarchar(0) | Same as nchar(0) | Same as nchar(0) |\n| nchar(n) | Written as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| nvarchar(n) | Written as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding. The byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| smallint | Written as an integer of 2\u2011byte length. (A binary format.) | Read as integer of 2\u2011byte length. (A binary format) |\n| text(0) | Written as a variable length string. If a delimiter is specified, it is written after the value. If the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding. Copy into using text(0) format is the way to get variable width output with no padding. | Read as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value |\n| text(n) | Written as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding. | Reads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded. |\n| varchar(0) | Same as varchar(n), where n is the display length of the corresponding table column. | Read as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |",
            "| varchar(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length. | Read as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |",
            "Note: The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\n\nFor user-defined data types (UDTs), use char or varchar.\n\nCertainly. I'll create a single Markdown (.md) file based on the provided documentation, focusing on formatting the content without modifying it. Here's the Markdown version:\n\n### Delimiters in the Data File\n\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\n\n| Delimiter | Description |\n|-----------|-------------|\n| nl | Newline character |\n| tab | Tab character |\n| sp | Space |\n| csv | Comma separated values |\n| ssv | Semicolon separated values |\n| nul or null | Null/zero character |\n| comma | Comma |\n| colon | Colon |\n| dash | Dash |\n| lparen | Left parenthesis |\n| rparen | Right parenthesis |\n| X | Any non-numeric character |\n\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\n\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\n\n## CSV and SSV Delimiters\n\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\n\nThe rules for a CSV-delimited field are:\n\n- The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n- Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\n  ```\n  \"There is a double quote \"\" here\"\n  ```\n\n  is translated to the table value:\n\n  ```\n  There is a double quote \" here\n  ```\n\n  Whitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\n- Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\n\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\n\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \"counted\" formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)\n\nCopy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\n\n## With Null Clause for Copy\n\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\n\n### With Null (value) Clause\n\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\n\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.",
            "To prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\n\nFor example, this example of a value is incorrect:\n\n```\nc0comma with null(0)\n```\n\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\n\n```\nc0comma with null('0')\n```\n\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\n\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\n\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\n\n```sql\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\n```\n\nThe correct version specifies a 4-character format for the column.\n\n```sql\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\n```\n\n### With Null Clause Omitting Value\n\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\n\n## Filename Specification for Copy\n\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\n\nUNIX: For copy into, if the file already exists, copy overwrites it.\n\n## Windows File Types for Copy\n\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\n\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\n\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\n\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\n\nThe binary-copy forms (copy () from or copy () into) use binary mode.\n\nNote: Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.\n\nCopy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\n\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\n\n## With Clause for Copy\n\nValid with clause options for the copy statement are as follows:\n\n### On_error=TERMINATE|CONTINUE\n\nDirects copy to continue after encountering conversion errors.\n\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\n\nBy default, copy terminates when an error occurs while converting between table format and file format\n\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\n\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\n\n### Error_count=n\n\nSpecifies how many errors can occur before processing terminates.\n\nDefault: 1.\n\nIf on_error is set to continue, setting error_count has no effect.",
            "Default: 1.\n\nIf on_error is set to continue, setting error_count has no effect.\n\n### Log='filename'\n\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\n\nLogging works as follows:\n\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\n\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\n\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\n\n### Rollback=ENABLED|DISABLED\n\nEnables or disables rollback, as follows:\n\n- ENABLED: Directs the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\n- DISABLED: Retains the appended rows.\n\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\n\nDefault: ENABLED\n\nWhen copying to a file, the with rollback clause has no effect.\n\n### Row_estimate\n\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\n\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\n\n## Permissions\n\nTo use the copy statement, one of the following must apply:\n\n- You own the table.\n- The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n- You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\n\n## Locking\n\n- When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n- When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n- When performing a non-bulk copy into a table, the DBMS server takes an \"intent exclusive\" lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\n\n## Restrictions and Considerations\n\n- Copy cannot be used to add data to a view, index, or system catalog.\n- When copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\n- When copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\n- The copy statement does not fire any rules defined against the table.\n- Values cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\n- Copy treats a present-but-empty field in the data file as:\n  - A blank default for character-based columns\n  - A zero default for numeric columns\n  - December 31 00-1 for date and timestamp columns\n  - 00:00:00 for time columns (and the time component in a timestamp)",
            "For example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\n\n## Related Statements\n\n- Create Table Statement\n- Modify Statement\n\n## Examples--Copy Statement\n\nThe following examples illustrate the correct use of the copy statement:\n\n1. In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\n\n   ```\n   ename     char(15)\n   age       integer4\n   dept      char(10)\n   comment   varchar(20)\n   ```\n\n   The emp.txt file contains the following data:\n\n   ```\n   Jones,J. 32 Anytown,USA toy,00017A This is a comment\n   Smith,P. 41 New York,NY admin,00015 Another comment\n   ```\n\n   The following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\n   - A dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\n   - The department field is delimited by a comma.\n   - The comment field is a variable-length varchar field, preceded by a five-character length specifier.\n\n2. Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\n\n   ```sql\n   copy table employee (eno=integer2, ename=char(10),\n       age=integer2, job=integer2, sal=float4,\n       dept=integer2, xxx=d1)\n       from 'myfile.in';\n   ```\n\n3. Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\n\n   ```sql\n   copy table employee (ename=char(0)comma,\n       eno=char(0)comma, sal= char(0)nl)\n       into 'mfile.out';\n   ```\n\n   Joe Smith , 101, $25000.00\n   \n   Shirley Scott , 102, $30000.00\n\n4. The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\n\n   ```sql\n   copy table employee (ename = text(0)csv,\n       eno = text(0)csv, sal = text(0)csv)\n       into 'mfile.out';\n   ```\n    \n   Joe Smith,101,$25000.00\n   Shirley Scott,102,$30000.00\n\n5. Bulk copy the employee table into a file. The resulting data file contains binary data.\n\n   ```sql\n   copy table employee () into 'ourfile.dat';\n   ```\n\n6. Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\n\n   ```sql\n   copy table other_employee_table () from 'ourfile.dat';\n   ```\n\n7. Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\n\n   ```sql\n   copy table acct_recv\n       (acct_name=char(0)'%',\n       address='d0%',\n       credit=char(0)'%' with null('xx'),\n       debit=char(0)'%' with null('xx'),\n       acct_mngr=char(15),\n       xx=d0nl)\n       into 'qtr_result';\n   ```\n\n   Smith Corp%% $12345.00% $-67890.00%Jones\n   ABC Oil %% $54321.00% $-98765.00%Green\n   Spring Omc%%xx %xx %Namroc\n\n8. Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\n\n   ```sql\n   copy table gifts\n       (item_name=char(0)tab,\n       date_recd=char(0)tab,\n       sender=char(20)nl with null('anonymous'))\n       into 'giftdata';\n   ```\n\n   toaster 04-mar-1993 Nicholas\n   sled 10-oct-1993 anonymous\n   rocket 01-dec-1993 Francisco\n\n9. Create a table and load it using bulk copy, specifying structural options.\n\n   ```sql\n   create table mytable (name char 25, ...);\n   \n   modify mytable to hash;\n   \n   copy mytable() from 'myfile' with minpages = 16384,\n   maxpages = 16384, allocation = 16384;\n   ```"
        ]
    },
    {
        "instruction": "How does the `on_error` clause affect the execution of Actian 4GL SQL COPY statements?",
        "input": "",
        "output": "The `on_error` clause in Actian 4GL SQL COPY statements determines what happens when an error occurs during the data copy operation. The possible values for this clause are:\n- TERMINATE: Abort the entire copy process if an error is encountered during execution.\n- CONTINUE: Continue processing the rest of the data while reporting any errors that occur. This option can help ensure that some data is still imported even if errors are encountered along the way.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "# Copy Statement\n\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\n\nThis statement has the following syntax:\n\n```sql\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\n```\n\n## Parameters--Copy Statement\n\nThis statement has the following parameters:\n\n- **table_name**: Specifies an existing table from which data is read or to which data is written.\n- **column_name**: Specifies the column from which data is read or to which data is written.\n- **format**: Specifies the format in which a value is stored in the file.\n- **filename**: Specifies the file from which data is read or to which data is written.\n- **type**: (Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\n\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\n\n- **with_clause**: Consists of the word with, followed by a comma-separated list of one or more of the following items:\n  - on_error = TERMINATE | CONTINUE\n  - error_count = n\n  - rollback = ENABLED | DISABLED\n  - log = 'filename'\n\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\n- allocation = n\n- extend = n\n- fillfactor = n (ISAM, Hash, and Btree only)\n- minpages = n (Hash only)\n- maxpages = n (Hash only)\n- leaffill = n (Btree only)\n- nonleaffill = n (Btree only)\n- row_estimate = n\n\n## Unformatted Copying\n\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\n\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\n\n```sql\ncopy table employee () into 'emp_name';\n```\n\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\n\nNote: An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\n\n## Formatted Copying\n\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\n\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\n\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\n\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\n\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).",
            "The values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.\n\nNote: If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\n\n```sql\ncopy table t (col1=c20, col2=c30, d0=nl) into 't.out':\n```\n\n## Bulk Copying\n\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\n\nThe requirements for performing a bulk copy are:\n\n- The table is not journaled\n- The table has no secondary indexes\n- For storage structures other than heap, the table is empty and occupies fewer than 18 pages\n\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\n\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\n\n## Column Formats for Copy\n\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\n\nNote: When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\n\n### Character (Text) Formats\n\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\n\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\n\nThe subtle differences between the various character formats are described in Copy Format Details.\n\n### Counted Character Formats\n\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\n\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\n\nNote: Nvarchar(0) is not a counted format.\n\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\n\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\n\n### Dummy Format\n\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\n\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\n\n### Unicode Formats\n\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\n\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\n\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\n\n### Binary Formats",
            "### Binary Formats\n\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\n\nCertainly. I'll convert the provided documentation into a Markdown (.md) file format, maintaining the content while adjusting only the formatting. Here's the result:\n\n### Copy Format Details\n\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\n- Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n- When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n- The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\n\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).",
            "| Format | How Stored (copy into) | How Read (copy from) |\n|--------|------------------------|----------------------|\n| boolean | Written as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format) | Same format as copy into |\n| byte(0) | Same as byte(n) where n is the display length of the corresponding table column. | Read as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. |\n| byte(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded. |\n| byte varying(0) | Same as byte varying(n) where n is the display length of the table column. | Read as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |\n| byte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |\n| C0 | Same as Cn where n is the display length of the corresponding table column | Read as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Any control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\. |\n| Cn | Written as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Any control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\. |\n| char(0) | Same as char(n) where n is the display length of the corresponding table column. | Read as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Unlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is. |\n| char(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding. Unlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Unlike C format, char does not convert control characters or tabs. File data is read as is. |\n| D0 | Instead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.) Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed. | Dummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value. Any \\ found in the input means that the next character is to be taken literally, and is not a delimiter. |\n| Dn | Dummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1. | Dummy field. N characters are read and discarded. Copy from does not allow a delimiter specification with a fixed-length dummy field. |\n| date | Written as a date. (A binary format) | Read as a date. (A binary format) |\n| decimal | Written as a decimal number. (A binary format.) | Read as a decimal number. (A binary format) |\n| float | Written as double\u2011precision floating point. (A binary format) | Read as double\u2011precision floating point. (A binary format) |\n| float4 | Written as single\u2011precision floating point. (A binary format) | Read as single\u2011precision floating point. (A binary format) |\n| integer | Written as integer of 4\u2011byte length. (A binary format) | Read as integer of 4\u2011byte length. (A binary format) |",
            "| integer1 | Written as integer of 1\u2011byte length. (A binary format) | Read as integer of 1\u2011byte length. (A binary format) |\n| long byte(0) | Identical to long varchar | Identical to long varchar |\n| long nvarchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). The maximum segment size for the long nvarchar segment is 32727 bytes. The UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment. If a delimiter is specified, it is written immediately following the last segment. | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| long varchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767. The following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long: 5 abcde10 abcdefghij 0 (with a space after the terminating 0 character) (In this example, the data that is in the originating table column is abcdeabcdefghij) | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| money | Written as a scaled floating point value (a money value). (A binary format) | Read as a scaled floating-point values (a money value). (A binary format) |\n| nchar(0) | Written as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value. | Read as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered. |\n| nvarchar(0) | Same as nchar(0) | Same as nchar(0) |\n| nchar(n) | Written as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| nvarchar(n) | Written as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding. The byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| smallint | Written as an integer of 2\u2011byte length. (A binary format.) | Read as integer of 2\u2011byte length. (A binary format) |\n| text(0) | Written as a variable length string. If a delimiter is specified, it is written after the value. If the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding. Copy into using text(0) format is the way to get variable width output with no padding. | Read as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value |\n| text(n) | Written as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding. | Reads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded. |\n| varchar(0) | Same as varchar(n), where n is the display length of the corresponding table column. | Read as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |",
            "| varchar(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length. | Read as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |",
            "Note: The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\n\nFor user-defined data types (UDTs), use char or varchar.\n\nCertainly. I'll create a single Markdown (.md) file based on the provided documentation, focusing on formatting the content without modifying it. Here's the Markdown version:\n\n### Delimiters in the Data File\n\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\n\n| Delimiter | Description |\n|-----------|-------------|\n| nl | Newline character |\n| tab | Tab character |\n| sp | Space |\n| csv | Comma separated values |\n| ssv | Semicolon separated values |\n| nul or null | Null/zero character |\n| comma | Comma |\n| colon | Colon |\n| dash | Dash |\n| lparen | Left parenthesis |\n| rparen | Right parenthesis |\n| X | Any non-numeric character |\n\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\n\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\n\n## CSV and SSV Delimiters\n\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\n\nThe rules for a CSV-delimited field are:\n\n- The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n- Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\n  ```\n  \"There is a double quote \"\" here\"\n  ```\n\n  is translated to the table value:\n\n  ```\n  There is a double quote \" here\n  ```\n\n  Whitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\n- Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\n\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\n\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \"counted\" formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)\n\nCopy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\n\n## With Null Clause for Copy\n\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\n\n### With Null (value) Clause\n\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\n\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.",
            "To prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\n\nFor example, this example of a value is incorrect:\n\n```\nc0comma with null(0)\n```\n\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\n\n```\nc0comma with null('0')\n```\n\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\n\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\n\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\n\n```sql\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\n```\n\nThe correct version specifies a 4-character format for the column.\n\n```sql\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\n```\n\n### With Null Clause Omitting Value\n\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\n\n## Filename Specification for Copy\n\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\n\nUNIX: For copy into, if the file already exists, copy overwrites it.\n\n## Windows File Types for Copy\n\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\n\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\n\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\n\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\n\nThe binary-copy forms (copy () from or copy () into) use binary mode.\n\nNote: Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.\n\nCopy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\n\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\n\n## With Clause for Copy\n\nValid with clause options for the copy statement are as follows:\n\n### On_error=TERMINATE|CONTINUE\n\nDirects copy to continue after encountering conversion errors.\n\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\n\nBy default, copy terminates when an error occurs while converting between table format and file format\n\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\n\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\n\n### Error_count=n\n\nSpecifies how many errors can occur before processing terminates.\n\nDefault: 1.\n\nIf on_error is set to continue, setting error_count has no effect.",
            "Default: 1.\n\nIf on_error is set to continue, setting error_count has no effect.\n\n### Log='filename'\n\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\n\nLogging works as follows:\n\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\n\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\n\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\n\n### Rollback=ENABLED|DISABLED\n\nEnables or disables rollback, as follows:\n\n- ENABLED: Directs the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\n- DISABLED: Retains the appended rows.\n\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\n\nDefault: ENABLED\n\nWhen copying to a file, the with rollback clause has no effect.\n\n### Row_estimate\n\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\n\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\n\n## Permissions\n\nTo use the copy statement, one of the following must apply:\n\n- You own the table.\n- The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n- You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\n\n## Locking\n\n- When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n- When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n- When performing a non-bulk copy into a table, the DBMS server takes an \"intent exclusive\" lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\n\n## Restrictions and Considerations\n\n- Copy cannot be used to add data to a view, index, or system catalog.\n- When copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\n- When copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\n- The copy statement does not fire any rules defined against the table.\n- Values cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\n- Copy treats a present-but-empty field in the data file as:\n  - A blank default for character-based columns\n  - A zero default for numeric columns\n  - December 31 00-1 for date and timestamp columns\n  - 00:00:00 for time columns (and the time component in a timestamp)",
            "For example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\n\n## Related Statements\n\n- Create Table Statement\n- Modify Statement\n\n## Examples--Copy Statement\n\nThe following examples illustrate the correct use of the copy statement:\n\n1. In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\n\n   ```\n   ename     char(15)\n   age       integer4\n   dept      char(10)\n   comment   varchar(20)\n   ```\n\n   The emp.txt file contains the following data:\n\n   ```\n   Jones,J. 32 Anytown,USA toy,00017A This is a comment\n   Smith,P. 41 New York,NY admin,00015 Another comment\n   ```\n\n   The following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\n   - A dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\n   - The department field is delimited by a comma.\n   - The comment field is a variable-length varchar field, preceded by a five-character length specifier.\n\n2. Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\n\n   ```sql\n   copy table employee (eno=integer2, ename=char(10),\n       age=integer2, job=integer2, sal=float4,\n       dept=integer2, xxx=d1)\n       from 'myfile.in';\n   ```\n\n3. Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\n\n   ```sql\n   copy table employee (ename=char(0)comma,\n       eno=char(0)comma, sal= char(0)nl)\n       into 'mfile.out';\n   ```\n\n   Joe Smith , 101, $25000.00\n   \n   Shirley Scott , 102, $30000.00\n\n4. The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\n\n   ```sql\n   copy table employee (ename = text(0)csv,\n       eno = text(0)csv, sal = text(0)csv)\n       into 'mfile.out';\n   ```\n    \n   Joe Smith,101,$25000.00\n   Shirley Scott,102,$30000.00\n\n5. Bulk copy the employee table into a file. The resulting data file contains binary data.\n\n   ```sql\n   copy table employee () into 'ourfile.dat';\n   ```\n\n6. Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\n\n   ```sql\n   copy table other_employee_table () from 'ourfile.dat';\n   ```\n\n7. Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\n\n   ```sql\n   copy table acct_recv\n       (acct_name=char(0)'%',\n       address='d0%',\n       credit=char(0)'%' with null('xx'),\n       debit=char(0)'%' with null('xx'),\n       acct_mngr=char(15),\n       xx=d0nl)\n       into 'qtr_result';\n   ```\n\n   Smith Corp%% $12345.00% $-67890.00%Jones\n   ABC Oil %% $54321.00% $-98765.00%Green\n   Spring Omc%%xx %xx %Namroc\n\n8. Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\n\n   ```sql\n   copy table gifts\n       (item_name=char(0)tab,\n       date_recd=char(0)tab,\n       sender=char(20)nl with null('anonymous'))\n       into 'giftdata';\n   ```\n\n   toaster 04-mar-1993 Nicholas\n   sled 10-oct-1993 anonymous\n   rocket 01-dec-1993 Francisco\n\n9. Create a table and load it using bulk copy, specifying structural options.\n\n   ```sql\n   create table mytable (name char 25, ...);\n   \n   modify mytable to hash;\n   \n   copy mytable() from 'myfile' with minpages = 16384,\n   maxpages = 16384, allocation = 16384;\n   ```"
        ]
    },
    {
        "instruction": "What is unformatted copying in Actian 4GL SQL COPY statements and when would it be useful?",
        "input": "",
        "output": "Unformatted copying is a feature that copies all rows of an existing table into a file without conversion or formatting. This operation skips the process of defining individual columns and their types in the COPY statement, which can save time when dealing with large amounts of data where column definitions are known to be consistent. It's especially useful when you need to quickly create a backup or transfer large volumes of data without modifying any existing formats.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "# Copy Statement\n\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\n\nThis statement has the following syntax:\n\n```sql\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\n```\n\n## Parameters--Copy Statement\n\nThis statement has the following parameters:\n\n- **table_name**: Specifies an existing table from which data is read or to which data is written.\n- **column_name**: Specifies the column from which data is read or to which data is written.\n- **format**: Specifies the format in which a value is stored in the file.\n- **filename**: Specifies the file from which data is read or to which data is written.\n- **type**: (Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\n\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\n\n- **with_clause**: Consists of the word with, followed by a comma-separated list of one or more of the following items:\n  - on_error = TERMINATE | CONTINUE\n  - error_count = n\n  - rollback = ENABLED | DISABLED\n  - log = 'filename'\n\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\n- allocation = n\n- extend = n\n- fillfactor = n (ISAM, Hash, and Btree only)\n- minpages = n (Hash only)\n- maxpages = n (Hash only)\n- leaffill = n (Btree only)\n- nonleaffill = n (Btree only)\n- row_estimate = n\n\n## Unformatted Copying\n\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\n\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\n\n```sql\ncopy table employee () into 'emp_name';\n```\n\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\n\nNote: An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\n\n## Formatted Copying\n\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\n\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\n\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\n\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\n\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).",
            "The values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.\n\nNote: If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\n\n```sql\ncopy table t (col1=c20, col2=c30, d0=nl) into 't.out':\n```\n\n## Bulk Copying\n\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\n\nThe requirements for performing a bulk copy are:\n\n- The table is not journaled\n- The table has no secondary indexes\n- For storage structures other than heap, the table is empty and occupies fewer than 18 pages\n\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\n\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\n\n## Column Formats for Copy\n\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\n\nNote: When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\n\n### Character (Text) Formats\n\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\n\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\n\nThe subtle differences between the various character formats are described in Copy Format Details.\n\n### Counted Character Formats\n\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\n\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\n\nNote: Nvarchar(0) is not a counted format.\n\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\n\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\n\n### Dummy Format\n\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\n\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\n\n### Unicode Formats\n\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\n\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\n\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\n\n### Binary Formats",
            "### Binary Formats\n\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\n\nCertainly. I'll convert the provided documentation into a Markdown (.md) file format, maintaining the content while adjusting only the formatting. Here's the result:\n\n### Copy Format Details\n\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\n- Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n- When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n- The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\n\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).",
            "| Format | How Stored (copy into) | How Read (copy from) |\n|--------|------------------------|----------------------|\n| boolean | Written as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format) | Same format as copy into |\n| byte(0) | Same as byte(n) where n is the display length of the corresponding table column. | Read as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. |\n| byte(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded. |\n| byte varying(0) | Same as byte varying(n) where n is the display length of the table column. | Read as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |\n| byte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |\n| C0 | Same as Cn where n is the display length of the corresponding table column | Read as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Any control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\. |\n| Cn | Written as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Any control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\. |\n| char(0) | Same as char(n) where n is the display length of the corresponding table column. | Read as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Unlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is. |\n| char(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding. Unlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Unlike C format, char does not convert control characters or tabs. File data is read as is. |\n| D0 | Instead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.) Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed. | Dummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value. Any \\ found in the input means that the next character is to be taken literally, and is not a delimiter. |\n| Dn | Dummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1. | Dummy field. N characters are read and discarded. Copy from does not allow a delimiter specification with a fixed-length dummy field. |\n| date | Written as a date. (A binary format) | Read as a date. (A binary format) |\n| decimal | Written as a decimal number. (A binary format.) | Read as a decimal number. (A binary format) |\n| float | Written as double\u2011precision floating point. (A binary format) | Read as double\u2011precision floating point. (A binary format) |\n| float4 | Written as single\u2011precision floating point. (A binary format) | Read as single\u2011precision floating point. (A binary format) |\n| integer | Written as integer of 4\u2011byte length. (A binary format) | Read as integer of 4\u2011byte length. (A binary format) |",
            "| integer1 | Written as integer of 1\u2011byte length. (A binary format) | Read as integer of 1\u2011byte length. (A binary format) |\n| long byte(0) | Identical to long varchar | Identical to long varchar |\n| long nvarchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). The maximum segment size for the long nvarchar segment is 32727 bytes. The UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment. If a delimiter is specified, it is written immediately following the last segment. | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| long varchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767. The following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long: 5 abcde10 abcdefghij 0 (with a space after the terminating 0 character) (In this example, the data that is in the originating table column is abcdeabcdefghij) | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| money | Written as a scaled floating point value (a money value). (A binary format) | Read as a scaled floating-point values (a money value). (A binary format) |\n| nchar(0) | Written as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value. | Read as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered. |\n| nvarchar(0) | Same as nchar(0) | Same as nchar(0) |\n| nchar(n) | Written as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| nvarchar(n) | Written as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding. The byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| smallint | Written as an integer of 2\u2011byte length. (A binary format.) | Read as integer of 2\u2011byte length. (A binary format) |\n| text(0) | Written as a variable length string. If a delimiter is specified, it is written after the value. If the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding. Copy into using text(0) format is the way to get variable width output with no padding. | Read as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value |\n| text(n) | Written as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding. | Reads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded. |\n| varchar(0) | Same as varchar(n), where n is the display length of the corresponding table column. | Read as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |",
            "| varchar(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length. | Read as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |",
            "Note: The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\n\nFor user-defined data types (UDTs), use char or varchar.\n\nCertainly. I'll create a single Markdown (.md) file based on the provided documentation, focusing on formatting the content without modifying it. Here's the Markdown version:\n\n### Delimiters in the Data File\n\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\n\n| Delimiter | Description |\n|-----------|-------------|\n| nl | Newline character |\n| tab | Tab character |\n| sp | Space |\n| csv | Comma separated values |\n| ssv | Semicolon separated values |\n| nul or null | Null/zero character |\n| comma | Comma |\n| colon | Colon |\n| dash | Dash |\n| lparen | Left parenthesis |\n| rparen | Right parenthesis |\n| X | Any non-numeric character |\n\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\n\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\n\n## CSV and SSV Delimiters\n\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\n\nThe rules for a CSV-delimited field are:\n\n- The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n- Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\n  ```\n  \"There is a double quote \"\" here\"\n  ```\n\n  is translated to the table value:\n\n  ```\n  There is a double quote \" here\n  ```\n\n  Whitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\n- Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\n\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\n\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \"counted\" formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)\n\nCopy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\n\n## With Null Clause for Copy\n\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\n\n### With Null (value) Clause\n\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\n\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.",
            "To prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\n\nFor example, this example of a value is incorrect:\n\n```\nc0comma with null(0)\n```\n\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\n\n```\nc0comma with null('0')\n```\n\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\n\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\n\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\n\n```sql\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\n```\n\nThe correct version specifies a 4-character format for the column.\n\n```sql\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\n```\n\n### With Null Clause Omitting Value\n\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\n\n## Filename Specification for Copy\n\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\n\nUNIX: For copy into, if the file already exists, copy overwrites it.\n\n## Windows File Types for Copy\n\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\n\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\n\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\n\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\n\nThe binary-copy forms (copy () from or copy () into) use binary mode.\n\nNote: Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.\n\nCopy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\n\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\n\n## With Clause for Copy\n\nValid with clause options for the copy statement are as follows:\n\n### On_error=TERMINATE|CONTINUE\n\nDirects copy to continue after encountering conversion errors.\n\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\n\nBy default, copy terminates when an error occurs while converting between table format and file format\n\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\n\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\n\n### Error_count=n\n\nSpecifies how many errors can occur before processing terminates.\n\nDefault: 1.\n\nIf on_error is set to continue, setting error_count has no effect.",
            "Default: 1.\n\nIf on_error is set to continue, setting error_count has no effect.\n\n### Log='filename'\n\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\n\nLogging works as follows:\n\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\n\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\n\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\n\n### Rollback=ENABLED|DISABLED\n\nEnables or disables rollback, as follows:\n\n- ENABLED: Directs the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\n- DISABLED: Retains the appended rows.\n\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\n\nDefault: ENABLED\n\nWhen copying to a file, the with rollback clause has no effect.\n\n### Row_estimate\n\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\n\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\n\n## Permissions\n\nTo use the copy statement, one of the following must apply:\n\n- You own the table.\n- The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n- You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\n\n## Locking\n\n- When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n- When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n- When performing a non-bulk copy into a table, the DBMS server takes an \"intent exclusive\" lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\n\n## Restrictions and Considerations\n\n- Copy cannot be used to add data to a view, index, or system catalog.\n- When copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\n- When copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\n- The copy statement does not fire any rules defined against the table.\n- Values cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\n- Copy treats a present-but-empty field in the data file as:\n  - A blank default for character-based columns\n  - A zero default for numeric columns\n  - December 31 00-1 for date and timestamp columns\n  - 00:00:00 for time columns (and the time component in a timestamp)",
            "For example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\n\n## Related Statements\n\n- Create Table Statement\n- Modify Statement\n\n## Examples--Copy Statement\n\nThe following examples illustrate the correct use of the copy statement:\n\n1. In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\n\n   ```\n   ename     char(15)\n   age       integer4\n   dept      char(10)\n   comment   varchar(20)\n   ```\n\n   The emp.txt file contains the following data:\n\n   ```\n   Jones,J. 32 Anytown,USA toy,00017A This is a comment\n   Smith,P. 41 New York,NY admin,00015 Another comment\n   ```\n\n   The following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\n   - A dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\n   - The department field is delimited by a comma.\n   - The comment field is a variable-length varchar field, preceded by a five-character length specifier.\n\n2. Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\n\n   ```sql\n   copy table employee (eno=integer2, ename=char(10),\n       age=integer2, job=integer2, sal=float4,\n       dept=integer2, xxx=d1)\n       from 'myfile.in';\n   ```\n\n3. Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\n\n   ```sql\n   copy table employee (ename=char(0)comma,\n       eno=char(0)comma, sal= char(0)nl)\n       into 'mfile.out';\n   ```\n\n   Joe Smith , 101, $25000.00\n   \n   Shirley Scott , 102, $30000.00\n\n4. The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\n\n   ```sql\n   copy table employee (ename = text(0)csv,\n       eno = text(0)csv, sal = text(0)csv)\n       into 'mfile.out';\n   ```\n    \n   Joe Smith,101,$25000.00\n   Shirley Scott,102,$30000.00\n\n5. Bulk copy the employee table into a file. The resulting data file contains binary data.\n\n   ```sql\n   copy table employee () into 'ourfile.dat';\n   ```\n\n6. Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\n\n   ```sql\n   copy table other_employee_table () from 'ourfile.dat';\n   ```\n\n7. Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\n\n   ```sql\n   copy table acct_recv\n       (acct_name=char(0)'%',\n       address='d0%',\n       credit=char(0)'%' with null('xx'),\n       debit=char(0)'%' with null('xx'),\n       acct_mngr=char(15),\n       xx=d0nl)\n       into 'qtr_result';\n   ```\n\n   Smith Corp%% $12345.00% $-67890.00%Jones\n   ABC Oil %% $54321.00% $-98765.00%Green\n   Spring Omc%%xx %xx %Namroc\n\n8. Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\n\n   ```sql\n   copy table gifts\n       (item_name=char(0)tab,\n       date_recd=char(0)tab,\n       sender=char(20)nl with null('anonymous'))\n       into 'giftdata';\n   ```\n\n   toaster 04-mar-1993 Nicholas\n   sled 10-oct-1993 anonymous\n   rocket 01-dec-1993 Francisco\n\n9. Create a table and load it using bulk copy, specifying structural options.\n\n   ```sql\n   create table mytable (name char 25, ...);\n   \n   modify mytable to hash;\n   \n   copy mytable() from 'myfile' with minpages = 16384,\n   maxpages = 16384, allocation = 16384;\n   ```"
        ]
    },
    {
        "instruction": "Can you describe the role of quote doubling in Actian 4GL SQL COPY statements?",
        "input": "",
        "output": "Quote doubling is a technique used when copying data from a file to a table using CSV or SSV delimiters in Actian 4GL SQL COPY statements. It allows handling of special characters like commas, newlines, and double quotes that may appear within the data itself. The process works by replacing an unescaped double quote with two consecutive double quotes, which are then treated as a single quote during data import/export operations.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "# Copy Statement\n\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\n\nThis statement has the following syntax:\n\n```sql\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\n```\n\n## Parameters--Copy Statement\n\nThis statement has the following parameters:\n\n- **table_name**: Specifies an existing table from which data is read or to which data is written.\n- **column_name**: Specifies the column from which data is read or to which data is written.\n- **format**: Specifies the format in which a value is stored in the file.\n- **filename**: Specifies the file from which data is read or to which data is written.\n- **type**: (Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\n\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\n\n- **with_clause**: Consists of the word with, followed by a comma-separated list of one or more of the following items:\n  - on_error = TERMINATE | CONTINUE\n  - error_count = n\n  - rollback = ENABLED | DISABLED\n  - log = 'filename'\n\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\n- allocation = n\n- extend = n\n- fillfactor = n (ISAM, Hash, and Btree only)\n- minpages = n (Hash only)\n- maxpages = n (Hash only)\n- leaffill = n (Btree only)\n- nonleaffill = n (Btree only)\n- row_estimate = n\n\n## Unformatted Copying\n\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\n\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\n\n```sql\ncopy table employee () into 'emp_name';\n```\n\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\n\nNote: An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\n\n## Formatted Copying\n\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\n\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\n\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\n\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\n\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).",
            "The values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.\n\nNote: If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\n\n```sql\ncopy table t (col1=c20, col2=c30, d0=nl) into 't.out':\n```\n\n## Bulk Copying\n\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\n\nThe requirements for performing a bulk copy are:\n\n- The table is not journaled\n- The table has no secondary indexes\n- For storage structures other than heap, the table is empty and occupies fewer than 18 pages\n\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\n\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\n\n## Column Formats for Copy\n\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\n\nNote: When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\n\n### Character (Text) Formats\n\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\n\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\n\nThe subtle differences between the various character formats are described in Copy Format Details.\n\n### Counted Character Formats\n\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\n\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\n\nNote: Nvarchar(0) is not a counted format.\n\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\n\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\n\n### Dummy Format\n\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\n\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\n\n### Unicode Formats\n\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\n\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\n\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\n\n### Binary Formats",
            "### Binary Formats\n\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\n\nCertainly. I'll convert the provided documentation into a Markdown (.md) file format, maintaining the content while adjusting only the formatting. Here's the result:\n\n### Copy Format Details\n\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\n- Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n- When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n- The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\n\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).",
            "| Format | How Stored (copy into) | How Read (copy from) |\n|--------|------------------------|----------------------|\n| boolean | Written as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format) | Same format as copy into |\n| byte(0) | Same as byte(n) where n is the display length of the corresponding table column. | Read as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. |\n| byte(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded. |\n| byte varying(0) | Same as byte varying(n) where n is the display length of the table column. | Read as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |\n| byte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |\n| C0 | Same as Cn where n is the display length of the corresponding table column | Read as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Any control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\. |\n| Cn | Written as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Any control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\. |\n| char(0) | Same as char(n) where n is the display length of the corresponding table column. | Read as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Unlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is. |\n| char(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding. Unlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Unlike C format, char does not convert control characters or tabs. File data is read as is. |\n| D0 | Instead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.) Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed. | Dummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value. Any \\ found in the input means that the next character is to be taken literally, and is not a delimiter. |\n| Dn | Dummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1. | Dummy field. N characters are read and discarded. Copy from does not allow a delimiter specification with a fixed-length dummy field. |\n| date | Written as a date. (A binary format) | Read as a date. (A binary format) |\n| decimal | Written as a decimal number. (A binary format.) | Read as a decimal number. (A binary format) |\n| float | Written as double\u2011precision floating point. (A binary format) | Read as double\u2011precision floating point. (A binary format) |\n| float4 | Written as single\u2011precision floating point. (A binary format) | Read as single\u2011precision floating point. (A binary format) |\n| integer | Written as integer of 4\u2011byte length. (A binary format) | Read as integer of 4\u2011byte length. (A binary format) |",
            "| integer1 | Written as integer of 1\u2011byte length. (A binary format) | Read as integer of 1\u2011byte length. (A binary format) |\n| long byte(0) | Identical to long varchar | Identical to long varchar |\n| long nvarchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). The maximum segment size for the long nvarchar segment is 32727 bytes. The UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment. If a delimiter is specified, it is written immediately following the last segment. | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| long varchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767. The following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long: 5 abcde10 abcdefghij 0 (with a space after the terminating 0 character) (In this example, the data that is in the originating table column is abcdeabcdefghij) | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| money | Written as a scaled floating point value (a money value). (A binary format) | Read as a scaled floating-point values (a money value). (A binary format) |\n| nchar(0) | Written as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value. | Read as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered. |\n| nvarchar(0) | Same as nchar(0) | Same as nchar(0) |\n| nchar(n) | Written as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| nvarchar(n) | Written as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding. The byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| smallint | Written as an integer of 2\u2011byte length. (A binary format.) | Read as integer of 2\u2011byte length. (A binary format) |\n| text(0) | Written as a variable length string. If a delimiter is specified, it is written after the value. If the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding. Copy into using text(0) format is the way to get variable width output with no padding. | Read as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value |\n| text(n) | Written as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding. | Reads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded. |\n| varchar(0) | Same as varchar(n), where n is the display length of the corresponding table column. | Read as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |",
            "| varchar(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length. | Read as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |",
            "Note: The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\n\nFor user-defined data types (UDTs), use char or varchar.\n\nCertainly. I'll create a single Markdown (.md) file based on the provided documentation, focusing on formatting the content without modifying it. Here's the Markdown version:\n\n### Delimiters in the Data File\n\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\n\n| Delimiter | Description |\n|-----------|-------------|\n| nl | Newline character |\n| tab | Tab character |\n| sp | Space |\n| csv | Comma separated values |\n| ssv | Semicolon separated values |\n| nul or null | Null/zero character |\n| comma | Comma |\n| colon | Colon |\n| dash | Dash |\n| lparen | Left parenthesis |\n| rparen | Right parenthesis |\n| X | Any non-numeric character |\n\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\n\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\n\n## CSV and SSV Delimiters\n\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\n\nThe rules for a CSV-delimited field are:\n\n- The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n- Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\n  ```\n  \"There is a double quote \"\" here\"\n  ```\n\n  is translated to the table value:\n\n  ```\n  There is a double quote \" here\n  ```\n\n  Whitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\n- Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\n\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\n\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \"counted\" formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)\n\nCopy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\n\n## With Null Clause for Copy\n\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\n\n### With Null (value) Clause\n\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\n\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.",
            "To prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\n\nFor example, this example of a value is incorrect:\n\n```\nc0comma with null(0)\n```\n\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\n\n```\nc0comma with null('0')\n```\n\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\n\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\n\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\n\n```sql\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\n```\n\nThe correct version specifies a 4-character format for the column.\n\n```sql\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\n```\n\n### With Null Clause Omitting Value\n\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\n\n## Filename Specification for Copy\n\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\n\nUNIX: For copy into, if the file already exists, copy overwrites it.\n\n## Windows File Types for Copy\n\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\n\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\n\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\n\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\n\nThe binary-copy forms (copy () from or copy () into) use binary mode.\n\nNote: Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.\n\nCopy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\n\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\n\n## With Clause for Copy\n\nValid with clause options for the copy statement are as follows:\n\n### On_error=TERMINATE|CONTINUE\n\nDirects copy to continue after encountering conversion errors.\n\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\n\nBy default, copy terminates when an error occurs while converting between table format and file format\n\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\n\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\n\n### Error_count=n\n\nSpecifies how many errors can occur before processing terminates.\n\nDefault: 1.\n\nIf on_error is set to continue, setting error_count has no effect.",
            "Default: 1.\n\nIf on_error is set to continue, setting error_count has no effect.\n\n### Log='filename'\n\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\n\nLogging works as follows:\n\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\n\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\n\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\n\n### Rollback=ENABLED|DISABLED\n\nEnables or disables rollback, as follows:\n\n- ENABLED: Directs the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\n- DISABLED: Retains the appended rows.\n\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\n\nDefault: ENABLED\n\nWhen copying to a file, the with rollback clause has no effect.\n\n### Row_estimate\n\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\n\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\n\n## Permissions\n\nTo use the copy statement, one of the following must apply:\n\n- You own the table.\n- The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n- You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\n\n## Locking\n\n- When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n- When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n- When performing a non-bulk copy into a table, the DBMS server takes an \"intent exclusive\" lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\n\n## Restrictions and Considerations\n\n- Copy cannot be used to add data to a view, index, or system catalog.\n- When copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\n- When copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\n- The copy statement does not fire any rules defined against the table.\n- Values cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\n- Copy treats a present-but-empty field in the data file as:\n  - A blank default for character-based columns\n  - A zero default for numeric columns\n  - December 31 00-1 for date and timestamp columns\n  - 00:00:00 for time columns (and the time component in a timestamp)",
            "For example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\n\n## Related Statements\n\n- Create Table Statement\n- Modify Statement\n\n## Examples--Copy Statement\n\nThe following examples illustrate the correct use of the copy statement:\n\n1. In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\n\n   ```\n   ename     char(15)\n   age       integer4\n   dept      char(10)\n   comment   varchar(20)\n   ```\n\n   The emp.txt file contains the following data:\n\n   ```\n   Jones,J. 32 Anytown,USA toy,00017A This is a comment\n   Smith,P. 41 New York,NY admin,00015 Another comment\n   ```\n\n   The following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\n   - A dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\n   - The department field is delimited by a comma.\n   - The comment field is a variable-length varchar field, preceded by a five-character length specifier.\n\n2. Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\n\n   ```sql\n   copy table employee (eno=integer2, ename=char(10),\n       age=integer2, job=integer2, sal=float4,\n       dept=integer2, xxx=d1)\n       from 'myfile.in';\n   ```\n\n3. Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\n\n   ```sql\n   copy table employee (ename=char(0)comma,\n       eno=char(0)comma, sal= char(0)nl)\n       into 'mfile.out';\n   ```\n\n   Joe Smith , 101, $25000.00\n   \n   Shirley Scott , 102, $30000.00\n\n4. The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\n\n   ```sql\n   copy table employee (ename = text(0)csv,\n       eno = text(0)csv, sal = text(0)csv)\n       into 'mfile.out';\n   ```\n    \n   Joe Smith,101,$25000.00\n   Shirley Scott,102,$30000.00\n\n5. Bulk copy the employee table into a file. The resulting data file contains binary data.\n\n   ```sql\n   copy table employee () into 'ourfile.dat';\n   ```\n\n6. Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\n\n   ```sql\n   copy table other_employee_table () from 'ourfile.dat';\n   ```\n\n7. Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\n\n   ```sql\n   copy table acct_recv\n       (acct_name=char(0)'%',\n       address='d0%',\n       credit=char(0)'%' with null('xx'),\n       debit=char(0)'%' with null('xx'),\n       acct_mngr=char(15),\n       xx=d0nl)\n       into 'qtr_result';\n   ```\n\n   Smith Corp%% $12345.00% $-67890.00%Jones\n   ABC Oil %% $54321.00% $-98765.00%Green\n   Spring Omc%%xx %xx %Namroc\n\n8. Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\n\n   ```sql\n   copy table gifts\n       (item_name=char(0)tab,\n       date_recd=char(0)tab,\n       sender=char(20)nl with null('anonymous'))\n       into 'giftdata';\n   ```\n\n   toaster 04-mar-1993 Nicholas\n   sled 10-oct-1993 anonymous\n   rocket 01-dec-1993 Francisco\n\n9. Create a table and load it using bulk copy, specifying structural options.\n\n   ```sql\n   create table mytable (name char 25, ...);\n   \n   modify mytable to hash;\n   \n   copy mytable() from 'myfile' with minpages = 16384,\n   maxpages = 16384, allocation = 16384;\n   ```"
        ]
    },
    {
        "instruction": "What are the advanced options available in Actian 4GL SQL COPY statements and how can they be used?",
        "input": "",
        "output": "The `WITH_CLAUSE` is an advanced option available in Actian 4GL SQL COPY statements, which allows you to set additional options for the data transfer operation. Options like `ON_ERROR`, `ERROR_COUNT`, `ROLLBACK`, `LOG`, `ALLOCATION`, `EXTEND`, `FILLFACTOR`, `MINPAGES`, `MAXPAGES`, `LEAFILL`, `NONLEAFFILL`, and `ROW_ESTIMATE` can be used to control various aspects of the transfer such as handling errors, log management, table allocation, and fill factors.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "# Copy Statement\n\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\n\nThis statement has the following syntax:\n\n```sql\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\n```\n\n## Parameters--Copy Statement\n\nThis statement has the following parameters:\n\n- **table_name**: Specifies an existing table from which data is read or to which data is written.\n- **column_name**: Specifies the column from which data is read or to which data is written.\n- **format**: Specifies the format in which a value is stored in the file.\n- **filename**: Specifies the file from which data is read or to which data is written.\n- **type**: (Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\n\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\n\n- **with_clause**: Consists of the word with, followed by a comma-separated list of one or more of the following items:\n  - on_error = TERMINATE | CONTINUE\n  - error_count = n\n  - rollback = ENABLED | DISABLED\n  - log = 'filename'\n\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\n- allocation = n\n- extend = n\n- fillfactor = n (ISAM, Hash, and Btree only)\n- minpages = n (Hash only)\n- maxpages = n (Hash only)\n- leaffill = n (Btree only)\n- nonleaffill = n (Btree only)\n- row_estimate = n\n\n## Unformatted Copying\n\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\n\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\n\n```sql\ncopy table employee () into 'emp_name';\n```\n\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\n\nNote: An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\n\n## Formatted Copying\n\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\n\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\n\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\n\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\n\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).",
            "The values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.\n\nNote: If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\n\n```sql\ncopy table t (col1=c20, col2=c30, d0=nl) into 't.out':\n```\n\n## Bulk Copying\n\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\n\nThe requirements for performing a bulk copy are:\n\n- The table is not journaled\n- The table has no secondary indexes\n- For storage structures other than heap, the table is empty and occupies fewer than 18 pages\n\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\n\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\n\n## Column Formats for Copy\n\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\n\nNote: When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\n\n### Character (Text) Formats\n\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\n\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\n\nThe subtle differences between the various character formats are described in Copy Format Details.\n\n### Counted Character Formats\n\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\n\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\n\nNote: Nvarchar(0) is not a counted format.\n\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\n\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\n\n### Dummy Format\n\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\n\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\n\n### Unicode Formats\n\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\n\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\n\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\n\n### Binary Formats",
            "### Binary Formats\n\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\n\nCertainly. I'll convert the provided documentation into a Markdown (.md) file format, maintaining the content while adjusting only the formatting. Here's the result:\n\n### Copy Format Details\n\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\n- Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n- When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n- The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\n\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).",
            "| Format | How Stored (copy into) | How Read (copy from) |\n|--------|------------------------|----------------------|\n| boolean | Written as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format) | Same format as copy into |\n| byte(0) | Same as byte(n) where n is the display length of the corresponding table column. | Read as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. |\n| byte(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded. |\n| byte varying(0) | Same as byte varying(n) where n is the display length of the table column. | Read as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |\n| byte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |\n| C0 | Same as Cn where n is the display length of the corresponding table column | Read as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Any control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\. |\n| Cn | Written as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Any control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\. |\n| char(0) | Same as char(n) where n is the display length of the corresponding table column. | Read as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Unlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is. |\n| char(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding. Unlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Unlike C format, char does not convert control characters or tabs. File data is read as is. |\n| D0 | Instead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.) Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed. | Dummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value. Any \\ found in the input means that the next character is to be taken literally, and is not a delimiter. |\n| Dn | Dummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1. | Dummy field. N characters are read and discarded. Copy from does not allow a delimiter specification with a fixed-length dummy field. |\n| date | Written as a date. (A binary format) | Read as a date. (A binary format) |\n| decimal | Written as a decimal number. (A binary format.) | Read as a decimal number. (A binary format) |\n| float | Written as double\u2011precision floating point. (A binary format) | Read as double\u2011precision floating point. (A binary format) |\n| float4 | Written as single\u2011precision floating point. (A binary format) | Read as single\u2011precision floating point. (A binary format) |\n| integer | Written as integer of 4\u2011byte length. (A binary format) | Read as integer of 4\u2011byte length. (A binary format) |",
            "| integer1 | Written as integer of 1\u2011byte length. (A binary format) | Read as integer of 1\u2011byte length. (A binary format) |\n| long byte(0) | Identical to long varchar | Identical to long varchar |\n| long nvarchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). The maximum segment size for the long nvarchar segment is 32727 bytes. The UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment. If a delimiter is specified, it is written immediately following the last segment. | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| long varchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767. The following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long: 5 abcde10 abcdefghij 0 (with a space after the terminating 0 character) (In this example, the data that is in the originating table column is abcdeabcdefghij) | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| money | Written as a scaled floating point value (a money value). (A binary format) | Read as a scaled floating-point values (a money value). (A binary format) |\n| nchar(0) | Written as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value. | Read as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered. |\n| nvarchar(0) | Same as nchar(0) | Same as nchar(0) |\n| nchar(n) | Written as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| nvarchar(n) | Written as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding. The byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| smallint | Written as an integer of 2\u2011byte length. (A binary format.) | Read as integer of 2\u2011byte length. (A binary format) |\n| text(0) | Written as a variable length string. If a delimiter is specified, it is written after the value. If the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding. Copy into using text(0) format is the way to get variable width output with no padding. | Read as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value |\n| text(n) | Written as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding. | Reads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded. |\n| varchar(0) | Same as varchar(n), where n is the display length of the corresponding table column. | Read as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |",
            "| varchar(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length. | Read as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |",
            "Note: The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\n\nFor user-defined data types (UDTs), use char or varchar.\n\nCertainly. I'll create a single Markdown (.md) file based on the provided documentation, focusing on formatting the content without modifying it. Here's the Markdown version:\n\n### Delimiters in the Data File\n\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\n\n| Delimiter | Description |\n|-----------|-------------|\n| nl | Newline character |\n| tab | Tab character |\n| sp | Space |\n| csv | Comma separated values |\n| ssv | Semicolon separated values |\n| nul or null | Null/zero character |\n| comma | Comma |\n| colon | Colon |\n| dash | Dash |\n| lparen | Left parenthesis |\n| rparen | Right parenthesis |\n| X | Any non-numeric character |\n\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\n\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\n\n## CSV and SSV Delimiters\n\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\n\nThe rules for a CSV-delimited field are:\n\n- The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n- Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\n  ```\n  \"There is a double quote \"\" here\"\n  ```\n\n  is translated to the table value:\n\n  ```\n  There is a double quote \" here\n  ```\n\n  Whitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\n- Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\n\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\n\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \"counted\" formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)\n\nCopy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\n\n## With Null Clause for Copy\n\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\n\n### With Null (value) Clause\n\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\n\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.",
            "To prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\n\nFor example, this example of a value is incorrect:\n\n```\nc0comma with null(0)\n```\n\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\n\n```\nc0comma with null('0')\n```\n\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\n\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\n\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\n\n```sql\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\n```\n\nThe correct version specifies a 4-character format for the column.\n\n```sql\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\n```\n\n### With Null Clause Omitting Value\n\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\n\n## Filename Specification for Copy\n\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\n\nUNIX: For copy into, if the file already exists, copy overwrites it.\n\n## Windows File Types for Copy\n\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\n\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\n\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\n\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\n\nThe binary-copy forms (copy () from or copy () into) use binary mode.\n\nNote: Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.\n\nCopy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\n\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\n\n## With Clause for Copy\n\nValid with clause options for the copy statement are as follows:\n\n### On_error=TERMINATE|CONTINUE\n\nDirects copy to continue after encountering conversion errors.\n\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\n\nBy default, copy terminates when an error occurs while converting between table format and file format\n\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\n\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\n\n### Error_count=n\n\nSpecifies how many errors can occur before processing terminates.\n\nDefault: 1.\n\nIf on_error is set to continue, setting error_count has no effect.",
            "Default: 1.\n\nIf on_error is set to continue, setting error_count has no effect.\n\n### Log='filename'\n\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\n\nLogging works as follows:\n\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\n\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\n\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\n\n### Rollback=ENABLED|DISABLED\n\nEnables or disables rollback, as follows:\n\n- ENABLED: Directs the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\n- DISABLED: Retains the appended rows.\n\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\n\nDefault: ENABLED\n\nWhen copying to a file, the with rollback clause has no effect.\n\n### Row_estimate\n\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\n\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\n\n## Permissions\n\nTo use the copy statement, one of the following must apply:\n\n- You own the table.\n- The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n- You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\n\n## Locking\n\n- When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n- When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n- When performing a non-bulk copy into a table, the DBMS server takes an \"intent exclusive\" lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\n\n## Restrictions and Considerations\n\n- Copy cannot be used to add data to a view, index, or system catalog.\n- When copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\n- When copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\n- The copy statement does not fire any rules defined against the table.\n- Values cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\n- Copy treats a present-but-empty field in the data file as:\n  - A blank default for character-based columns\n  - A zero default for numeric columns\n  - December 31 00-1 for date and timestamp columns\n  - 00:00:00 for time columns (and the time component in a timestamp)",
            "For example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\n\n## Related Statements\n\n- Create Table Statement\n- Modify Statement\n\n## Examples--Copy Statement\n\nThe following examples illustrate the correct use of the copy statement:\n\n1. In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\n\n   ```\n   ename     char(15)\n   age       integer4\n   dept      char(10)\n   comment   varchar(20)\n   ```\n\n   The emp.txt file contains the following data:\n\n   ```\n   Jones,J. 32 Anytown,USA toy,00017A This is a comment\n   Smith,P. 41 New York,NY admin,00015 Another comment\n   ```\n\n   The following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\n   - A dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\n   - The department field is delimited by a comma.\n   - The comment field is a variable-length varchar field, preceded by a five-character length specifier.\n\n2. Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\n\n   ```sql\n   copy table employee (eno=integer2, ename=char(10),\n       age=integer2, job=integer2, sal=float4,\n       dept=integer2, xxx=d1)\n       from 'myfile.in';\n   ```\n\n3. Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\n\n   ```sql\n   copy table employee (ename=char(0)comma,\n       eno=char(0)comma, sal= char(0)nl)\n       into 'mfile.out';\n   ```\n\n   Joe Smith , 101, $25000.00\n   \n   Shirley Scott , 102, $30000.00\n\n4. The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\n\n   ```sql\n   copy table employee (ename = text(0)csv,\n       eno = text(0)csv, sal = text(0)csv)\n       into 'mfile.out';\n   ```\n    \n   Joe Smith,101,$25000.00\n   Shirley Scott,102,$30000.00\n\n5. Bulk copy the employee table into a file. The resulting data file contains binary data.\n\n   ```sql\n   copy table employee () into 'ourfile.dat';\n   ```\n\n6. Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\n\n   ```sql\n   copy table other_employee_table () from 'ourfile.dat';\n   ```\n\n7. Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\n\n   ```sql\n   copy table acct_recv\n       (acct_name=char(0)'%',\n       address='d0%',\n       credit=char(0)'%' with null('xx'),\n       debit=char(0)'%' with null('xx'),\n       acct_mngr=char(15),\n       xx=d0nl)\n       into 'qtr_result';\n   ```\n\n   Smith Corp%% $12345.00% $-67890.00%Jones\n   ABC Oil %% $54321.00% $-98765.00%Green\n   Spring Omc%%xx %xx %Namroc\n\n8. Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\n\n   ```sql\n   copy table gifts\n       (item_name=char(0)tab,\n       date_recd=char(0)tab,\n       sender=char(20)nl with null('anonymous'))\n       into 'giftdata';\n   ```\n\n   toaster 04-mar-1993 Nicholas\n   sled 10-oct-1993 anonymous\n   rocket 01-dec-1993 Francisco\n\n9. Create a table and load it using bulk copy, specifying structural options.\n\n   ```sql\n   create table mytable (name char 25, ...);\n   \n   modify mytable to hash;\n   \n   copy mytable() from 'myfile' with minpages = 16384,\n   maxpages = 16384, allocation = 16384;\n   ```"
        ]
    },
    {
        "instruction": "What are unformatted copying and formatted copying in Actian 4GL SQL COPY statements?",
        "input": "",
        "output": "In Actian 4GL SQL COPY statements, unformatted copying refers to the process of copying all rows of a table into a file without any conversion or formatting. On the other hand, formatted copying allows you to copy data between files and tables where the type, number, and order of columns can differ from each other by specifying a list of columns in the `COPY` statement.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "# Copy Statement\n\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\n\nThis statement has the following syntax:\n\n```sql\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\n```\n\n## Parameters--Copy Statement\n\nThis statement has the following parameters:\n\n- **table_name**: Specifies an existing table from which data is read or to which data is written.\n- **column_name**: Specifies the column from which data is read or to which data is written.\n- **format**: Specifies the format in which a value is stored in the file.\n- **filename**: Specifies the file from which data is read or to which data is written.\n- **type**: (Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\n\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\n\n- **with_clause**: Consists of the word with, followed by a comma-separated list of one or more of the following items:\n  - on_error = TERMINATE | CONTINUE\n  - error_count = n\n  - rollback = ENABLED | DISABLED\n  - log = 'filename'\n\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\n- allocation = n\n- extend = n\n- fillfactor = n (ISAM, Hash, and Btree only)\n- minpages = n (Hash only)\n- maxpages = n (Hash only)\n- leaffill = n (Btree only)\n- nonleaffill = n (Btree only)\n- row_estimate = n\n\n## Unformatted Copying\n\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\n\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\n\n```sql\ncopy table employee () into 'emp_name';\n```\n\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\n\nNote: An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\n\n## Formatted Copying\n\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\n\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\n\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\n\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\n\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).",
            "The values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.\n\nNote: If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\n\n```sql\ncopy table t (col1=c20, col2=c30, d0=nl) into 't.out':\n```\n\n## Bulk Copying\n\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\n\nThe requirements for performing a bulk copy are:\n\n- The table is not journaled\n- The table has no secondary indexes\n- For storage structures other than heap, the table is empty and occupies fewer than 18 pages\n\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\n\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\n\n## Column Formats for Copy\n\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\n\nNote: When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\n\n### Character (Text) Formats\n\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\n\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\n\nThe subtle differences between the various character formats are described in Copy Format Details.\n\n### Counted Character Formats\n\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\n\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\n\nNote: Nvarchar(0) is not a counted format.\n\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\n\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\n\n### Dummy Format\n\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\n\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\n\n### Unicode Formats\n\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\n\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\n\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\n\n### Binary Formats",
            "### Binary Formats\n\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\n\nCertainly. I'll convert the provided documentation into a Markdown (.md) file format, maintaining the content while adjusting only the formatting. Here's the result:\n\n### Copy Format Details\n\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\n- Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n- When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n- The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\n\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).",
            "| Format | How Stored (copy into) | How Read (copy from) |\n|--------|------------------------|----------------------|\n| boolean | Written as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format) | Same format as copy into |\n| byte(0) | Same as byte(n) where n is the display length of the corresponding table column. | Read as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. |\n| byte(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded. |\n| byte varying(0) | Same as byte varying(n) where n is the display length of the table column. | Read as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |\n| byte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |\n| C0 | Same as Cn where n is the display length of the corresponding table column | Read as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Any control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\. |\n| Cn | Written as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Any control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\. |\n| char(0) | Same as char(n) where n is the display length of the corresponding table column. | Read as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Unlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is. |\n| char(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding. Unlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Unlike C format, char does not convert control characters or tabs. File data is read as is. |\n| D0 | Instead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.) Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed. | Dummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value. Any \\ found in the input means that the next character is to be taken literally, and is not a delimiter. |\n| Dn | Dummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1. | Dummy field. N characters are read and discarded. Copy from does not allow a delimiter specification with a fixed-length dummy field. |\n| date | Written as a date. (A binary format) | Read as a date. (A binary format) |\n| decimal | Written as a decimal number. (A binary format.) | Read as a decimal number. (A binary format) |\n| float | Written as double\u2011precision floating point. (A binary format) | Read as double\u2011precision floating point. (A binary format) |\n| float4 | Written as single\u2011precision floating point. (A binary format) | Read as single\u2011precision floating point. (A binary format) |\n| integer | Written as integer of 4\u2011byte length. (A binary format) | Read as integer of 4\u2011byte length. (A binary format) |",
            "| integer1 | Written as integer of 1\u2011byte length. (A binary format) | Read as integer of 1\u2011byte length. (A binary format) |\n| long byte(0) | Identical to long varchar | Identical to long varchar |\n| long nvarchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). The maximum segment size for the long nvarchar segment is 32727 bytes. The UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment. If a delimiter is specified, it is written immediately following the last segment. | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| long varchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767. The following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long: 5 abcde10 abcdefghij 0 (with a space after the terminating 0 character) (In this example, the data that is in the originating table column is abcdeabcdefghij) | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| money | Written as a scaled floating point value (a money value). (A binary format) | Read as a scaled floating-point values (a money value). (A binary format) |\n| nchar(0) | Written as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value. | Read as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered. |\n| nvarchar(0) | Same as nchar(0) | Same as nchar(0) |\n| nchar(n) | Written as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| nvarchar(n) | Written as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding. The byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| smallint | Written as an integer of 2\u2011byte length. (A binary format.) | Read as integer of 2\u2011byte length. (A binary format) |\n| text(0) | Written as a variable length string. If a delimiter is specified, it is written after the value. If the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding. Copy into using text(0) format is the way to get variable width output with no padding. | Read as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value |\n| text(n) | Written as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding. | Reads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded. |\n| varchar(0) | Same as varchar(n), where n is the display length of the corresponding table column. | Read as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |",
            "| varchar(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length. | Read as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |",
            "Note: The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\n\nFor user-defined data types (UDTs), use char or varchar.\n\nCertainly. I'll create a single Markdown (.md) file based on the provided documentation, focusing on formatting the content without modifying it. Here's the Markdown version:\n\n### Delimiters in the Data File\n\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\n\n| Delimiter | Description |\n|-----------|-------------|\n| nl | Newline character |\n| tab | Tab character |\n| sp | Space |\n| csv | Comma separated values |\n| ssv | Semicolon separated values |\n| nul or null | Null/zero character |\n| comma | Comma |\n| colon | Colon |\n| dash | Dash |\n| lparen | Left parenthesis |\n| rparen | Right parenthesis |\n| X | Any non-numeric character |\n\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\n\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\n\n## CSV and SSV Delimiters\n\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\n\nThe rules for a CSV-delimited field are:\n\n- The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n- Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\n  ```\n  \"There is a double quote \"\" here\"\n  ```\n\n  is translated to the table value:\n\n  ```\n  There is a double quote \" here\n  ```\n\n  Whitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\n- Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\n\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\n\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \"counted\" formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)\n\nCopy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\n\n## With Null Clause for Copy\n\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\n\n### With Null (value) Clause\n\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\n\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.",
            "To prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\n\nFor example, this example of a value is incorrect:\n\n```\nc0comma with null(0)\n```\n\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\n\n```\nc0comma with null('0')\n```\n\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\n\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\n\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\n\n```sql\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\n```\n\nThe correct version specifies a 4-character format for the column.\n\n```sql\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\n```\n\n### With Null Clause Omitting Value\n\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\n\n## Filename Specification for Copy\n\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\n\nUNIX: For copy into, if the file already exists, copy overwrites it.\n\n## Windows File Types for Copy\n\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\n\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\n\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\n\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\n\nThe binary-copy forms (copy () from or copy () into) use binary mode.\n\nNote: Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.\n\nCopy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\n\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\n\n## With Clause for Copy\n\nValid with clause options for the copy statement are as follows:\n\n### On_error=TERMINATE|CONTINUE\n\nDirects copy to continue after encountering conversion errors.\n\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\n\nBy default, copy terminates when an error occurs while converting between table format and file format\n\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\n\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\n\n### Error_count=n\n\nSpecifies how many errors can occur before processing terminates.\n\nDefault: 1.\n\nIf on_error is set to continue, setting error_count has no effect.",
            "Default: 1.\n\nIf on_error is set to continue, setting error_count has no effect.\n\n### Log='filename'\n\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\n\nLogging works as follows:\n\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\n\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\n\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\n\n### Rollback=ENABLED|DISABLED\n\nEnables or disables rollback, as follows:\n\n- ENABLED: Directs the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\n- DISABLED: Retains the appended rows.\n\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\n\nDefault: ENABLED\n\nWhen copying to a file, the with rollback clause has no effect.\n\n### Row_estimate\n\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\n\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\n\n## Permissions\n\nTo use the copy statement, one of the following must apply:\n\n- You own the table.\n- The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n- You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\n\n## Locking\n\n- When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n- When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n- When performing a non-bulk copy into a table, the DBMS server takes an \"intent exclusive\" lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\n\n## Restrictions and Considerations\n\n- Copy cannot be used to add data to a view, index, or system catalog.\n- When copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\n- When copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\n- The copy statement does not fire any rules defined against the table.\n- Values cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\n- Copy treats a present-but-empty field in the data file as:\n  - A blank default for character-based columns\n  - A zero default for numeric columns\n  - December 31 00-1 for date and timestamp columns\n  - 00:00:00 for time columns (and the time component in a timestamp)",
            "For example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\n\n## Related Statements\n\n- Create Table Statement\n- Modify Statement\n\n## Examples--Copy Statement\n\nThe following examples illustrate the correct use of the copy statement:\n\n1. In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\n\n   ```\n   ename     char(15)\n   age       integer4\n   dept      char(10)\n   comment   varchar(20)\n   ```\n\n   The emp.txt file contains the following data:\n\n   ```\n   Jones,J. 32 Anytown,USA toy,00017A This is a comment\n   Smith,P. 41 New York,NY admin,00015 Another comment\n   ```\n\n   The following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\n   - A dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\n   - The department field is delimited by a comma.\n   - The comment field is a variable-length varchar field, preceded by a five-character length specifier.\n\n2. Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\n\n   ```sql\n   copy table employee (eno=integer2, ename=char(10),\n       age=integer2, job=integer2, sal=float4,\n       dept=integer2, xxx=d1)\n       from 'myfile.in';\n   ```\n\n3. Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\n\n   ```sql\n   copy table employee (ename=char(0)comma,\n       eno=char(0)comma, sal= char(0)nl)\n       into 'mfile.out';\n   ```\n\n   Joe Smith , 101, $25000.00\n   \n   Shirley Scott , 102, $30000.00\n\n4. The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\n\n   ```sql\n   copy table employee (ename = text(0)csv,\n       eno = text(0)csv, sal = text(0)csv)\n       into 'mfile.out';\n   ```\n    \n   Joe Smith,101,$25000.00\n   Shirley Scott,102,$30000.00\n\n5. Bulk copy the employee table into a file. The resulting data file contains binary data.\n\n   ```sql\n   copy table employee () into 'ourfile.dat';\n   ```\n\n6. Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\n\n   ```sql\n   copy table other_employee_table () from 'ourfile.dat';\n   ```\n\n7. Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\n\n   ```sql\n   copy table acct_recv\n       (acct_name=char(0)'%',\n       address='d0%',\n       credit=char(0)'%' with null('xx'),\n       debit=char(0)'%' with null('xx'),\n       acct_mngr=char(15),\n       xx=d0nl)\n       into 'qtr_result';\n   ```\n\n   Smith Corp%% $12345.00% $-67890.00%Jones\n   ABC Oil %% $54321.00% $-98765.00%Green\n   Spring Omc%%xx %xx %Namroc\n\n8. Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\n\n   ```sql\n   copy table gifts\n       (item_name=char(0)tab,\n       date_recd=char(0)tab,\n       sender=char(20)nl with null('anonymous'))\n       into 'giftdata';\n   ```\n\n   toaster 04-mar-1993 Nicholas\n   sled 10-oct-1993 anonymous\n   rocket 01-dec-1993 Francisco\n\n9. Create a table and load it using bulk copy, specifying structural options.\n\n   ```sql\n   create table mytable (name char 25, ...);\n   \n   modify mytable to hash;\n   \n   copy mytable() from 'myfile' with minpages = 16384,\n   maxpages = 16384, allocation = 16384;\n   ```"
        ]
    },
    {
        "instruction": "Explain the usage of length specifiers in Actian 4GL SQL COPY statements with examples.",
        "input": "",
        "output": "Length specifiers are used in Actian 4GL SQL COPY statements to define the maximum length of variables. For example, if you want to read a fixed-length string of 5 characters from a data file, you can use `varchar(5)`. The resulting variable will be a string containing the specified number of characters, preceded by a 5-character, right-justified length specifier. If the input string is shorter than the specified length, it will be padded with null characters to reach the specified length. For example:\n```\nCOPY my_table FROM datafile USING DELIMITER 'tab' FIELDS:\n  varchar(5) field1 tab varchar(3) field2 tab varchar(8) field3;\n```\nIn this example, `field1`, `field2`, and `field3` will have lengths of 5, 3, and 8 characters, respectively.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "# Copy Statement\n\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\n\nThis statement has the following syntax:\n\n```sql\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\n```\n\n## Parameters--Copy Statement\n\nThis statement has the following parameters:\n\n- **table_name**: Specifies an existing table from which data is read or to which data is written.\n- **column_name**: Specifies the column from which data is read or to which data is written.\n- **format**: Specifies the format in which a value is stored in the file.\n- **filename**: Specifies the file from which data is read or to which data is written.\n- **type**: (Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\n\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\n\n- **with_clause**: Consists of the word with, followed by a comma-separated list of one or more of the following items:\n  - on_error = TERMINATE | CONTINUE\n  - error_count = n\n  - rollback = ENABLED | DISABLED\n  - log = 'filename'\n\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\n- allocation = n\n- extend = n\n- fillfactor = n (ISAM, Hash, and Btree only)\n- minpages = n (Hash only)\n- maxpages = n (Hash only)\n- leaffill = n (Btree only)\n- nonleaffill = n (Btree only)\n- row_estimate = n\n\n## Unformatted Copying\n\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\n\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\n\n```sql\ncopy table employee () into 'emp_name';\n```\n\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\n\nNote: An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\n\n## Formatted Copying\n\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\n\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\n\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\n\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\n\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).",
            "The values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.\n\nNote: If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\n\n```sql\ncopy table t (col1=c20, col2=c30, d0=nl) into 't.out':\n```\n\n## Bulk Copying\n\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\n\nThe requirements for performing a bulk copy are:\n\n- The table is not journaled\n- The table has no secondary indexes\n- For storage structures other than heap, the table is empty and occupies fewer than 18 pages\n\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\n\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\n\n## Column Formats for Copy\n\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\n\nNote: When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\n\n### Character (Text) Formats\n\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\n\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\n\nThe subtle differences between the various character formats are described in Copy Format Details.\n\n### Counted Character Formats\n\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\n\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\n\nNote: Nvarchar(0) is not a counted format.\n\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\n\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\n\n### Dummy Format\n\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\n\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\n\n### Unicode Formats\n\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\n\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\n\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\n\n### Binary Formats",
            "### Binary Formats\n\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\n\nCertainly. I'll convert the provided documentation into a Markdown (.md) file format, maintaining the content while adjusting only the formatting. Here's the result:\n\n### Copy Format Details\n\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\n- Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n- When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n- The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\n\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).",
            "| Format | How Stored (copy into) | How Read (copy from) |\n|--------|------------------------|----------------------|\n| boolean | Written as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format) | Same format as copy into |\n| byte(0) | Same as byte(n) where n is the display length of the corresponding table column. | Read as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. |\n| byte(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded. |\n| byte varying(0) | Same as byte varying(n) where n is the display length of the table column. | Read as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |\n| byte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |\n| C0 | Same as Cn where n is the display length of the corresponding table column | Read as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Any control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\. |\n| Cn | Written as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Any control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\. |\n| char(0) | Same as char(n) where n is the display length of the corresponding table column. | Read as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Unlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is. |\n| char(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding. Unlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Unlike C format, char does not convert control characters or tabs. File data is read as is. |\n| D0 | Instead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.) Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed. | Dummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value. Any \\ found in the input means that the next character is to be taken literally, and is not a delimiter. |\n| Dn | Dummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1. | Dummy field. N characters are read and discarded. Copy from does not allow a delimiter specification with a fixed-length dummy field. |\n| date | Written as a date. (A binary format) | Read as a date. (A binary format) |\n| decimal | Written as a decimal number. (A binary format.) | Read as a decimal number. (A binary format) |\n| float | Written as double\u2011precision floating point. (A binary format) | Read as double\u2011precision floating point. (A binary format) |\n| float4 | Written as single\u2011precision floating point. (A binary format) | Read as single\u2011precision floating point. (A binary format) |\n| integer | Written as integer of 4\u2011byte length. (A binary format) | Read as integer of 4\u2011byte length. (A binary format) |",
            "| integer1 | Written as integer of 1\u2011byte length. (A binary format) | Read as integer of 1\u2011byte length. (A binary format) |\n| long byte(0) | Identical to long varchar | Identical to long varchar |\n| long nvarchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). The maximum segment size for the long nvarchar segment is 32727 bytes. The UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment. If a delimiter is specified, it is written immediately following the last segment. | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| long varchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767. The following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long: 5 abcde10 abcdefghij 0 (with a space after the terminating 0 character) (In this example, the data that is in the originating table column is abcdeabcdefghij) | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| money | Written as a scaled floating point value (a money value). (A binary format) | Read as a scaled floating-point values (a money value). (A binary format) |\n| nchar(0) | Written as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value. | Read as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered. |\n| nvarchar(0) | Same as nchar(0) | Same as nchar(0) |\n| nchar(n) | Written as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| nvarchar(n) | Written as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding. The byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| smallint | Written as an integer of 2\u2011byte length. (A binary format.) | Read as integer of 2\u2011byte length. (A binary format) |\n| text(0) | Written as a variable length string. If a delimiter is specified, it is written after the value. If the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding. Copy into using text(0) format is the way to get variable width output with no padding. | Read as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value |\n| text(n) | Written as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding. | Reads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded. |\n| varchar(0) | Same as varchar(n), where n is the display length of the corresponding table column. | Read as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |",
            "| varchar(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length. | Read as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |",
            "Note: The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\n\nFor user-defined data types (UDTs), use char or varchar.\n\nCertainly. I'll create a single Markdown (.md) file based on the provided documentation, focusing on formatting the content without modifying it. Here's the Markdown version:\n\n### Delimiters in the Data File\n\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\n\n| Delimiter | Description |\n|-----------|-------------|\n| nl | Newline character |\n| tab | Tab character |\n| sp | Space |\n| csv | Comma separated values |\n| ssv | Semicolon separated values |\n| nul or null | Null/zero character |\n| comma | Comma |\n| colon | Colon |\n| dash | Dash |\n| lparen | Left parenthesis |\n| rparen | Right parenthesis |\n| X | Any non-numeric character |\n\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\n\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\n\n## CSV and SSV Delimiters\n\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\n\nThe rules for a CSV-delimited field are:\n\n- The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n- Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\n  ```\n  \"There is a double quote \"\" here\"\n  ```\n\n  is translated to the table value:\n\n  ```\n  There is a double quote \" here\n  ```\n\n  Whitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\n- Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\n\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\n\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \"counted\" formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)\n\nCopy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\n\n## With Null Clause for Copy\n\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\n\n### With Null (value) Clause\n\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\n\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.",
            "To prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\n\nFor example, this example of a value is incorrect:\n\n```\nc0comma with null(0)\n```\n\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\n\n```\nc0comma with null('0')\n```\n\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\n\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\n\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\n\n```sql\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\n```\n\nThe correct version specifies a 4-character format for the column.\n\n```sql\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\n```\n\n### With Null Clause Omitting Value\n\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\n\n## Filename Specification for Copy\n\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\n\nUNIX: For copy into, if the file already exists, copy overwrites it.\n\n## Windows File Types for Copy\n\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\n\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\n\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\n\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\n\nThe binary-copy forms (copy () from or copy () into) use binary mode.\n\nNote: Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.\n\nCopy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\n\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\n\n## With Clause for Copy\n\nValid with clause options for the copy statement are as follows:\n\n### On_error=TERMINATE|CONTINUE\n\nDirects copy to continue after encountering conversion errors.\n\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\n\nBy default, copy terminates when an error occurs while converting between table format and file format\n\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\n\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\n\n### Error_count=n\n\nSpecifies how many errors can occur before processing terminates.\n\nDefault: 1.\n\nIf on_error is set to continue, setting error_count has no effect.",
            "Default: 1.\n\nIf on_error is set to continue, setting error_count has no effect.\n\n### Log='filename'\n\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\n\nLogging works as follows:\n\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\n\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\n\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\n\n### Rollback=ENABLED|DISABLED\n\nEnables or disables rollback, as follows:\n\n- ENABLED: Directs the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\n- DISABLED: Retains the appended rows.\n\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\n\nDefault: ENABLED\n\nWhen copying to a file, the with rollback clause has no effect.\n\n### Row_estimate\n\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\n\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\n\n## Permissions\n\nTo use the copy statement, one of the following must apply:\n\n- You own the table.\n- The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n- You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\n\n## Locking\n\n- When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n- When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n- When performing a non-bulk copy into a table, the DBMS server takes an \"intent exclusive\" lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\n\n## Restrictions and Considerations\n\n- Copy cannot be used to add data to a view, index, or system catalog.\n- When copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\n- When copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\n- The copy statement does not fire any rules defined against the table.\n- Values cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\n- Copy treats a present-but-empty field in the data file as:\n  - A blank default for character-based columns\n  - A zero default for numeric columns\n  - December 31 00-1 for date and timestamp columns\n  - 00:00:00 for time columns (and the time component in a timestamp)",
            "For example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\n\n## Related Statements\n\n- Create Table Statement\n- Modify Statement\n\n## Examples--Copy Statement\n\nThe following examples illustrate the correct use of the copy statement:\n\n1. In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\n\n   ```\n   ename     char(15)\n   age       integer4\n   dept      char(10)\n   comment   varchar(20)\n   ```\n\n   The emp.txt file contains the following data:\n\n   ```\n   Jones,J. 32 Anytown,USA toy,00017A This is a comment\n   Smith,P. 41 New York,NY admin,00015 Another comment\n   ```\n\n   The following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\n   - A dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\n   - The department field is delimited by a comma.\n   - The comment field is a variable-length varchar field, preceded by a five-character length specifier.\n\n2. Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\n\n   ```sql\n   copy table employee (eno=integer2, ename=char(10),\n       age=integer2, job=integer2, sal=float4,\n       dept=integer2, xxx=d1)\n       from 'myfile.in';\n   ```\n\n3. Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\n\n   ```sql\n   copy table employee (ename=char(0)comma,\n       eno=char(0)comma, sal= char(0)nl)\n       into 'mfile.out';\n   ```\n\n   Joe Smith , 101, $25000.00\n   \n   Shirley Scott , 102, $30000.00\n\n4. The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\n\n   ```sql\n   copy table employee (ename = text(0)csv,\n       eno = text(0)csv, sal = text(0)csv)\n       into 'mfile.out';\n   ```\n    \n   Joe Smith,101,$25000.00\n   Shirley Scott,102,$30000.00\n\n5. Bulk copy the employee table into a file. The resulting data file contains binary data.\n\n   ```sql\n   copy table employee () into 'ourfile.dat';\n   ```\n\n6. Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\n\n   ```sql\n   copy table other_employee_table () from 'ourfile.dat';\n   ```\n\n7. Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\n\n   ```sql\n   copy table acct_recv\n       (acct_name=char(0)'%',\n       address='d0%',\n       credit=char(0)'%' with null('xx'),\n       debit=char(0)'%' with null('xx'),\n       acct_mngr=char(15),\n       xx=d0nl)\n       into 'qtr_result';\n   ```\n\n   Smith Corp%% $12345.00% $-67890.00%Jones\n   ABC Oil %% $54321.00% $-98765.00%Green\n   Spring Omc%%xx %xx %Namroc\n\n8. Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\n\n   ```sql\n   copy table gifts\n       (item_name=char(0)tab,\n       date_recd=char(0)tab,\n       sender=char(20)nl with null('anonymous'))\n       into 'giftdata';\n   ```\n\n   toaster 04-mar-1993 Nicholas\n   sled 10-oct-1993 anonymous\n   rocket 01-dec-1993 Francisco\n\n9. Create a table and load it using bulk copy, specifying structural options.\n\n   ```sql\n   create table mytable (name char 25, ...);\n   \n   modify mytable to hash;\n   \n   copy mytable() from 'myfile' with minpages = 16384,\n   maxpages = 16384, allocation = 16384;\n   ```"
        ]
    },
    {
        "instruction": "How can we handle large text data using Actian 4GL SQL COPY statements?",
        "input": "",
        "output": "Large text data can be handled using the `clob` or `blob` (Character Large Object and Binary Large Object, respectively) data types in Actian 4GL SQL COPY statements. The `CLOB` type is used for large character strings while `BLOB` type is used for large binary data. To import or export large text data, you can use the following syntax:\n```\nCOPY my_table FROM datafile USING DELIMITER 'nl' FIELDS:\n  clob field1 nl ...;\n```\nIn this example, all rows in the `my_table` table containing a column of type `clob` will be updated with the large text data from the corresponding row in the data file.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "# Copy Statement\n\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\n\nThis statement has the following syntax:\n\n```sql\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\n```\n\n## Parameters--Copy Statement\n\nThis statement has the following parameters:\n\n- **table_name**: Specifies an existing table from which data is read or to which data is written.\n- **column_name**: Specifies the column from which data is read or to which data is written.\n- **format**: Specifies the format in which a value is stored in the file.\n- **filename**: Specifies the file from which data is read or to which data is written.\n- **type**: (Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\n\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\n\n- **with_clause**: Consists of the word with, followed by a comma-separated list of one or more of the following items:\n  - on_error = TERMINATE | CONTINUE\n  - error_count = n\n  - rollback = ENABLED | DISABLED\n  - log = 'filename'\n\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\n- allocation = n\n- extend = n\n- fillfactor = n (ISAM, Hash, and Btree only)\n- minpages = n (Hash only)\n- maxpages = n (Hash only)\n- leaffill = n (Btree only)\n- nonleaffill = n (Btree only)\n- row_estimate = n\n\n## Unformatted Copying\n\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\n\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\n\n```sql\ncopy table employee () into 'emp_name';\n```\n\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\n\nNote: An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\n\n## Formatted Copying\n\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\n\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\n\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\n\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\n\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).",
            "The values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.\n\nNote: If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\n\n```sql\ncopy table t (col1=c20, col2=c30, d0=nl) into 't.out':\n```\n\n## Bulk Copying\n\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\n\nThe requirements for performing a bulk copy are:\n\n- The table is not journaled\n- The table has no secondary indexes\n- For storage structures other than heap, the table is empty and occupies fewer than 18 pages\n\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\n\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\n\n## Column Formats for Copy\n\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\n\nNote: When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\n\n### Character (Text) Formats\n\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\n\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\n\nThe subtle differences between the various character formats are described in Copy Format Details.\n\n### Counted Character Formats\n\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\n\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\n\nNote: Nvarchar(0) is not a counted format.\n\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\n\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\n\n### Dummy Format\n\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\n\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\n\n### Unicode Formats\n\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\n\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\n\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\n\n### Binary Formats",
            "### Binary Formats\n\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\n\nCertainly. I'll convert the provided documentation into a Markdown (.md) file format, maintaining the content while adjusting only the formatting. Here's the result:\n\n### Copy Format Details\n\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\n- Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n- When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n- The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\n\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).",
            "| Format | How Stored (copy into) | How Read (copy from) |\n|--------|------------------------|----------------------|\n| boolean | Written as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format) | Same format as copy into |\n| byte(0) | Same as byte(n) where n is the display length of the corresponding table column. | Read as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. |\n| byte(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded. |\n| byte varying(0) | Same as byte varying(n) where n is the display length of the table column. | Read as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |\n| byte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |\n| C0 | Same as Cn where n is the display length of the corresponding table column | Read as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Any control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\. |\n| Cn | Written as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Any control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\. |\n| char(0) | Same as char(n) where n is the display length of the corresponding table column. | Read as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Unlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is. |\n| char(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding. Unlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Unlike C format, char does not convert control characters or tabs. File data is read as is. |\n| D0 | Instead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.) Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed. | Dummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value. Any \\ found in the input means that the next character is to be taken literally, and is not a delimiter. |\n| Dn | Dummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1. | Dummy field. N characters are read and discarded. Copy from does not allow a delimiter specification with a fixed-length dummy field. |\n| date | Written as a date. (A binary format) | Read as a date. (A binary format) |\n| decimal | Written as a decimal number. (A binary format.) | Read as a decimal number. (A binary format) |\n| float | Written as double\u2011precision floating point. (A binary format) | Read as double\u2011precision floating point. (A binary format) |\n| float4 | Written as single\u2011precision floating point. (A binary format) | Read as single\u2011precision floating point. (A binary format) |\n| integer | Written as integer of 4\u2011byte length. (A binary format) | Read as integer of 4\u2011byte length. (A binary format) |",
            "| integer1 | Written as integer of 1\u2011byte length. (A binary format) | Read as integer of 1\u2011byte length. (A binary format) |\n| long byte(0) | Identical to long varchar | Identical to long varchar |\n| long nvarchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). The maximum segment size for the long nvarchar segment is 32727 bytes. The UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment. If a delimiter is specified, it is written immediately following the last segment. | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| long varchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767. The following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long: 5 abcde10 abcdefghij 0 (with a space after the terminating 0 character) (In this example, the data that is in the originating table column is abcdeabcdefghij) | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| money | Written as a scaled floating point value (a money value). (A binary format) | Read as a scaled floating-point values (a money value). (A binary format) |\n| nchar(0) | Written as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value. | Read as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered. |\n| nvarchar(0) | Same as nchar(0) | Same as nchar(0) |\n| nchar(n) | Written as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| nvarchar(n) | Written as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding. The byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| smallint | Written as an integer of 2\u2011byte length. (A binary format.) | Read as integer of 2\u2011byte length. (A binary format) |\n| text(0) | Written as a variable length string. If a delimiter is specified, it is written after the value. If the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding. Copy into using text(0) format is the way to get variable width output with no padding. | Read as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value |\n| text(n) | Written as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding. | Reads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded. |\n| varchar(0) | Same as varchar(n), where n is the display length of the corresponding table column. | Read as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |",
            "| varchar(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length. | Read as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |",
            "Note: The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\n\nFor user-defined data types (UDTs), use char or varchar.\n\nCertainly. I'll create a single Markdown (.md) file based on the provided documentation, focusing on formatting the content without modifying it. Here's the Markdown version:\n\n### Delimiters in the Data File\n\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\n\n| Delimiter | Description |\n|-----------|-------------|\n| nl | Newline character |\n| tab | Tab character |\n| sp | Space |\n| csv | Comma separated values |\n| ssv | Semicolon separated values |\n| nul or null | Null/zero character |\n| comma | Comma |\n| colon | Colon |\n| dash | Dash |\n| lparen | Left parenthesis |\n| rparen | Right parenthesis |\n| X | Any non-numeric character |\n\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\n\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\n\n## CSV and SSV Delimiters\n\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\n\nThe rules for a CSV-delimited field are:\n\n- The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n- Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\n  ```\n  \"There is a double quote \"\" here\"\n  ```\n\n  is translated to the table value:\n\n  ```\n  There is a double quote \" here\n  ```\n\n  Whitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\n- Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\n\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\n\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \"counted\" formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)\n\nCopy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\n\n## With Null Clause for Copy\n\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\n\n### With Null (value) Clause\n\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\n\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.",
            "To prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\n\nFor example, this example of a value is incorrect:\n\n```\nc0comma with null(0)\n```\n\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\n\n```\nc0comma with null('0')\n```\n\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\n\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\n\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\n\n```sql\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\n```\n\nThe correct version specifies a 4-character format for the column.\n\n```sql\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\n```\n\n### With Null Clause Omitting Value\n\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\n\n## Filename Specification for Copy\n\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\n\nUNIX: For copy into, if the file already exists, copy overwrites it.\n\n## Windows File Types for Copy\n\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\n\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\n\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\n\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\n\nThe binary-copy forms (copy () from or copy () into) use binary mode.\n\nNote: Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.\n\nCopy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\n\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\n\n## With Clause for Copy\n\nValid with clause options for the copy statement are as follows:\n\n### On_error=TERMINATE|CONTINUE\n\nDirects copy to continue after encountering conversion errors.\n\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\n\nBy default, copy terminates when an error occurs while converting between table format and file format\n\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\n\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\n\n### Error_count=n\n\nSpecifies how many errors can occur before processing terminates.\n\nDefault: 1.\n\nIf on_error is set to continue, setting error_count has no effect.",
            "Default: 1.\n\nIf on_error is set to continue, setting error_count has no effect.\n\n### Log='filename'\n\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\n\nLogging works as follows:\n\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\n\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\n\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\n\n### Rollback=ENABLED|DISABLED\n\nEnables or disables rollback, as follows:\n\n- ENABLED: Directs the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\n- DISABLED: Retains the appended rows.\n\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\n\nDefault: ENABLED\n\nWhen copying to a file, the with rollback clause has no effect.\n\n### Row_estimate\n\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\n\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\n\n## Permissions\n\nTo use the copy statement, one of the following must apply:\n\n- You own the table.\n- The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n- You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\n\n## Locking\n\n- When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n- When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n- When performing a non-bulk copy into a table, the DBMS server takes an \"intent exclusive\" lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\n\n## Restrictions and Considerations\n\n- Copy cannot be used to add data to a view, index, or system catalog.\n- When copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\n- When copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\n- The copy statement does not fire any rules defined against the table.\n- Values cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\n- Copy treats a present-but-empty field in the data file as:\n  - A blank default for character-based columns\n  - A zero default for numeric columns\n  - December 31 00-1 for date and timestamp columns\n  - 00:00:00 for time columns (and the time component in a timestamp)",
            "For example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\n\n## Related Statements\n\n- Create Table Statement\n- Modify Statement\n\n## Examples--Copy Statement\n\nThe following examples illustrate the correct use of the copy statement:\n\n1. In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\n\n   ```\n   ename     char(15)\n   age       integer4\n   dept      char(10)\n   comment   varchar(20)\n   ```\n\n   The emp.txt file contains the following data:\n\n   ```\n   Jones,J. 32 Anytown,USA toy,00017A This is a comment\n   Smith,P. 41 New York,NY admin,00015 Another comment\n   ```\n\n   The following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\n   - A dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\n   - The department field is delimited by a comma.\n   - The comment field is a variable-length varchar field, preceded by a five-character length specifier.\n\n2. Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\n\n   ```sql\n   copy table employee (eno=integer2, ename=char(10),\n       age=integer2, job=integer2, sal=float4,\n       dept=integer2, xxx=d1)\n       from 'myfile.in';\n   ```\n\n3. Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\n\n   ```sql\n   copy table employee (ename=char(0)comma,\n       eno=char(0)comma, sal= char(0)nl)\n       into 'mfile.out';\n   ```\n\n   Joe Smith , 101, $25000.00\n   \n   Shirley Scott , 102, $30000.00\n\n4. The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\n\n   ```sql\n   copy table employee (ename = text(0)csv,\n       eno = text(0)csv, sal = text(0)csv)\n       into 'mfile.out';\n   ```\n    \n   Joe Smith,101,$25000.00\n   Shirley Scott,102,$30000.00\n\n5. Bulk copy the employee table into a file. The resulting data file contains binary data.\n\n   ```sql\n   copy table employee () into 'ourfile.dat';\n   ```\n\n6. Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\n\n   ```sql\n   copy table other_employee_table () from 'ourfile.dat';\n   ```\n\n7. Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\n\n   ```sql\n   copy table acct_recv\n       (acct_name=char(0)'%',\n       address='d0%',\n       credit=char(0)'%' with null('xx'),\n       debit=char(0)'%' with null('xx'),\n       acct_mngr=char(15),\n       xx=d0nl)\n       into 'qtr_result';\n   ```\n\n   Smith Corp%% $12345.00% $-67890.00%Jones\n   ABC Oil %% $54321.00% $-98765.00%Green\n   Spring Omc%%xx %xx %Namroc\n\n8. Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\n\n   ```sql\n   copy table gifts\n       (item_name=char(0)tab,\n       date_recd=char(0)tab,\n       sender=char(20)nl with null('anonymous'))\n       into 'giftdata';\n   ```\n\n   toaster 04-mar-1993 Nicholas\n   sled 10-oct-1993 anonymous\n   rocket 01-dec-1993 Francisco\n\n9. Create a table and load it using bulk copy, specifying structural options.\n\n   ```sql\n   create table mytable (name char 25, ...);\n   \n   modify mytable to hash;\n   \n   copy mytable() from 'myfile' with minpages = 16384,\n   maxpages = 16384, allocation = 16384;\n   ```"
        ]
    },
    {
        "instruction": "Describe the difference between fixed-length and variable-length data types in Actian 4GL SQL COPY statements.",
        "input": "",
        "output": "Fixed-length data types have a predefined, constant length, regardless of the size of the actual data. For example, the `byte(n)` or `char(n)` format in Actian 4GL SQL COPY statements has a specified length n that is used to allocate space for the value in memory and in the file. If the data value is shorter than the allocated length, it will be padded with null characters or spaces to reach the specified length.\nOn the other hand, variable-length data types are not fixed and their lengths may vary. For example, `byte varying(n)` or `varchar(n)` format in Actian 4GL SQL COPY statements allocates space only for the actual data and pads it with null characters if necessary when reading from the file.\nIn general, fixed-length formats are more efficient for large volumes of data with uniform length, while variable-length formats are more suitable for data with varying lengths.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "# Copy Statement\n\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\n\nThis statement has the following syntax:\n\n```sql\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\n```\n\n## Parameters--Copy Statement\n\nThis statement has the following parameters:\n\n- **table_name**: Specifies an existing table from which data is read or to which data is written.\n- **column_name**: Specifies the column from which data is read or to which data is written.\n- **format**: Specifies the format in which a value is stored in the file.\n- **filename**: Specifies the file from which data is read or to which data is written.\n- **type**: (Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\n\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\n\n- **with_clause**: Consists of the word with, followed by a comma-separated list of one or more of the following items:\n  - on_error = TERMINATE | CONTINUE\n  - error_count = n\n  - rollback = ENABLED | DISABLED\n  - log = 'filename'\n\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\n- allocation = n\n- extend = n\n- fillfactor = n (ISAM, Hash, and Btree only)\n- minpages = n (Hash only)\n- maxpages = n (Hash only)\n- leaffill = n (Btree only)\n- nonleaffill = n (Btree only)\n- row_estimate = n\n\n## Unformatted Copying\n\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\n\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\n\n```sql\ncopy table employee () into 'emp_name';\n```\n\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\n\nNote: An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\n\n## Formatted Copying\n\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\n\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\n\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\n\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\n\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).",
            "The values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.\n\nNote: If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\n\n```sql\ncopy table t (col1=c20, col2=c30, d0=nl) into 't.out':\n```\n\n## Bulk Copying\n\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\n\nThe requirements for performing a bulk copy are:\n\n- The table is not journaled\n- The table has no secondary indexes\n- For storage structures other than heap, the table is empty and occupies fewer than 18 pages\n\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\n\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\n\n## Column Formats for Copy\n\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\n\nNote: When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\n\n### Character (Text) Formats\n\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\n\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\n\nThe subtle differences between the various character formats are described in Copy Format Details.\n\n### Counted Character Formats\n\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\n\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\n\nNote: Nvarchar(0) is not a counted format.\n\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\n\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\n\n### Dummy Format\n\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\n\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\n\n### Unicode Formats\n\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\n\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\n\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\n\n### Binary Formats",
            "### Binary Formats\n\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\n\nCertainly. I'll convert the provided documentation into a Markdown (.md) file format, maintaining the content while adjusting only the formatting. Here's the result:\n\n### Copy Format Details\n\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\n- Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n- When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n- The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\n\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).",
            "| Format | How Stored (copy into) | How Read (copy from) |\n|--------|------------------------|----------------------|\n| boolean | Written as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format) | Same format as copy into |\n| byte(0) | Same as byte(n) where n is the display length of the corresponding table column. | Read as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. |\n| byte(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded. |\n| byte varying(0) | Same as byte varying(n) where n is the display length of the table column. | Read as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |\n| byte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |\n| C0 | Same as Cn where n is the display length of the corresponding table column | Read as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Any control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\. |\n| Cn | Written as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Any control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\. |\n| char(0) | Same as char(n) where n is the display length of the corresponding table column. | Read as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Unlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is. |\n| char(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding. Unlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Unlike C format, char does not convert control characters or tabs. File data is read as is. |\n| D0 | Instead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.) Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed. | Dummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value. Any \\ found in the input means that the next character is to be taken literally, and is not a delimiter. |\n| Dn | Dummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1. | Dummy field. N characters are read and discarded. Copy from does not allow a delimiter specification with a fixed-length dummy field. |\n| date | Written as a date. (A binary format) | Read as a date. (A binary format) |\n| decimal | Written as a decimal number. (A binary format.) | Read as a decimal number. (A binary format) |\n| float | Written as double\u2011precision floating point. (A binary format) | Read as double\u2011precision floating point. (A binary format) |\n| float4 | Written as single\u2011precision floating point. (A binary format) | Read as single\u2011precision floating point. (A binary format) |\n| integer | Written as integer of 4\u2011byte length. (A binary format) | Read as integer of 4\u2011byte length. (A binary format) |",
            "| integer1 | Written as integer of 1\u2011byte length. (A binary format) | Read as integer of 1\u2011byte length. (A binary format) |\n| long byte(0) | Identical to long varchar | Identical to long varchar |\n| long nvarchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). The maximum segment size for the long nvarchar segment is 32727 bytes. The UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment. If a delimiter is specified, it is written immediately following the last segment. | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| long varchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767. The following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long: 5 abcde10 abcdefghij 0 (with a space after the terminating 0 character) (In this example, the data that is in the originating table column is abcdeabcdefghij) | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| money | Written as a scaled floating point value (a money value). (A binary format) | Read as a scaled floating-point values (a money value). (A binary format) |\n| nchar(0) | Written as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value. | Read as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered. |\n| nvarchar(0) | Same as nchar(0) | Same as nchar(0) |\n| nchar(n) | Written as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| nvarchar(n) | Written as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding. The byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| smallint | Written as an integer of 2\u2011byte length. (A binary format.) | Read as integer of 2\u2011byte length. (A binary format) |\n| text(0) | Written as a variable length string. If a delimiter is specified, it is written after the value. If the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding. Copy into using text(0) format is the way to get variable width output with no padding. | Read as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value |\n| text(n) | Written as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding. | Reads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded. |\n| varchar(0) | Same as varchar(n), where n is the display length of the corresponding table column. | Read as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |",
            "| varchar(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length. | Read as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |",
            "Note: The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\n\nFor user-defined data types (UDTs), use char or varchar.\n\nCertainly. I'll create a single Markdown (.md) file based on the provided documentation, focusing on formatting the content without modifying it. Here's the Markdown version:\n\n### Delimiters in the Data File\n\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\n\n| Delimiter | Description |\n|-----------|-------------|\n| nl | Newline character |\n| tab | Tab character |\n| sp | Space |\n| csv | Comma separated values |\n| ssv | Semicolon separated values |\n| nul or null | Null/zero character |\n| comma | Comma |\n| colon | Colon |\n| dash | Dash |\n| lparen | Left parenthesis |\n| rparen | Right parenthesis |\n| X | Any non-numeric character |\n\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\n\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\n\n## CSV and SSV Delimiters\n\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\n\nThe rules for a CSV-delimited field are:\n\n- The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n- Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\n  ```\n  \"There is a double quote \"\" here\"\n  ```\n\n  is translated to the table value:\n\n  ```\n  There is a double quote \" here\n  ```\n\n  Whitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\n- Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\n\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\n\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \"counted\" formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)\n\nCopy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\n\n## With Null Clause for Copy\n\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\n\n### With Null (value) Clause\n\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\n\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.",
            "To prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\n\nFor example, this example of a value is incorrect:\n\n```\nc0comma with null(0)\n```\n\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\n\n```\nc0comma with null('0')\n```\n\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\n\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\n\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\n\n```sql\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\n```\n\nThe correct version specifies a 4-character format for the column.\n\n```sql\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\n```\n\n### With Null Clause Omitting Value\n\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\n\n## Filename Specification for Copy\n\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\n\nUNIX: For copy into, if the file already exists, copy overwrites it.\n\n## Windows File Types for Copy\n\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\n\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\n\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\n\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\n\nThe binary-copy forms (copy () from or copy () into) use binary mode.\n\nNote: Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.\n\nCopy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\n\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\n\n## With Clause for Copy\n\nValid with clause options for the copy statement are as follows:\n\n### On_error=TERMINATE|CONTINUE\n\nDirects copy to continue after encountering conversion errors.\n\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\n\nBy default, copy terminates when an error occurs while converting between table format and file format\n\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\n\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\n\n### Error_count=n\n\nSpecifies how many errors can occur before processing terminates.\n\nDefault: 1.\n\nIf on_error is set to continue, setting error_count has no effect.",
            "Default: 1.\n\nIf on_error is set to continue, setting error_count has no effect.\n\n### Log='filename'\n\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\n\nLogging works as follows:\n\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\n\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\n\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\n\n### Rollback=ENABLED|DISABLED\n\nEnables or disables rollback, as follows:\n\n- ENABLED: Directs the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\n- DISABLED: Retains the appended rows.\n\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\n\nDefault: ENABLED\n\nWhen copying to a file, the with rollback clause has no effect.\n\n### Row_estimate\n\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\n\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\n\n## Permissions\n\nTo use the copy statement, one of the following must apply:\n\n- You own the table.\n- The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n- You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\n\n## Locking\n\n- When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n- When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n- When performing a non-bulk copy into a table, the DBMS server takes an \"intent exclusive\" lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\n\n## Restrictions and Considerations\n\n- Copy cannot be used to add data to a view, index, or system catalog.\n- When copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\n- When copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\n- The copy statement does not fire any rules defined against the table.\n- Values cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\n- Copy treats a present-but-empty field in the data file as:\n  - A blank default for character-based columns\n  - A zero default for numeric columns\n  - December 31 00-1 for date and timestamp columns\n  - 00:00:00 for time columns (and the time component in a timestamp)",
            "For example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\n\n## Related Statements\n\n- Create Table Statement\n- Modify Statement\n\n## Examples--Copy Statement\n\nThe following examples illustrate the correct use of the copy statement:\n\n1. In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\n\n   ```\n   ename     char(15)\n   age       integer4\n   dept      char(10)\n   comment   varchar(20)\n   ```\n\n   The emp.txt file contains the following data:\n\n   ```\n   Jones,J. 32 Anytown,USA toy,00017A This is a comment\n   Smith,P. 41 New York,NY admin,00015 Another comment\n   ```\n\n   The following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\n   - A dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\n   - The department field is delimited by a comma.\n   - The comment field is a variable-length varchar field, preceded by a five-character length specifier.\n\n2. Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\n\n   ```sql\n   copy table employee (eno=integer2, ename=char(10),\n       age=integer2, job=integer2, sal=float4,\n       dept=integer2, xxx=d1)\n       from 'myfile.in';\n   ```\n\n3. Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\n\n   ```sql\n   copy table employee (ename=char(0)comma,\n       eno=char(0)comma, sal= char(0)nl)\n       into 'mfile.out';\n   ```\n\n   Joe Smith , 101, $25000.00\n   \n   Shirley Scott , 102, $30000.00\n\n4. The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\n\n   ```sql\n   copy table employee (ename = text(0)csv,\n       eno = text(0)csv, sal = text(0)csv)\n       into 'mfile.out';\n   ```\n    \n   Joe Smith,101,$25000.00\n   Shirley Scott,102,$30000.00\n\n5. Bulk copy the employee table into a file. The resulting data file contains binary data.\n\n   ```sql\n   copy table employee () into 'ourfile.dat';\n   ```\n\n6. Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\n\n   ```sql\n   copy table other_employee_table () from 'ourfile.dat';\n   ```\n\n7. Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\n\n   ```sql\n   copy table acct_recv\n       (acct_name=char(0)'%',\n       address='d0%',\n       credit=char(0)'%' with null('xx'),\n       debit=char(0)'%' with null('xx'),\n       acct_mngr=char(15),\n       xx=d0nl)\n       into 'qtr_result';\n   ```\n\n   Smith Corp%% $12345.00% $-67890.00%Jones\n   ABC Oil %% $54321.00% $-98765.00%Green\n   Spring Omc%%xx %xx %Namroc\n\n8. Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\n\n   ```sql\n   copy table gifts\n       (item_name=char(0)tab,\n       date_recd=char(0)tab,\n       sender=char(20)nl with null('anonymous'))\n       into 'giftdata';\n   ```\n\n   toaster 04-mar-1993 Nicholas\n   sled 10-oct-1993 anonymous\n   rocket 01-dec-1993 Francisco\n\n9. Create a table and load it using bulk copy, specifying structural options.\n\n   ```sql\n   create table mytable (name char 25, ...);\n   \n   modify mytable to hash;\n   \n   copy mytable() from 'myfile' with minpages = 16384,\n   maxpages = 16384, allocation = 16384;\n   ```"
        ]
    },
    {
        "instruction": "Describe the usage of advanced options like specifying delimiters and the use of `\\` in Actian 4GL SQL COPY statements with examples.",
        "input": "",
        "output": "Advanced options, such as specifying delimiters and using `\\`, can be used to enhance the flexibility and control of data import and export operations in Actian 4GL SQL COPY statements. The `DELIMITER` option specifies the character(s) that separate fields and mark the end of records in the data file. For example, you can use the comma as a delimiter with `DELIMITER ','`. If no delimiter is specified, the first comma, tab, or newline encountered ends the value.\nThe backslash character (`\\`) is used to escape special characters that would otherwise be treated as delimiters or escape sequences. For example, if you want to include a comma in the data and use it as a literal value, you can precede it with `\\`. For instance, if you want to import a string containing commas, you can use:\n```\nCOPY my_table FROM datafile USING DELIMITER ',' FIELDS: varchar(50) field1;\nfield1 value: John\\ Doe, Jane\\ Smith\n```\nIn this example, the commas in `John Doe, Jane Smith` are escaped with `\\`, so that they are not interpreted as delimiters and the entire string is imported as a single value.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "# Copy Statement\n\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\n\nThis statement has the following syntax:\n\n```sql\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\n```\n\n## Parameters--Copy Statement\n\nThis statement has the following parameters:\n\n- **table_name**: Specifies an existing table from which data is read or to which data is written.\n- **column_name**: Specifies the column from which data is read or to which data is written.\n- **format**: Specifies the format in which a value is stored in the file.\n- **filename**: Specifies the file from which data is read or to which data is written.\n- **type**: (Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\n\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\n\n- **with_clause**: Consists of the word with, followed by a comma-separated list of one or more of the following items:\n  - on_error = TERMINATE | CONTINUE\n  - error_count = n\n  - rollback = ENABLED | DISABLED\n  - log = 'filename'\n\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\n- allocation = n\n- extend = n\n- fillfactor = n (ISAM, Hash, and Btree only)\n- minpages = n (Hash only)\n- maxpages = n (Hash only)\n- leaffill = n (Btree only)\n- nonleaffill = n (Btree only)\n- row_estimate = n\n\n## Unformatted Copying\n\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\n\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\n\n```sql\ncopy table employee () into 'emp_name';\n```\n\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\n\nNote: An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\n\n## Formatted Copying\n\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\n\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\n\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\n\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\n\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).",
            "The values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.\n\nNote: If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\n\n```sql\ncopy table t (col1=c20, col2=c30, d0=nl) into 't.out':\n```\n\n## Bulk Copying\n\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\n\nThe requirements for performing a bulk copy are:\n\n- The table is not journaled\n- The table has no secondary indexes\n- For storage structures other than heap, the table is empty and occupies fewer than 18 pages\n\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\n\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\n\n## Column Formats for Copy\n\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\n\nNote: When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\n\n### Character (Text) Formats\n\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\n\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\n\nThe subtle differences between the various character formats are described in Copy Format Details.\n\n### Counted Character Formats\n\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\n\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\n\nNote: Nvarchar(0) is not a counted format.\n\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\n\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\n\n### Dummy Format\n\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\n\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\n\n### Unicode Formats\n\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\n\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\n\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\n\n### Binary Formats",
            "### Binary Formats\n\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\n\nCertainly. I'll convert the provided documentation into a Markdown (.md) file format, maintaining the content while adjusting only the formatting. Here's the result:\n\n### Copy Format Details\n\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\n- Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n- When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n- The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\n\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).",
            "| Format | How Stored (copy into) | How Read (copy from) |\n|--------|------------------------|----------------------|\n| boolean | Written as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format) | Same format as copy into |\n| byte(0) | Same as byte(n) where n is the display length of the corresponding table column. | Read as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. |\n| byte(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded. |\n| byte varying(0) | Same as byte varying(n) where n is the display length of the table column. | Read as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |\n| byte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |\n| C0 | Same as Cn where n is the display length of the corresponding table column | Read as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Any control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\. |\n| Cn | Written as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Any control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\. |\n| char(0) | Same as char(n) where n is the display length of the corresponding table column. | Read as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Unlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is. |\n| char(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding. Unlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Unlike C format, char does not convert control characters or tabs. File data is read as is. |\n| D0 | Instead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.) Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed. | Dummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value. Any \\ found in the input means that the next character is to be taken literally, and is not a delimiter. |\n| Dn | Dummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1. | Dummy field. N characters are read and discarded. Copy from does not allow a delimiter specification with a fixed-length dummy field. |\n| date | Written as a date. (A binary format) | Read as a date. (A binary format) |\n| decimal | Written as a decimal number. (A binary format.) | Read as a decimal number. (A binary format) |\n| float | Written as double\u2011precision floating point. (A binary format) | Read as double\u2011precision floating point. (A binary format) |\n| float4 | Written as single\u2011precision floating point. (A binary format) | Read as single\u2011precision floating point. (A binary format) |\n| integer | Written as integer of 4\u2011byte length. (A binary format) | Read as integer of 4\u2011byte length. (A binary format) |",
            "| integer1 | Written as integer of 1\u2011byte length. (A binary format) | Read as integer of 1\u2011byte length. (A binary format) |\n| long byte(0) | Identical to long varchar | Identical to long varchar |\n| long nvarchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). The maximum segment size for the long nvarchar segment is 32727 bytes. The UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment. If a delimiter is specified, it is written immediately following the last segment. | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| long varchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767. The following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long: 5 abcde10 abcdefghij 0 (with a space after the terminating 0 character) (In this example, the data that is in the originating table column is abcdeabcdefghij) | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| money | Written as a scaled floating point value (a money value). (A binary format) | Read as a scaled floating-point values (a money value). (A binary format) |\n| nchar(0) | Written as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value. | Read as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered. |\n| nvarchar(0) | Same as nchar(0) | Same as nchar(0) |\n| nchar(n) | Written as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| nvarchar(n) | Written as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding. The byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| smallint | Written as an integer of 2\u2011byte length. (A binary format.) | Read as integer of 2\u2011byte length. (A binary format) |\n| text(0) | Written as a variable length string. If a delimiter is specified, it is written after the value. If the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding. Copy into using text(0) format is the way to get variable width output with no padding. | Read as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value |\n| text(n) | Written as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding. | Reads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded. |\n| varchar(0) | Same as varchar(n), where n is the display length of the corresponding table column. | Read as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |",
            "| varchar(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length. | Read as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |",
            "Note: The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\n\nFor user-defined data types (UDTs), use char or varchar.\n\nCertainly. I'll create a single Markdown (.md) file based on the provided documentation, focusing on formatting the content without modifying it. Here's the Markdown version:\n\n### Delimiters in the Data File\n\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\n\n| Delimiter | Description |\n|-----------|-------------|\n| nl | Newline character |\n| tab | Tab character |\n| sp | Space |\n| csv | Comma separated values |\n| ssv | Semicolon separated values |\n| nul or null | Null/zero character |\n| comma | Comma |\n| colon | Colon |\n| dash | Dash |\n| lparen | Left parenthesis |\n| rparen | Right parenthesis |\n| X | Any non-numeric character |\n\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\n\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\n\n## CSV and SSV Delimiters\n\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\n\nThe rules for a CSV-delimited field are:\n\n- The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n- Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\n  ```\n  \"There is a double quote \"\" here\"\n  ```\n\n  is translated to the table value:\n\n  ```\n  There is a double quote \" here\n  ```\n\n  Whitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\n- Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\n\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\n\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \"counted\" formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)\n\nCopy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\n\n## With Null Clause for Copy\n\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\n\n### With Null (value) Clause\n\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\n\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.",
            "To prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\n\nFor example, this example of a value is incorrect:\n\n```\nc0comma with null(0)\n```\n\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\n\n```\nc0comma with null('0')\n```\n\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\n\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\n\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\n\n```sql\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\n```\n\nThe correct version specifies a 4-character format for the column.\n\n```sql\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\n```\n\n### With Null Clause Omitting Value\n\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\n\n## Filename Specification for Copy\n\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\n\nUNIX: For copy into, if the file already exists, copy overwrites it.\n\n## Windows File Types for Copy\n\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\n\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\n\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\n\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\n\nThe binary-copy forms (copy () from or copy () into) use binary mode.\n\nNote: Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.\n\nCopy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\n\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\n\n## With Clause for Copy\n\nValid with clause options for the copy statement are as follows:\n\n### On_error=TERMINATE|CONTINUE\n\nDirects copy to continue after encountering conversion errors.\n\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\n\nBy default, copy terminates when an error occurs while converting between table format and file format\n\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\n\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\n\n### Error_count=n\n\nSpecifies how many errors can occur before processing terminates.\n\nDefault: 1.\n\nIf on_error is set to continue, setting error_count has no effect.",
            "Default: 1.\n\nIf on_error is set to continue, setting error_count has no effect.\n\n### Log='filename'\n\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\n\nLogging works as follows:\n\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\n\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\n\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\n\n### Rollback=ENABLED|DISABLED\n\nEnables or disables rollback, as follows:\n\n- ENABLED: Directs the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\n- DISABLED: Retains the appended rows.\n\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\n\nDefault: ENABLED\n\nWhen copying to a file, the with rollback clause has no effect.\n\n### Row_estimate\n\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\n\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\n\n## Permissions\n\nTo use the copy statement, one of the following must apply:\n\n- You own the table.\n- The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n- You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\n\n## Locking\n\n- When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n- When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n- When performing a non-bulk copy into a table, the DBMS server takes an \"intent exclusive\" lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\n\n## Restrictions and Considerations\n\n- Copy cannot be used to add data to a view, index, or system catalog.\n- When copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\n- When copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\n- The copy statement does not fire any rules defined against the table.\n- Values cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\n- Copy treats a present-but-empty field in the data file as:\n  - A blank default for character-based columns\n  - A zero default for numeric columns\n  - December 31 00-1 for date and timestamp columns\n  - 00:00:00 for time columns (and the time component in a timestamp)",
            "For example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\n\n## Related Statements\n\n- Create Table Statement\n- Modify Statement\n\n## Examples--Copy Statement\n\nThe following examples illustrate the correct use of the copy statement:\n\n1. In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\n\n   ```\n   ename     char(15)\n   age       integer4\n   dept      char(10)\n   comment   varchar(20)\n   ```\n\n   The emp.txt file contains the following data:\n\n   ```\n   Jones,J. 32 Anytown,USA toy,00017A This is a comment\n   Smith,P. 41 New York,NY admin,00015 Another comment\n   ```\n\n   The following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\n   - A dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\n   - The department field is delimited by a comma.\n   - The comment field is a variable-length varchar field, preceded by a five-character length specifier.\n\n2. Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\n\n   ```sql\n   copy table employee (eno=integer2, ename=char(10),\n       age=integer2, job=integer2, sal=float4,\n       dept=integer2, xxx=d1)\n       from 'myfile.in';\n   ```\n\n3. Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\n\n   ```sql\n   copy table employee (ename=char(0)comma,\n       eno=char(0)comma, sal= char(0)nl)\n       into 'mfile.out';\n   ```\n\n   Joe Smith , 101, $25000.00\n   \n   Shirley Scott , 102, $30000.00\n\n4. The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\n\n   ```sql\n   copy table employee (ename = text(0)csv,\n       eno = text(0)csv, sal = text(0)csv)\n       into 'mfile.out';\n   ```\n    \n   Joe Smith,101,$25000.00\n   Shirley Scott,102,$30000.00\n\n5. Bulk copy the employee table into a file. The resulting data file contains binary data.\n\n   ```sql\n   copy table employee () into 'ourfile.dat';\n   ```\n\n6. Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\n\n   ```sql\n   copy table other_employee_table () from 'ourfile.dat';\n   ```\n\n7. Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\n\n   ```sql\n   copy table acct_recv\n       (acct_name=char(0)'%',\n       address='d0%',\n       credit=char(0)'%' with null('xx'),\n       debit=char(0)'%' with null('xx'),\n       acct_mngr=char(15),\n       xx=d0nl)\n       into 'qtr_result';\n   ```\n\n   Smith Corp%% $12345.00% $-67890.00%Jones\n   ABC Oil %% $54321.00% $-98765.00%Green\n   Spring Omc%%xx %xx %Namroc\n\n8. Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\n\n   ```sql\n   copy table gifts\n       (item_name=char(0)tab,\n       date_recd=char(0)tab,\n       sender=char(20)nl with null('anonymous'))\n       into 'giftdata';\n   ```\n\n   toaster 04-mar-1993 Nicholas\n   sled 10-oct-1993 anonymous\n   rocket 01-dec-1993 Francisco\n\n9. Create a table and load it using bulk copy, specifying structural options.\n\n   ```sql\n   create table mytable (name char 25, ...);\n   \n   modify mytable to hash;\n   \n   copy mytable() from 'myfile' with minpages = 16384,\n   maxpages = 16384, allocation = 16384;\n   ```"
        ]
    },
    {
        "instruction": "What is the use of the `with_clause` option in Actian 4GL SQL COPY statements?",
        "input": "",
        "output": "The `WITH_CLAUSE` option in Actian 4GL SQL COPY statements allows you to customize various aspects of data transfer, such as how errors should be handled or whether logging is enabled. Specifically, it includes the following options:\n- ON\\_ERROR can take the values TERMINATE or CONTINUE, which determine whether the copy operation should stop upon encountering an error (TERMINATE) or continue processing the rest of the rows after skipping the erroneous row (CONTINUE).\n- ERROR\\_COUNT lets you specify the maximum number of errors allowed before terminating the operation.\n- ROLLBACK can be used to enable or disable rollback recovery for the operation.\n- LOG allows you to log the progress and results of the copy operation to a specified file.\n- Other options, such as `allocation`, `extend`, and `fillfactor`, apply only to bulk copy operations.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "# Copy Statement\n\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\n\nThis statement has the following syntax:\n\n```sql\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\n```\n\n## Parameters--Copy Statement\n\nThis statement has the following parameters:\n\n- **table_name**: Specifies an existing table from which data is read or to which data is written.\n- **column_name**: Specifies the column from which data is read or to which data is written.\n- **format**: Specifies the format in which a value is stored in the file.\n- **filename**: Specifies the file from which data is read or to which data is written.\n- **type**: (Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\n\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\n\n- **with_clause**: Consists of the word with, followed by a comma-separated list of one or more of the following items:\n  - on_error = TERMINATE | CONTINUE\n  - error_count = n\n  - rollback = ENABLED | DISABLED\n  - log = 'filename'\n\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\n- allocation = n\n- extend = n\n- fillfactor = n (ISAM, Hash, and Btree only)\n- minpages = n (Hash only)\n- maxpages = n (Hash only)\n- leaffill = n (Btree only)\n- nonleaffill = n (Btree only)\n- row_estimate = n\n\n## Unformatted Copying\n\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\n\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\n\n```sql\ncopy table employee () into 'emp_name';\n```\n\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\n\nNote: An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\n\n## Formatted Copying\n\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\n\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\n\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\n\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\n\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).",
            "The values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.\n\nNote: If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\n\n```sql\ncopy table t (col1=c20, col2=c30, d0=nl) into 't.out':\n```\n\n## Bulk Copying\n\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\n\nThe requirements for performing a bulk copy are:\n\n- The table is not journaled\n- The table has no secondary indexes\n- For storage structures other than heap, the table is empty and occupies fewer than 18 pages\n\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\n\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\n\n## Column Formats for Copy\n\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\n\nNote: When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\n\n### Character (Text) Formats\n\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\n\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\n\nThe subtle differences between the various character formats are described in Copy Format Details.\n\n### Counted Character Formats\n\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\n\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\n\nNote: Nvarchar(0) is not a counted format.\n\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\n\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\n\n### Dummy Format\n\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\n\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\n\n### Unicode Formats\n\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\n\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\n\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\n\n### Binary Formats",
            "### Binary Formats\n\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\n\nCertainly. I'll convert the provided documentation into a Markdown (.md) file format, maintaining the content while adjusting only the formatting. Here's the result:\n\n### Copy Format Details\n\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\n- Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n- When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n- The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\n\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).",
            "| Format | How Stored (copy into) | How Read (copy from) |\n|--------|------------------------|----------------------|\n| boolean | Written as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format) | Same format as copy into |\n| byte(0) | Same as byte(n) where n is the display length of the corresponding table column. | Read as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. |\n| byte(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded. |\n| byte varying(0) | Same as byte varying(n) where n is the display length of the table column. | Read as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |\n| byte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |\n| C0 | Same as Cn where n is the display length of the corresponding table column | Read as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Any control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\. |\n| Cn | Written as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Any control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\. |\n| char(0) | Same as char(n) where n is the display length of the corresponding table column. | Read as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Unlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is. |\n| char(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding. Unlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Unlike C format, char does not convert control characters or tabs. File data is read as is. |\n| D0 | Instead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.) Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed. | Dummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value. Any \\ found in the input means that the next character is to be taken literally, and is not a delimiter. |\n| Dn | Dummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1. | Dummy field. N characters are read and discarded. Copy from does not allow a delimiter specification with a fixed-length dummy field. |\n| date | Written as a date. (A binary format) | Read as a date. (A binary format) |\n| decimal | Written as a decimal number. (A binary format.) | Read as a decimal number. (A binary format) |\n| float | Written as double\u2011precision floating point. (A binary format) | Read as double\u2011precision floating point. (A binary format) |\n| float4 | Written as single\u2011precision floating point. (A binary format) | Read as single\u2011precision floating point. (A binary format) |\n| integer | Written as integer of 4\u2011byte length. (A binary format) | Read as integer of 4\u2011byte length. (A binary format) |",
            "| integer1 | Written as integer of 1\u2011byte length. (A binary format) | Read as integer of 1\u2011byte length. (A binary format) |\n| long byte(0) | Identical to long varchar | Identical to long varchar |\n| long nvarchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). The maximum segment size for the long nvarchar segment is 32727 bytes. The UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment. If a delimiter is specified, it is written immediately following the last segment. | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| long varchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767. The following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long: 5 abcde10 abcdefghij 0 (with a space after the terminating 0 character) (In this example, the data that is in the originating table column is abcdeabcdefghij) | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| money | Written as a scaled floating point value (a money value). (A binary format) | Read as a scaled floating-point values (a money value). (A binary format) |\n| nchar(0) | Written as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value. | Read as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered. |\n| nvarchar(0) | Same as nchar(0) | Same as nchar(0) |\n| nchar(n) | Written as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| nvarchar(n) | Written as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding. The byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| smallint | Written as an integer of 2\u2011byte length. (A binary format.) | Read as integer of 2\u2011byte length. (A binary format) |\n| text(0) | Written as a variable length string. If a delimiter is specified, it is written after the value. If the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding. Copy into using text(0) format is the way to get variable width output with no padding. | Read as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value |\n| text(n) | Written as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding. | Reads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded. |\n| varchar(0) | Same as varchar(n), where n is the display length of the corresponding table column. | Read as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |",
            "| varchar(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length. | Read as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |",
            "Note: The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\n\nFor user-defined data types (UDTs), use char or varchar.\n\nCertainly. I'll create a single Markdown (.md) file based on the provided documentation, focusing on formatting the content without modifying it. Here's the Markdown version:\n\n### Delimiters in the Data File\n\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\n\n| Delimiter | Description |\n|-----------|-------------|\n| nl | Newline character |\n| tab | Tab character |\n| sp | Space |\n| csv | Comma separated values |\n| ssv | Semicolon separated values |\n| nul or null | Null/zero character |\n| comma | Comma |\n| colon | Colon |\n| dash | Dash |\n| lparen | Left parenthesis |\n| rparen | Right parenthesis |\n| X | Any non-numeric character |\n\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\n\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\n\n## CSV and SSV Delimiters\n\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\n\nThe rules for a CSV-delimited field are:\n\n- The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n- Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\n  ```\n  \"There is a double quote \"\" here\"\n  ```\n\n  is translated to the table value:\n\n  ```\n  There is a double quote \" here\n  ```\n\n  Whitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\n- Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\n\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\n\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \"counted\" formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)\n\nCopy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\n\n## With Null Clause for Copy\n\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\n\n### With Null (value) Clause\n\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\n\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.",
            "To prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\n\nFor example, this example of a value is incorrect:\n\n```\nc0comma with null(0)\n```\n\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\n\n```\nc0comma with null('0')\n```\n\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\n\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\n\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\n\n```sql\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\n```\n\nThe correct version specifies a 4-character format for the column.\n\n```sql\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\n```\n\n### With Null Clause Omitting Value\n\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\n\n## Filename Specification for Copy\n\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\n\nUNIX: For copy into, if the file already exists, copy overwrites it.\n\n## Windows File Types for Copy\n\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\n\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\n\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\n\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\n\nThe binary-copy forms (copy () from or copy () into) use binary mode.\n\nNote: Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.\n\nCopy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\n\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\n\n## With Clause for Copy\n\nValid with clause options for the copy statement are as follows:\n\n### On_error=TERMINATE|CONTINUE\n\nDirects copy to continue after encountering conversion errors.\n\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\n\nBy default, copy terminates when an error occurs while converting between table format and file format\n\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\n\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\n\n### Error_count=n\n\nSpecifies how many errors can occur before processing terminates.\n\nDefault: 1.\n\nIf on_error is set to continue, setting error_count has no effect.",
            "Default: 1.\n\nIf on_error is set to continue, setting error_count has no effect.\n\n### Log='filename'\n\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\n\nLogging works as follows:\n\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\n\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\n\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\n\n### Rollback=ENABLED|DISABLED\n\nEnables or disables rollback, as follows:\n\n- ENABLED: Directs the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\n- DISABLED: Retains the appended rows.\n\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\n\nDefault: ENABLED\n\nWhen copying to a file, the with rollback clause has no effect.\n\n### Row_estimate\n\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\n\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\n\n## Permissions\n\nTo use the copy statement, one of the following must apply:\n\n- You own the table.\n- The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n- You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\n\n## Locking\n\n- When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n- When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n- When performing a non-bulk copy into a table, the DBMS server takes an \"intent exclusive\" lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\n\n## Restrictions and Considerations\n\n- Copy cannot be used to add data to a view, index, or system catalog.\n- When copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\n- When copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\n- The copy statement does not fire any rules defined against the table.\n- Values cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\n- Copy treats a present-but-empty field in the data file as:\n  - A blank default for character-based columns\n  - A zero default for numeric columns\n  - December 31 00-1 for date and timestamp columns\n  - 00:00:00 for time columns (and the time component in a timestamp)",
            "For example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\n\n## Related Statements\n\n- Create Table Statement\n- Modify Statement\n\n## Examples--Copy Statement\n\nThe following examples illustrate the correct use of the copy statement:\n\n1. In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\n\n   ```\n   ename     char(15)\n   age       integer4\n   dept      char(10)\n   comment   varchar(20)\n   ```\n\n   The emp.txt file contains the following data:\n\n   ```\n   Jones,J. 32 Anytown,USA toy,00017A This is a comment\n   Smith,P. 41 New York,NY admin,00015 Another comment\n   ```\n\n   The following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\n   - A dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\n   - The department field is delimited by a comma.\n   - The comment field is a variable-length varchar field, preceded by a five-character length specifier.\n\n2. Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\n\n   ```sql\n   copy table employee (eno=integer2, ename=char(10),\n       age=integer2, job=integer2, sal=float4,\n       dept=integer2, xxx=d1)\n       from 'myfile.in';\n   ```\n\n3. Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\n\n   ```sql\n   copy table employee (ename=char(0)comma,\n       eno=char(0)comma, sal= char(0)nl)\n       into 'mfile.out';\n   ```\n\n   Joe Smith , 101, $25000.00\n   \n   Shirley Scott , 102, $30000.00\n\n4. The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\n\n   ```sql\n   copy table employee (ename = text(0)csv,\n       eno = text(0)csv, sal = text(0)csv)\n       into 'mfile.out';\n   ```\n    \n   Joe Smith,101,$25000.00\n   Shirley Scott,102,$30000.00\n\n5. Bulk copy the employee table into a file. The resulting data file contains binary data.\n\n   ```sql\n   copy table employee () into 'ourfile.dat';\n   ```\n\n6. Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\n\n   ```sql\n   copy table other_employee_table () from 'ourfile.dat';\n   ```\n\n7. Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\n\n   ```sql\n   copy table acct_recv\n       (acct_name=char(0)'%',\n       address='d0%',\n       credit=char(0)'%' with null('xx'),\n       debit=char(0)'%' with null('xx'),\n       acct_mngr=char(15),\n       xx=d0nl)\n       into 'qtr_result';\n   ```\n\n   Smith Corp%% $12345.00% $-67890.00%Jones\n   ABC Oil %% $54321.00% $-98765.00%Green\n   Spring Omc%%xx %xx %Namroc\n\n8. Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\n\n   ```sql\n   copy table gifts\n       (item_name=char(0)tab,\n       date_recd=char(0)tab,\n       sender=char(20)nl with null('anonymous'))\n       into 'giftdata';\n   ```\n\n   toaster 04-mar-1993 Nicholas\n   sled 10-oct-1993 anonymous\n   rocket 01-dec-1993 Francisco\n\n9. Create a table and load it using bulk copy, specifying structural options.\n\n   ```sql\n   create table mytable (name char 25, ...);\n   \n   modify mytable to hash;\n   \n   copy mytable() from 'myfile' with minpages = 16384,\n   maxpages = 16384, allocation = 16384;\n   ```"
        ]
    },
    {
        "instruction": "What is the difference between a `copy from` and a `copy into` statement in Actian 4GL SQL COPY?",
        "input": "",
        "output": "A `copy from` statement in Actian 4GL SQL COPY reads data from an external file or another database table, while a `copy into` statement writes the contents of a table to a data file. Both statements are used for importing and exporting data but with opposite functionalities.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "# Copy Statement\n\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\n\nThis statement has the following syntax:\n\n```sql\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\n```\n\n## Parameters--Copy Statement\n\nThis statement has the following parameters:\n\n- **table_name**: Specifies an existing table from which data is read or to which data is written.\n- **column_name**: Specifies the column from which data is read or to which data is written.\n- **format**: Specifies the format in which a value is stored in the file.\n- **filename**: Specifies the file from which data is read or to which data is written.\n- **type**: (Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\n\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\n\n- **with_clause**: Consists of the word with, followed by a comma-separated list of one or more of the following items:\n  - on_error = TERMINATE | CONTINUE\n  - error_count = n\n  - rollback = ENABLED | DISABLED\n  - log = 'filename'\n\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\n- allocation = n\n- extend = n\n- fillfactor = n (ISAM, Hash, and Btree only)\n- minpages = n (Hash only)\n- maxpages = n (Hash only)\n- leaffill = n (Btree only)\n- nonleaffill = n (Btree only)\n- row_estimate = n\n\n## Unformatted Copying\n\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\n\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\n\n```sql\ncopy table employee () into 'emp_name';\n```\n\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\n\nNote: An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\n\n## Formatted Copying\n\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\n\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\n\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\n\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\n\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).",
            "The values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.\n\nNote: If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\n\n```sql\ncopy table t (col1=c20, col2=c30, d0=nl) into 't.out':\n```\n\n## Bulk Copying\n\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\n\nThe requirements for performing a bulk copy are:\n\n- The table is not journaled\n- The table has no secondary indexes\n- For storage structures other than heap, the table is empty and occupies fewer than 18 pages\n\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\n\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\n\n## Column Formats for Copy\n\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\n\nNote: When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\n\n### Character (Text) Formats\n\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\n\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\n\nThe subtle differences between the various character formats are described in Copy Format Details.\n\n### Counted Character Formats\n\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\n\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\n\nNote: Nvarchar(0) is not a counted format.\n\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\n\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\n\n### Dummy Format\n\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\n\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\n\n### Unicode Formats\n\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\n\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\n\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\n\n### Binary Formats",
            "### Binary Formats\n\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\n\nCertainly. I'll convert the provided documentation into a Markdown (.md) file format, maintaining the content while adjusting only the formatting. Here's the result:\n\n### Copy Format Details\n\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\n- Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n- When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n- The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\n\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).",
            "| Format | How Stored (copy into) | How Read (copy from) |\n|--------|------------------------|----------------------|\n| boolean | Written as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format) | Same format as copy into |\n| byte(0) | Same as byte(n) where n is the display length of the corresponding table column. | Read as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. |\n| byte(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded. |\n| byte varying(0) | Same as byte varying(n) where n is the display length of the table column. | Read as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |\n| byte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |\n| C0 | Same as Cn where n is the display length of the corresponding table column | Read as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Any control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\. |\n| Cn | Written as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Any control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\. |\n| char(0) | Same as char(n) where n is the display length of the corresponding table column. | Read as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Unlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is. |\n| char(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding. Unlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Unlike C format, char does not convert control characters or tabs. File data is read as is. |\n| D0 | Instead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.) Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed. | Dummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value. Any \\ found in the input means that the next character is to be taken literally, and is not a delimiter. |\n| Dn | Dummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1. | Dummy field. N characters are read and discarded. Copy from does not allow a delimiter specification with a fixed-length dummy field. |\n| date | Written as a date. (A binary format) | Read as a date. (A binary format) |\n| decimal | Written as a decimal number. (A binary format.) | Read as a decimal number. (A binary format) |\n| float | Written as double\u2011precision floating point. (A binary format) | Read as double\u2011precision floating point. (A binary format) |\n| float4 | Written as single\u2011precision floating point. (A binary format) | Read as single\u2011precision floating point. (A binary format) |\n| integer | Written as integer of 4\u2011byte length. (A binary format) | Read as integer of 4\u2011byte length. (A binary format) |",
            "| integer1 | Written as integer of 1\u2011byte length. (A binary format) | Read as integer of 1\u2011byte length. (A binary format) |\n| long byte(0) | Identical to long varchar | Identical to long varchar |\n| long nvarchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). The maximum segment size for the long nvarchar segment is 32727 bytes. The UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment. If a delimiter is specified, it is written immediately following the last segment. | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| long varchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767. The following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long: 5 abcde10 abcdefghij 0 (with a space after the terminating 0 character) (In this example, the data that is in the originating table column is abcdeabcdefghij) | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| money | Written as a scaled floating point value (a money value). (A binary format) | Read as a scaled floating-point values (a money value). (A binary format) |\n| nchar(0) | Written as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value. | Read as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered. |\n| nvarchar(0) | Same as nchar(0) | Same as nchar(0) |\n| nchar(n) | Written as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| nvarchar(n) | Written as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding. The byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| smallint | Written as an integer of 2\u2011byte length. (A binary format.) | Read as integer of 2\u2011byte length. (A binary format) |\n| text(0) | Written as a variable length string. If a delimiter is specified, it is written after the value. If the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding. Copy into using text(0) format is the way to get variable width output with no padding. | Read as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value |\n| text(n) | Written as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding. | Reads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded. |\n| varchar(0) | Same as varchar(n), where n is the display length of the corresponding table column. | Read as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |",
            "| varchar(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length. | Read as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |",
            "Note: The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\n\nFor user-defined data types (UDTs), use char or varchar.\n\nCertainly. I'll create a single Markdown (.md) file based on the provided documentation, focusing on formatting the content without modifying it. Here's the Markdown version:\n\n### Delimiters in the Data File\n\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\n\n| Delimiter | Description |\n|-----------|-------------|\n| nl | Newline character |\n| tab | Tab character |\n| sp | Space |\n| csv | Comma separated values |\n| ssv | Semicolon separated values |\n| nul or null | Null/zero character |\n| comma | Comma |\n| colon | Colon |\n| dash | Dash |\n| lparen | Left parenthesis |\n| rparen | Right parenthesis |\n| X | Any non-numeric character |\n\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\n\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\n\n## CSV and SSV Delimiters\n\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\n\nThe rules for a CSV-delimited field are:\n\n- The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n- Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\n  ```\n  \"There is a double quote \"\" here\"\n  ```\n\n  is translated to the table value:\n\n  ```\n  There is a double quote \" here\n  ```\n\n  Whitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\n- Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\n\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\n\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \"counted\" formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)\n\nCopy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\n\n## With Null Clause for Copy\n\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\n\n### With Null (value) Clause\n\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\n\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.",
            "To prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\n\nFor example, this example of a value is incorrect:\n\n```\nc0comma with null(0)\n```\n\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\n\n```\nc0comma with null('0')\n```\n\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\n\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\n\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\n\n```sql\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\n```\n\nThe correct version specifies a 4-character format for the column.\n\n```sql\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\n```\n\n### With Null Clause Omitting Value\n\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\n\n## Filename Specification for Copy\n\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\n\nUNIX: For copy into, if the file already exists, copy overwrites it.\n\n## Windows File Types for Copy\n\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\n\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\n\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\n\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\n\nThe binary-copy forms (copy () from or copy () into) use binary mode.\n\nNote: Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.\n\nCopy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\n\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\n\n## With Clause for Copy\n\nValid with clause options for the copy statement are as follows:\n\n### On_error=TERMINATE|CONTINUE\n\nDirects copy to continue after encountering conversion errors.\n\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\n\nBy default, copy terminates when an error occurs while converting between table format and file format\n\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\n\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\n\n### Error_count=n\n\nSpecifies how many errors can occur before processing terminates.\n\nDefault: 1.\n\nIf on_error is set to continue, setting error_count has no effect.",
            "Default: 1.\n\nIf on_error is set to continue, setting error_count has no effect.\n\n### Log='filename'\n\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\n\nLogging works as follows:\n\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\n\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\n\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\n\n### Rollback=ENABLED|DISABLED\n\nEnables or disables rollback, as follows:\n\n- ENABLED: Directs the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\n- DISABLED: Retains the appended rows.\n\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\n\nDefault: ENABLED\n\nWhen copying to a file, the with rollback clause has no effect.\n\n### Row_estimate\n\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\n\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\n\n## Permissions\n\nTo use the copy statement, one of the following must apply:\n\n- You own the table.\n- The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n- You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\n\n## Locking\n\n- When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n- When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n- When performing a non-bulk copy into a table, the DBMS server takes an \"intent exclusive\" lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\n\n## Restrictions and Considerations\n\n- Copy cannot be used to add data to a view, index, or system catalog.\n- When copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\n- When copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\n- The copy statement does not fire any rules defined against the table.\n- Values cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\n- Copy treats a present-but-empty field in the data file as:\n  - A blank default for character-based columns\n  - A zero default for numeric columns\n  - December 31 00-1 for date and timestamp columns\n  - 00:00:00 for time columns (and the time component in a timestamp)",
            "For example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\n\n## Related Statements\n\n- Create Table Statement\n- Modify Statement\n\n## Examples--Copy Statement\n\nThe following examples illustrate the correct use of the copy statement:\n\n1. In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\n\n   ```\n   ename     char(15)\n   age       integer4\n   dept      char(10)\n   comment   varchar(20)\n   ```\n\n   The emp.txt file contains the following data:\n\n   ```\n   Jones,J. 32 Anytown,USA toy,00017A This is a comment\n   Smith,P. 41 New York,NY admin,00015 Another comment\n   ```\n\n   The following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\n   - A dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\n   - The department field is delimited by a comma.\n   - The comment field is a variable-length varchar field, preceded by a five-character length specifier.\n\n2. Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\n\n   ```sql\n   copy table employee (eno=integer2, ename=char(10),\n       age=integer2, job=integer2, sal=float4,\n       dept=integer2, xxx=d1)\n       from 'myfile.in';\n   ```\n\n3. Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\n\n   ```sql\n   copy table employee (ename=char(0)comma,\n       eno=char(0)comma, sal= char(0)nl)\n       into 'mfile.out';\n   ```\n\n   Joe Smith , 101, $25000.00\n   \n   Shirley Scott , 102, $30000.00\n\n4. The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\n\n   ```sql\n   copy table employee (ename = text(0)csv,\n       eno = text(0)csv, sal = text(0)csv)\n       into 'mfile.out';\n   ```\n    \n   Joe Smith,101,$25000.00\n   Shirley Scott,102,$30000.00\n\n5. Bulk copy the employee table into a file. The resulting data file contains binary data.\n\n   ```sql\n   copy table employee () into 'ourfile.dat';\n   ```\n\n6. Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\n\n   ```sql\n   copy table other_employee_table () from 'ourfile.dat';\n   ```\n\n7. Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\n\n   ```sql\n   copy table acct_recv\n       (acct_name=char(0)'%',\n       address='d0%',\n       credit=char(0)'%' with null('xx'),\n       debit=char(0)'%' with null('xx'),\n       acct_mngr=char(15),\n       xx=d0nl)\n       into 'qtr_result';\n   ```\n\n   Smith Corp%% $12345.00% $-67890.00%Jones\n   ABC Oil %% $54321.00% $-98765.00%Green\n   Spring Omc%%xx %xx %Namroc\n\n8. Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\n\n   ```sql\n   copy table gifts\n       (item_name=char(0)tab,\n       date_recd=char(0)tab,\n       sender=char(20)nl with null('anonymous'))\n       into 'giftdata';\n   ```\n\n   toaster 04-mar-1993 Nicholas\n   sled 10-oct-1993 anonymous\n   rocket 01-dec-1993 Francisco\n\n9. Create a table and load it using bulk copy, specifying structural options.\n\n   ```sql\n   create table mytable (name char 25, ...);\n   \n   modify mytable to hash;\n   \n   copy mytable() from 'myfile' with minpages = 16384,\n   maxpages = 16384, allocation = 16384;\n   ```"
        ]
    },
    {
        "instruction": "What are some advanced options that can be set using the `WITH_CLAUSE` in Actian 4GL SQL COPY?",
        "input": "",
        "output": "The `WITH_CLAUSE` in Actian 4GL SQL COPY allows setting several options such as on_error (TERMINATE | CONTINUE), error_count (n), rollback (ENABLED | DISABLED), log ('filename'), allocation (n), extend (n), fillfactor (n for ISAM, Hash, and Btree only), minpages (n for Hash only), maxpages (n for Hash only), leaffill (n for Btree only), nonleaffill (n for Btree only) and row_estimate (n). These options can be useful in handling errors, managing table structure, or optimizing performance.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "# Copy Statement\n\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\n\nThis statement has the following syntax:\n\n```sql\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\n```\n\n## Parameters--Copy Statement\n\nThis statement has the following parameters:\n\n- **table_name**: Specifies an existing table from which data is read or to which data is written.\n- **column_name**: Specifies the column from which data is read or to which data is written.\n- **format**: Specifies the format in which a value is stored in the file.\n- **filename**: Specifies the file from which data is read or to which data is written.\n- **type**: (Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\n\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\n\n- **with_clause**: Consists of the word with, followed by a comma-separated list of one or more of the following items:\n  - on_error = TERMINATE | CONTINUE\n  - error_count = n\n  - rollback = ENABLED | DISABLED\n  - log = 'filename'\n\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\n- allocation = n\n- extend = n\n- fillfactor = n (ISAM, Hash, and Btree only)\n- minpages = n (Hash only)\n- maxpages = n (Hash only)\n- leaffill = n (Btree only)\n- nonleaffill = n (Btree only)\n- row_estimate = n\n\n## Unformatted Copying\n\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\n\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\n\n```sql\ncopy table employee () into 'emp_name';\n```\n\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\n\nNote: An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\n\n## Formatted Copying\n\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\n\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\n\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\n\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\n\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).",
            "The values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.\n\nNote: If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\n\n```sql\ncopy table t (col1=c20, col2=c30, d0=nl) into 't.out':\n```\n\n## Bulk Copying\n\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\n\nThe requirements for performing a bulk copy are:\n\n- The table is not journaled\n- The table has no secondary indexes\n- For storage structures other than heap, the table is empty and occupies fewer than 18 pages\n\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\n\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\n\n## Column Formats for Copy\n\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\n\nNote: When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\n\n### Character (Text) Formats\n\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\n\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\n\nThe subtle differences between the various character formats are described in Copy Format Details.\n\n### Counted Character Formats\n\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\n\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\n\nNote: Nvarchar(0) is not a counted format.\n\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\n\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\n\n### Dummy Format\n\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\n\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\n\n### Unicode Formats\n\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\n\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\n\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\n\n### Binary Formats",
            "### Binary Formats\n\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\n\nCertainly. I'll convert the provided documentation into a Markdown (.md) file format, maintaining the content while adjusting only the formatting. Here's the result:\n\n### Copy Format Details\n\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\n- Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n- When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n- The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\n\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).",
            "| Format | How Stored (copy into) | How Read (copy from) |\n|--------|------------------------|----------------------|\n| boolean | Written as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format) | Same format as copy into |\n| byte(0) | Same as byte(n) where n is the display length of the corresponding table column. | Read as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. |\n| byte(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded. |\n| byte varying(0) | Same as byte varying(n) where n is the display length of the table column. | Read as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |\n| byte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |\n| C0 | Same as Cn where n is the display length of the corresponding table column | Read as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Any control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\. |\n| Cn | Written as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Any control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\. |\n| char(0) | Same as char(n) where n is the display length of the corresponding table column. | Read as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Unlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is. |\n| char(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding. Unlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Unlike C format, char does not convert control characters or tabs. File data is read as is. |\n| D0 | Instead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.) Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed. | Dummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value. Any \\ found in the input means that the next character is to be taken literally, and is not a delimiter. |\n| Dn | Dummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1. | Dummy field. N characters are read and discarded. Copy from does not allow a delimiter specification with a fixed-length dummy field. |\n| date | Written as a date. (A binary format) | Read as a date. (A binary format) |\n| decimal | Written as a decimal number. (A binary format.) | Read as a decimal number. (A binary format) |\n| float | Written as double\u2011precision floating point. (A binary format) | Read as double\u2011precision floating point. (A binary format) |\n| float4 | Written as single\u2011precision floating point. (A binary format) | Read as single\u2011precision floating point. (A binary format) |\n| integer | Written as integer of 4\u2011byte length. (A binary format) | Read as integer of 4\u2011byte length. (A binary format) |",
            "| integer1 | Written as integer of 1\u2011byte length. (A binary format) | Read as integer of 1\u2011byte length. (A binary format) |\n| long byte(0) | Identical to long varchar | Identical to long varchar |\n| long nvarchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). The maximum segment size for the long nvarchar segment is 32727 bytes. The UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment. If a delimiter is specified, it is written immediately following the last segment. | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| long varchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767. The following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long: 5 abcde10 abcdefghij 0 (with a space after the terminating 0 character) (In this example, the data that is in the originating table column is abcdeabcdefghij) | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| money | Written as a scaled floating point value (a money value). (A binary format) | Read as a scaled floating-point values (a money value). (A binary format) |\n| nchar(0) | Written as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value. | Read as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered. |\n| nvarchar(0) | Same as nchar(0) | Same as nchar(0) |\n| nchar(n) | Written as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| nvarchar(n) | Written as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding. The byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| smallint | Written as an integer of 2\u2011byte length. (A binary format.) | Read as integer of 2\u2011byte length. (A binary format) |\n| text(0) | Written as a variable length string. If a delimiter is specified, it is written after the value. If the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding. Copy into using text(0) format is the way to get variable width output with no padding. | Read as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value |\n| text(n) | Written as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding. | Reads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded. |\n| varchar(0) | Same as varchar(n), where n is the display length of the corresponding table column. | Read as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |",
            "| varchar(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length. | Read as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |",
            "Note: The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\n\nFor user-defined data types (UDTs), use char or varchar.\n\nCertainly. I'll create a single Markdown (.md) file based on the provided documentation, focusing on formatting the content without modifying it. Here's the Markdown version:\n\n### Delimiters in the Data File\n\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\n\n| Delimiter | Description |\n|-----------|-------------|\n| nl | Newline character |\n| tab | Tab character |\n| sp | Space |\n| csv | Comma separated values |\n| ssv | Semicolon separated values |\n| nul or null | Null/zero character |\n| comma | Comma |\n| colon | Colon |\n| dash | Dash |\n| lparen | Left parenthesis |\n| rparen | Right parenthesis |\n| X | Any non-numeric character |\n\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\n\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\n\n## CSV and SSV Delimiters\n\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\n\nThe rules for a CSV-delimited field are:\n\n- The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n- Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\n  ```\n  \"There is a double quote \"\" here\"\n  ```\n\n  is translated to the table value:\n\n  ```\n  There is a double quote \" here\n  ```\n\n  Whitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\n- Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\n\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\n\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \"counted\" formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)\n\nCopy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\n\n## With Null Clause for Copy\n\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\n\n### With Null (value) Clause\n\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\n\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.",
            "To prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\n\nFor example, this example of a value is incorrect:\n\n```\nc0comma with null(0)\n```\n\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\n\n```\nc0comma with null('0')\n```\n\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\n\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\n\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\n\n```sql\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\n```\n\nThe correct version specifies a 4-character format for the column.\n\n```sql\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\n```\n\n### With Null Clause Omitting Value\n\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\n\n## Filename Specification for Copy\n\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\n\nUNIX: For copy into, if the file already exists, copy overwrites it.\n\n## Windows File Types for Copy\n\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\n\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\n\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\n\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\n\nThe binary-copy forms (copy () from or copy () into) use binary mode.\n\nNote: Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.\n\nCopy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\n\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\n\n## With Clause for Copy\n\nValid with clause options for the copy statement are as follows:\n\n### On_error=TERMINATE|CONTINUE\n\nDirects copy to continue after encountering conversion errors.\n\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\n\nBy default, copy terminates when an error occurs while converting between table format and file format\n\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\n\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\n\n### Error_count=n\n\nSpecifies how many errors can occur before processing terminates.\n\nDefault: 1.\n\nIf on_error is set to continue, setting error_count has no effect.",
            "Default: 1.\n\nIf on_error is set to continue, setting error_count has no effect.\n\n### Log='filename'\n\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\n\nLogging works as follows:\n\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\n\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\n\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\n\n### Rollback=ENABLED|DISABLED\n\nEnables or disables rollback, as follows:\n\n- ENABLED: Directs the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\n- DISABLED: Retains the appended rows.\n\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\n\nDefault: ENABLED\n\nWhen copying to a file, the with rollback clause has no effect.\n\n### Row_estimate\n\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\n\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\n\n## Permissions\n\nTo use the copy statement, one of the following must apply:\n\n- You own the table.\n- The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n- You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\n\n## Locking\n\n- When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n- When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n- When performing a non-bulk copy into a table, the DBMS server takes an \"intent exclusive\" lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\n\n## Restrictions and Considerations\n\n- Copy cannot be used to add data to a view, index, or system catalog.\n- When copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\n- When copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\n- The copy statement does not fire any rules defined against the table.\n- Values cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\n- Copy treats a present-but-empty field in the data file as:\n  - A blank default for character-based columns\n  - A zero default for numeric columns\n  - December 31 00-1 for date and timestamp columns\n  - 00:00:00 for time columns (and the time component in a timestamp)",
            "For example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\n\n## Related Statements\n\n- Create Table Statement\n- Modify Statement\n\n## Examples--Copy Statement\n\nThe following examples illustrate the correct use of the copy statement:\n\n1. In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\n\n   ```\n   ename     char(15)\n   age       integer4\n   dept      char(10)\n   comment   varchar(20)\n   ```\n\n   The emp.txt file contains the following data:\n\n   ```\n   Jones,J. 32 Anytown,USA toy,00017A This is a comment\n   Smith,P. 41 New York,NY admin,00015 Another comment\n   ```\n\n   The following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\n   - A dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\n   - The department field is delimited by a comma.\n   - The comment field is a variable-length varchar field, preceded by a five-character length specifier.\n\n2. Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\n\n   ```sql\n   copy table employee (eno=integer2, ename=char(10),\n       age=integer2, job=integer2, sal=float4,\n       dept=integer2, xxx=d1)\n       from 'myfile.in';\n   ```\n\n3. Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\n\n   ```sql\n   copy table employee (ename=char(0)comma,\n       eno=char(0)comma, sal= char(0)nl)\n       into 'mfile.out';\n   ```\n\n   Joe Smith , 101, $25000.00\n   \n   Shirley Scott , 102, $30000.00\n\n4. The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\n\n   ```sql\n   copy table employee (ename = text(0)csv,\n       eno = text(0)csv, sal = text(0)csv)\n       into 'mfile.out';\n   ```\n    \n   Joe Smith,101,$25000.00\n   Shirley Scott,102,$30000.00\n\n5. Bulk copy the employee table into a file. The resulting data file contains binary data.\n\n   ```sql\n   copy table employee () into 'ourfile.dat';\n   ```\n\n6. Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\n\n   ```sql\n   copy table other_employee_table () from 'ourfile.dat';\n   ```\n\n7. Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\n\n   ```sql\n   copy table acct_recv\n       (acct_name=char(0)'%',\n       address='d0%',\n       credit=char(0)'%' with null('xx'),\n       debit=char(0)'%' with null('xx'),\n       acct_mngr=char(15),\n       xx=d0nl)\n       into 'qtr_result';\n   ```\n\n   Smith Corp%% $12345.00% $-67890.00%Jones\n   ABC Oil %% $54321.00% $-98765.00%Green\n   Spring Omc%%xx %xx %Namroc\n\n8. Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\n\n   ```sql\n   copy table gifts\n       (item_name=char(0)tab,\n       date_recd=char(0)tab,\n       sender=char(20)nl with null('anonymous'))\n       into 'giftdata';\n   ```\n\n   toaster 04-mar-1993 Nicholas\n   sled 10-oct-1993 anonymous\n   rocket 01-dec-1993 Francisco\n\n9. Create a table and load it using bulk copy, specifying structural options.\n\n   ```sql\n   create table mytable (name char 25, ...);\n   \n   modify mytable to hash;\n   \n   copy mytable() from 'myfile' with minpages = 16384,\n   maxpages = 16384, allocation = 16384;\n   ```"
        ]
    },
    {
        "instruction": "What options does Actian 4GL SQL COPY provide for handling duplicate rows during import and export operations?",
        "input": "",
        "output": "Actian 4GL SQL COPY provides two options to handle duplicate rows during import and export operations:\n- `noduplicates`: This option disallows duplicate rows from being inserted into the table. If a duplicate row is encountered during the copy operation, an error message is generated.\n- Log: When specified with log, copy places any duplicate rows that it cannot process into the specified log file. This option is only available if `on_error` is set to `CONTINUE`.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "# Copy Statement\n\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\n\nThis statement has the following syntax:\n\n```sql\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\n```\n\n## Parameters--Copy Statement\n\nThis statement has the following parameters:\n\n- **table_name**: Specifies an existing table from which data is read or to which data is written.\n- **column_name**: Specifies the column from which data is read or to which data is written.\n- **format**: Specifies the format in which a value is stored in the file.\n- **filename**: Specifies the file from which data is read or to which data is written.\n- **type**: (Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\n\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\n\n- **with_clause**: Consists of the word with, followed by a comma-separated list of one or more of the following items:\n  - on_error = TERMINATE | CONTINUE\n  - error_count = n\n  - rollback = ENABLED | DISABLED\n  - log = 'filename'\n\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\n- allocation = n\n- extend = n\n- fillfactor = n (ISAM, Hash, and Btree only)\n- minpages = n (Hash only)\n- maxpages = n (Hash only)\n- leaffill = n (Btree only)\n- nonleaffill = n (Btree only)\n- row_estimate = n\n\n## Unformatted Copying\n\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\n\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\n\n```sql\ncopy table employee () into 'emp_name';\n```\n\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\n\nNote: An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\n\n## Formatted Copying\n\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\n\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\n\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\n\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\n\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).",
            "The values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.\n\nNote: If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\n\n```sql\ncopy table t (col1=c20, col2=c30, d0=nl) into 't.out':\n```\n\n## Bulk Copying\n\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\n\nThe requirements for performing a bulk copy are:\n\n- The table is not journaled\n- The table has no secondary indexes\n- For storage structures other than heap, the table is empty and occupies fewer than 18 pages\n\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\n\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\n\n## Column Formats for Copy\n\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\n\nNote: When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\n\n### Character (Text) Formats\n\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\n\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\n\nThe subtle differences between the various character formats are described in Copy Format Details.\n\n### Counted Character Formats\n\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\n\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\n\nNote: Nvarchar(0) is not a counted format.\n\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\n\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\n\n### Dummy Format\n\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\n\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\n\n### Unicode Formats\n\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\n\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\n\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\n\n### Binary Formats",
            "### Binary Formats\n\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\n\nCertainly. I'll convert the provided documentation into a Markdown (.md) file format, maintaining the content while adjusting only the formatting. Here's the result:\n\n### Copy Format Details\n\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\n- Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n- When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n- The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\n\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).",
            "| Format | How Stored (copy into) | How Read (copy from) |\n|--------|------------------------|----------------------|\n| boolean | Written as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format) | Same format as copy into |\n| byte(0) | Same as byte(n) where n is the display length of the corresponding table column. | Read as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. |\n| byte(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded. |\n| byte varying(0) | Same as byte varying(n) where n is the display length of the table column. | Read as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |\n| byte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |\n| C0 | Same as Cn where n is the display length of the corresponding table column | Read as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Any control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\. |\n| Cn | Written as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Any control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\. |\n| char(0) | Same as char(n) where n is the display length of the corresponding table column. | Read as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Unlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is. |\n| char(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding. Unlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Unlike C format, char does not convert control characters or tabs. File data is read as is. |\n| D0 | Instead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.) Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed. | Dummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value. Any \\ found in the input means that the next character is to be taken literally, and is not a delimiter. |\n| Dn | Dummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1. | Dummy field. N characters are read and discarded. Copy from does not allow a delimiter specification with a fixed-length dummy field. |\n| date | Written as a date. (A binary format) | Read as a date. (A binary format) |\n| decimal | Written as a decimal number. (A binary format.) | Read as a decimal number. (A binary format) |\n| float | Written as double\u2011precision floating point. (A binary format) | Read as double\u2011precision floating point. (A binary format) |\n| float4 | Written as single\u2011precision floating point. (A binary format) | Read as single\u2011precision floating point. (A binary format) |\n| integer | Written as integer of 4\u2011byte length. (A binary format) | Read as integer of 4\u2011byte length. (A binary format) |",
            "| integer1 | Written as integer of 1\u2011byte length. (A binary format) | Read as integer of 1\u2011byte length. (A binary format) |\n| long byte(0) | Identical to long varchar | Identical to long varchar |\n| long nvarchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). The maximum segment size for the long nvarchar segment is 32727 bytes. The UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment. If a delimiter is specified, it is written immediately following the last segment. | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| long varchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767. The following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long: 5 abcde10 abcdefghij 0 (with a space after the terminating 0 character) (In this example, the data that is in the originating table column is abcdeabcdefghij) | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| money | Written as a scaled floating point value (a money value). (A binary format) | Read as a scaled floating-point values (a money value). (A binary format) |\n| nchar(0) | Written as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value. | Read as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered. |\n| nvarchar(0) | Same as nchar(0) | Same as nchar(0) |\n| nchar(n) | Written as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| nvarchar(n) | Written as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding. The byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| smallint | Written as an integer of 2\u2011byte length. (A binary format.) | Read as integer of 2\u2011byte length. (A binary format) |\n| text(0) | Written as a variable length string. If a delimiter is specified, it is written after the value. If the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding. Copy into using text(0) format is the way to get variable width output with no padding. | Read as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value |\n| text(n) | Written as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding. | Reads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded. |\n| varchar(0) | Same as varchar(n), where n is the display length of the corresponding table column. | Read as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |",
            "| varchar(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length. | Read as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |",
            "Note: The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\n\nFor user-defined data types (UDTs), use char or varchar.\n\nCertainly. I'll create a single Markdown (.md) file based on the provided documentation, focusing on formatting the content without modifying it. Here's the Markdown version:\n\n### Delimiters in the Data File\n\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\n\n| Delimiter | Description |\n|-----------|-------------|\n| nl | Newline character |\n| tab | Tab character |\n| sp | Space |\n| csv | Comma separated values |\n| ssv | Semicolon separated values |\n| nul or null | Null/zero character |\n| comma | Comma |\n| colon | Colon |\n| dash | Dash |\n| lparen | Left parenthesis |\n| rparen | Right parenthesis |\n| X | Any non-numeric character |\n\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\n\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\n\n## CSV and SSV Delimiters\n\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\n\nThe rules for a CSV-delimited field are:\n\n- The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n- Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\n  ```\n  \"There is a double quote \"\" here\"\n  ```\n\n  is translated to the table value:\n\n  ```\n  There is a double quote \" here\n  ```\n\n  Whitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\n- Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\n\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\n\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \"counted\" formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)\n\nCopy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\n\n## With Null Clause for Copy\n\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\n\n### With Null (value) Clause\n\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\n\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.",
            "To prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\n\nFor example, this example of a value is incorrect:\n\n```\nc0comma with null(0)\n```\n\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\n\n```\nc0comma with null('0')\n```\n\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\n\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\n\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\n\n```sql\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\n```\n\nThe correct version specifies a 4-character format for the column.\n\n```sql\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\n```\n\n### With Null Clause Omitting Value\n\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\n\n## Filename Specification for Copy\n\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\n\nUNIX: For copy into, if the file already exists, copy overwrites it.\n\n## Windows File Types for Copy\n\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\n\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\n\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\n\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\n\nThe binary-copy forms (copy () from or copy () into) use binary mode.\n\nNote: Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.\n\nCopy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\n\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\n\n## With Clause for Copy\n\nValid with clause options for the copy statement are as follows:\n\n### On_error=TERMINATE|CONTINUE\n\nDirects copy to continue after encountering conversion errors.\n\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\n\nBy default, copy terminates when an error occurs while converting between table format and file format\n\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\n\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\n\n### Error_count=n\n\nSpecifies how many errors can occur before processing terminates.\n\nDefault: 1.\n\nIf on_error is set to continue, setting error_count has no effect.",
            "Default: 1.\n\nIf on_error is set to continue, setting error_count has no effect.\n\n### Log='filename'\n\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\n\nLogging works as follows:\n\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\n\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\n\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\n\n### Rollback=ENABLED|DISABLED\n\nEnables or disables rollback, as follows:\n\n- ENABLED: Directs the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\n- DISABLED: Retains the appended rows.\n\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\n\nDefault: ENABLED\n\nWhen copying to a file, the with rollback clause has no effect.\n\n### Row_estimate\n\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\n\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\n\n## Permissions\n\nTo use the copy statement, one of the following must apply:\n\n- You own the table.\n- The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n- You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\n\n## Locking\n\n- When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n- When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n- When performing a non-bulk copy into a table, the DBMS server takes an \"intent exclusive\" lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\n\n## Restrictions and Considerations\n\n- Copy cannot be used to add data to a view, index, or system catalog.\n- When copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\n- When copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\n- The copy statement does not fire any rules defined against the table.\n- Values cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\n- Copy treats a present-but-empty field in the data file as:\n  - A blank default for character-based columns\n  - A zero default for numeric columns\n  - December 31 00-1 for date and timestamp columns\n  - 00:00:00 for time columns (and the time component in a timestamp)",
            "For example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\n\n## Related Statements\n\n- Create Table Statement\n- Modify Statement\n\n## Examples--Copy Statement\n\nThe following examples illustrate the correct use of the copy statement:\n\n1. In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\n\n   ```\n   ename     char(15)\n   age       integer4\n   dept      char(10)\n   comment   varchar(20)\n   ```\n\n   The emp.txt file contains the following data:\n\n   ```\n   Jones,J. 32 Anytown,USA toy,00017A This is a comment\n   Smith,P. 41 New York,NY admin,00015 Another comment\n   ```\n\n   The following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\n   - A dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\n   - The department field is delimited by a comma.\n   - The comment field is a variable-length varchar field, preceded by a five-character length specifier.\n\n2. Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\n\n   ```sql\n   copy table employee (eno=integer2, ename=char(10),\n       age=integer2, job=integer2, sal=float4,\n       dept=integer2, xxx=d1)\n       from 'myfile.in';\n   ```\n\n3. Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\n\n   ```sql\n   copy table employee (ename=char(0)comma,\n       eno=char(0)comma, sal= char(0)nl)\n       into 'mfile.out';\n   ```\n\n   Joe Smith , 101, $25000.00\n   \n   Shirley Scott , 102, $30000.00\n\n4. The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\n\n   ```sql\n   copy table employee (ename = text(0)csv,\n       eno = text(0)csv, sal = text(0)csv)\n       into 'mfile.out';\n   ```\n    \n   Joe Smith,101,$25000.00\n   Shirley Scott,102,$30000.00\n\n5. Bulk copy the employee table into a file. The resulting data file contains binary data.\n\n   ```sql\n   copy table employee () into 'ourfile.dat';\n   ```\n\n6. Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\n\n   ```sql\n   copy table other_employee_table () from 'ourfile.dat';\n   ```\n\n7. Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\n\n   ```sql\n   copy table acct_recv\n       (acct_name=char(0)'%',\n       address='d0%',\n       credit=char(0)'%' with null('xx'),\n       debit=char(0)'%' with null('xx'),\n       acct_mngr=char(15),\n       xx=d0nl)\n       into 'qtr_result';\n   ```\n\n   Smith Corp%% $12345.00% $-67890.00%Jones\n   ABC Oil %% $54321.00% $-98765.00%Green\n   Spring Omc%%xx %xx %Namroc\n\n8. Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\n\n   ```sql\n   copy table gifts\n       (item_name=char(0)tab,\n       date_recd=char(0)tab,\n       sender=char(20)nl with null('anonymous'))\n       into 'giftdata';\n   ```\n\n   toaster 04-mar-1993 Nicholas\n   sled 10-oct-1993 anonymous\n   rocket 01-dec-1993 Francisco\n\n9. Create a table and load it using bulk copy, specifying structural options.\n\n   ```sql\n   create table mytable (name char 25, ...);\n   \n   modify mytable to hash;\n   \n   copy mytable() from 'myfile' with minpages = 16384,\n   maxpages = 16384, allocation = 16384;\n   ```"
        ]
    },
    {
        "instruction": "What is the purpose of the `rollback=ENABLED|DISABLED` clause in Actian 4GL SQL COPY statements and what happens when it's set to each value?",
        "input": "",
        "output": "The `rollback=ENABLED|DISABLED` clause in Actian 4GL SQL COPY statements determines whether the DBMS Server rolls back the copy operation if an error occurs during the data transfer. If this option is set to `ENABLED`, any rows appended by the copy are rolled back if the copy process encounters an error and terminates prematurely. If it's set to `DISABLED`, the appended rows are retained even if an error occurs.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "# Copy Statement\n\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\n\nThis statement has the following syntax:\n\n```sql\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\n```\n\n## Parameters--Copy Statement\n\nThis statement has the following parameters:\n\n- **table_name**: Specifies an existing table from which data is read or to which data is written.\n- **column_name**: Specifies the column from which data is read or to which data is written.\n- **format**: Specifies the format in which a value is stored in the file.\n- **filename**: Specifies the file from which data is read or to which data is written.\n- **type**: (Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\n\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\n\n- **with_clause**: Consists of the word with, followed by a comma-separated list of one or more of the following items:\n  - on_error = TERMINATE | CONTINUE\n  - error_count = n\n  - rollback = ENABLED | DISABLED\n  - log = 'filename'\n\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\n- allocation = n\n- extend = n\n- fillfactor = n (ISAM, Hash, and Btree only)\n- minpages = n (Hash only)\n- maxpages = n (Hash only)\n- leaffill = n (Btree only)\n- nonleaffill = n (Btree only)\n- row_estimate = n\n\n## Unformatted Copying\n\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\n\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\n\n```sql\ncopy table employee () into 'emp_name';\n```\n\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\n\nNote: An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\n\n## Formatted Copying\n\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\n\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\n\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\n\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\n\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).",
            "The values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.\n\nNote: If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\n\n```sql\ncopy table t (col1=c20, col2=c30, d0=nl) into 't.out':\n```\n\n## Bulk Copying\n\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\n\nThe requirements for performing a bulk copy are:\n\n- The table is not journaled\n- The table has no secondary indexes\n- For storage structures other than heap, the table is empty and occupies fewer than 18 pages\n\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\n\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\n\n## Column Formats for Copy\n\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\n\nNote: When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\n\n### Character (Text) Formats\n\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\n\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\n\nThe subtle differences between the various character formats are described in Copy Format Details.\n\n### Counted Character Formats\n\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\n\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\n\nNote: Nvarchar(0) is not a counted format.\n\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\n\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\n\n### Dummy Format\n\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\n\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\n\n### Unicode Formats\n\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\n\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\n\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\n\n### Binary Formats",
            "### Binary Formats\n\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\n\nCertainly. I'll convert the provided documentation into a Markdown (.md) file format, maintaining the content while adjusting only the formatting. Here's the result:\n\n### Copy Format Details\n\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\n- Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n- When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n- The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\n\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).",
            "| Format | How Stored (copy into) | How Read (copy from) |\n|--------|------------------------|----------------------|\n| boolean | Written as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format) | Same format as copy into |\n| byte(0) | Same as byte(n) where n is the display length of the corresponding table column. | Read as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. |\n| byte(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded. |\n| byte varying(0) | Same as byte varying(n) where n is the display length of the table column. | Read as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |\n| byte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |\n| C0 | Same as Cn where n is the display length of the corresponding table column | Read as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Any control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\. |\n| Cn | Written as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Any control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\. |\n| char(0) | Same as char(n) where n is the display length of the corresponding table column. | Read as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Unlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is. |\n| char(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding. Unlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Unlike C format, char does not convert control characters or tabs. File data is read as is. |\n| D0 | Instead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.) Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed. | Dummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value. Any \\ found in the input means that the next character is to be taken literally, and is not a delimiter. |\n| Dn | Dummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1. | Dummy field. N characters are read and discarded. Copy from does not allow a delimiter specification with a fixed-length dummy field. |\n| date | Written as a date. (A binary format) | Read as a date. (A binary format) |\n| decimal | Written as a decimal number. (A binary format.) | Read as a decimal number. (A binary format) |\n| float | Written as double\u2011precision floating point. (A binary format) | Read as double\u2011precision floating point. (A binary format) |\n| float4 | Written as single\u2011precision floating point. (A binary format) | Read as single\u2011precision floating point. (A binary format) |\n| integer | Written as integer of 4\u2011byte length. (A binary format) | Read as integer of 4\u2011byte length. (A binary format) |",
            "| integer1 | Written as integer of 1\u2011byte length. (A binary format) | Read as integer of 1\u2011byte length. (A binary format) |\n| long byte(0) | Identical to long varchar | Identical to long varchar |\n| long nvarchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). The maximum segment size for the long nvarchar segment is 32727 bytes. The UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment. If a delimiter is specified, it is written immediately following the last segment. | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| long varchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767. The following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long: 5 abcde10 abcdefghij 0 (with a space after the terminating 0 character) (In this example, the data that is in the originating table column is abcdeabcdefghij) | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| money | Written as a scaled floating point value (a money value). (A binary format) | Read as a scaled floating-point values (a money value). (A binary format) |\n| nchar(0) | Written as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value. | Read as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered. |\n| nvarchar(0) | Same as nchar(0) | Same as nchar(0) |\n| nchar(n) | Written as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| nvarchar(n) | Written as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding. The byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| smallint | Written as an integer of 2\u2011byte length. (A binary format.) | Read as integer of 2\u2011byte length. (A binary format) |\n| text(0) | Written as a variable length string. If a delimiter is specified, it is written after the value. If the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding. Copy into using text(0) format is the way to get variable width output with no padding. | Read as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value |\n| text(n) | Written as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding. | Reads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded. |\n| varchar(0) | Same as varchar(n), where n is the display length of the corresponding table column. | Read as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |",
            "| varchar(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length. | Read as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |",
            "Note: The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\n\nFor user-defined data types (UDTs), use char or varchar.\n\nCertainly. I'll create a single Markdown (.md) file based on the provided documentation, focusing on formatting the content without modifying it. Here's the Markdown version:\n\n### Delimiters in the Data File\n\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\n\n| Delimiter | Description |\n|-----------|-------------|\n| nl | Newline character |\n| tab | Tab character |\n| sp | Space |\n| csv | Comma separated values |\n| ssv | Semicolon separated values |\n| nul or null | Null/zero character |\n| comma | Comma |\n| colon | Colon |\n| dash | Dash |\n| lparen | Left parenthesis |\n| rparen | Right parenthesis |\n| X | Any non-numeric character |\n\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\n\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\n\n## CSV and SSV Delimiters\n\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\n\nThe rules for a CSV-delimited field are:\n\n- The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n- Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\n  ```\n  \"There is a double quote \"\" here\"\n  ```\n\n  is translated to the table value:\n\n  ```\n  There is a double quote \" here\n  ```\n\n  Whitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\n- Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\n\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\n\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \"counted\" formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)\n\nCopy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\n\n## With Null Clause for Copy\n\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\n\n### With Null (value) Clause\n\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\n\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.",
            "To prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\n\nFor example, this example of a value is incorrect:\n\n```\nc0comma with null(0)\n```\n\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\n\n```\nc0comma with null('0')\n```\n\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\n\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\n\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\n\n```sql\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\n```\n\nThe correct version specifies a 4-character format for the column.\n\n```sql\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\n```\n\n### With Null Clause Omitting Value\n\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\n\n## Filename Specification for Copy\n\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\n\nUNIX: For copy into, if the file already exists, copy overwrites it.\n\n## Windows File Types for Copy\n\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\n\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\n\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\n\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\n\nThe binary-copy forms (copy () from or copy () into) use binary mode.\n\nNote: Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.\n\nCopy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\n\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\n\n## With Clause for Copy\n\nValid with clause options for the copy statement are as follows:\n\n### On_error=TERMINATE|CONTINUE\n\nDirects copy to continue after encountering conversion errors.\n\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\n\nBy default, copy terminates when an error occurs while converting between table format and file format\n\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\n\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\n\n### Error_count=n\n\nSpecifies how many errors can occur before processing terminates.\n\nDefault: 1.\n\nIf on_error is set to continue, setting error_count has no effect.",
            "Default: 1.\n\nIf on_error is set to continue, setting error_count has no effect.\n\n### Log='filename'\n\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\n\nLogging works as follows:\n\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\n\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\n\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\n\n### Rollback=ENABLED|DISABLED\n\nEnables or disables rollback, as follows:\n\n- ENABLED: Directs the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\n- DISABLED: Retains the appended rows.\n\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\n\nDefault: ENABLED\n\nWhen copying to a file, the with rollback clause has no effect.\n\n### Row_estimate\n\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\n\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\n\n## Permissions\n\nTo use the copy statement, one of the following must apply:\n\n- You own the table.\n- The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n- You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\n\n## Locking\n\n- When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n- When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n- When performing a non-bulk copy into a table, the DBMS server takes an \"intent exclusive\" lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\n\n## Restrictions and Considerations\n\n- Copy cannot be used to add data to a view, index, or system catalog.\n- When copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\n- When copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\n- The copy statement does not fire any rules defined against the table.\n- Values cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\n- Copy treats a present-but-empty field in the data file as:\n  - A blank default for character-based columns\n  - A zero default for numeric columns\n  - December 31 00-1 for date and timestamp columns\n  - 00:00:00 for time columns (and the time component in a timestamp)",
            "For example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\n\n## Related Statements\n\n- Create Table Statement\n- Modify Statement\n\n## Examples--Copy Statement\n\nThe following examples illustrate the correct use of the copy statement:\n\n1. In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\n\n   ```\n   ename     char(15)\n   age       integer4\n   dept      char(10)\n   comment   varchar(20)\n   ```\n\n   The emp.txt file contains the following data:\n\n   ```\n   Jones,J. 32 Anytown,USA toy,00017A This is a comment\n   Smith,P. 41 New York,NY admin,00015 Another comment\n   ```\n\n   The following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\n   - A dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\n   - The department field is delimited by a comma.\n   - The comment field is a variable-length varchar field, preceded by a five-character length specifier.\n\n2. Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\n\n   ```sql\n   copy table employee (eno=integer2, ename=char(10),\n       age=integer2, job=integer2, sal=float4,\n       dept=integer2, xxx=d1)\n       from 'myfile.in';\n   ```\n\n3. Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\n\n   ```sql\n   copy table employee (ename=char(0)comma,\n       eno=char(0)comma, sal= char(0)nl)\n       into 'mfile.out';\n   ```\n\n   Joe Smith , 101, $25000.00\n   \n   Shirley Scott , 102, $30000.00\n\n4. The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\n\n   ```sql\n   copy table employee (ename = text(0)csv,\n       eno = text(0)csv, sal = text(0)csv)\n       into 'mfile.out';\n   ```\n    \n   Joe Smith,101,$25000.00\n   Shirley Scott,102,$30000.00\n\n5. Bulk copy the employee table into a file. The resulting data file contains binary data.\n\n   ```sql\n   copy table employee () into 'ourfile.dat';\n   ```\n\n6. Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\n\n   ```sql\n   copy table other_employee_table () from 'ourfile.dat';\n   ```\n\n7. Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\n\n   ```sql\n   copy table acct_recv\n       (acct_name=char(0)'%',\n       address='d0%',\n       credit=char(0)'%' with null('xx'),\n       debit=char(0)'%' with null('xx'),\n       acct_mngr=char(15),\n       xx=d0nl)\n       into 'qtr_result';\n   ```\n\n   Smith Corp%% $12345.00% $-67890.00%Jones\n   ABC Oil %% $54321.00% $-98765.00%Green\n   Spring Omc%%xx %xx %Namroc\n\n8. Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\n\n   ```sql\n   copy table gifts\n       (item_name=char(0)tab,\n       date_recd=char(0)tab,\n       sender=char(20)nl with null('anonymous'))\n       into 'giftdata';\n   ```\n\n   toaster 04-mar-1993 Nicholas\n   sled 10-oct-1993 anonymous\n   rocket 01-dec-1993 Francisco\n\n9. Create a table and load it using bulk copy, specifying structural options.\n\n   ```sql\n   create table mytable (name char 25, ...);\n   \n   modify mytable to hash;\n   \n   copy mytable() from 'myfile' with minpages = 16384,\n   maxpages = 16384, allocation = 16384;\n   ```"
        ]
    },
    {
        "instruction": "Describe the difference between formatted and unformatted copying in Actian 4GL SQL COPY statements.",
        "input": "",
        "output": "Formatted copying specifies the format of individual columns within a data file, while unformatted copying skips this step by assuming that all columns have the same format as the table being copied. Formatted copying is useful when dealing with heterogeneous data where column formats differ, while unformatted copying is efficient for homogeneous data where consistent formatting across columns can be assumed.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "# Copy Statement\n\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\n\nThis statement has the following syntax:\n\n```sql\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\n```\n\n## Parameters--Copy Statement\n\nThis statement has the following parameters:\n\n- **table_name**: Specifies an existing table from which data is read or to which data is written.\n- **column_name**: Specifies the column from which data is read or to which data is written.\n- **format**: Specifies the format in which a value is stored in the file.\n- **filename**: Specifies the file from which data is read or to which data is written.\n- **type**: (Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\n\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\n\n- **with_clause**: Consists of the word with, followed by a comma-separated list of one or more of the following items:\n  - on_error = TERMINATE | CONTINUE\n  - error_count = n\n  - rollback = ENABLED | DISABLED\n  - log = 'filename'\n\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\n- allocation = n\n- extend = n\n- fillfactor = n (ISAM, Hash, and Btree only)\n- minpages = n (Hash only)\n- maxpages = n (Hash only)\n- leaffill = n (Btree only)\n- nonleaffill = n (Btree only)\n- row_estimate = n\n\n## Unformatted Copying\n\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\n\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\n\n```sql\ncopy table employee () into 'emp_name';\n```\n\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\n\nNote: An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\n\n## Formatted Copying\n\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\n\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\n\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\n\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\n\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).",
            "The values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.\n\nNote: If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\n\n```sql\ncopy table t (col1=c20, col2=c30, d0=nl) into 't.out':\n```\n\n## Bulk Copying\n\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\n\nThe requirements for performing a bulk copy are:\n\n- The table is not journaled\n- The table has no secondary indexes\n- For storage structures other than heap, the table is empty and occupies fewer than 18 pages\n\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\n\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\n\n## Column Formats for Copy\n\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\n\nNote: When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\n\n### Character (Text) Formats\n\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\n\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\n\nThe subtle differences between the various character formats are described in Copy Format Details.\n\n### Counted Character Formats\n\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\n\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\n\nNote: Nvarchar(0) is not a counted format.\n\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\n\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\n\n### Dummy Format\n\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\n\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\n\n### Unicode Formats\n\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\n\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\n\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\n\n### Binary Formats",
            "### Binary Formats\n\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\n\nCertainly. I'll convert the provided documentation into a Markdown (.md) file format, maintaining the content while adjusting only the formatting. Here's the result:\n\n### Copy Format Details\n\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\n- Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n- When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n- The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\n\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).",
            "| Format | How Stored (copy into) | How Read (copy from) |\n|--------|------------------------|----------------------|\n| boolean | Written as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format) | Same format as copy into |\n| byte(0) | Same as byte(n) where n is the display length of the corresponding table column. | Read as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. |\n| byte(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded. |\n| byte varying(0) | Same as byte varying(n) where n is the display length of the table column. | Read as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |\n| byte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |\n| C0 | Same as Cn where n is the display length of the corresponding table column | Read as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Any control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\. |\n| Cn | Written as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Any control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\. |\n| char(0) | Same as char(n) where n is the display length of the corresponding table column. | Read as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Unlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is. |\n| char(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding. Unlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Unlike C format, char does not convert control characters or tabs. File data is read as is. |\n| D0 | Instead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.) Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed. | Dummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value. Any \\ found in the input means that the next character is to be taken literally, and is not a delimiter. |\n| Dn | Dummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1. | Dummy field. N characters are read and discarded. Copy from does not allow a delimiter specification with a fixed-length dummy field. |\n| date | Written as a date. (A binary format) | Read as a date. (A binary format) |\n| decimal | Written as a decimal number. (A binary format.) | Read as a decimal number. (A binary format) |\n| float | Written as double\u2011precision floating point. (A binary format) | Read as double\u2011precision floating point. (A binary format) |\n| float4 | Written as single\u2011precision floating point. (A binary format) | Read as single\u2011precision floating point. (A binary format) |\n| integer | Written as integer of 4\u2011byte length. (A binary format) | Read as integer of 4\u2011byte length. (A binary format) |",
            "| integer1 | Written as integer of 1\u2011byte length. (A binary format) | Read as integer of 1\u2011byte length. (A binary format) |\n| long byte(0) | Identical to long varchar | Identical to long varchar |\n| long nvarchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). The maximum segment size for the long nvarchar segment is 32727 bytes. The UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment. If a delimiter is specified, it is written immediately following the last segment. | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| long varchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767. The following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long: 5 abcde10 abcdefghij 0 (with a space after the terminating 0 character) (In this example, the data that is in the originating table column is abcdeabcdefghij) | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| money | Written as a scaled floating point value (a money value). (A binary format) | Read as a scaled floating-point values (a money value). (A binary format) |\n| nchar(0) | Written as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value. | Read as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered. |\n| nvarchar(0) | Same as nchar(0) | Same as nchar(0) |\n| nchar(n) | Written as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| nvarchar(n) | Written as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding. The byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| smallint | Written as an integer of 2\u2011byte length. (A binary format.) | Read as integer of 2\u2011byte length. (A binary format) |\n| text(0) | Written as a variable length string. If a delimiter is specified, it is written after the value. If the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding. Copy into using text(0) format is the way to get variable width output with no padding. | Read as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value |\n| text(n) | Written as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding. | Reads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded. |\n| varchar(0) | Same as varchar(n), where n is the display length of the corresponding table column. | Read as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |",
            "| varchar(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length. | Read as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |",
            "Note: The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\n\nFor user-defined data types (UDTs), use char or varchar.\n\nCertainly. I'll create a single Markdown (.md) file based on the provided documentation, focusing on formatting the content without modifying it. Here's the Markdown version:\n\n### Delimiters in the Data File\n\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\n\n| Delimiter | Description |\n|-----------|-------------|\n| nl | Newline character |\n| tab | Tab character |\n| sp | Space |\n| csv | Comma separated values |\n| ssv | Semicolon separated values |\n| nul or null | Null/zero character |\n| comma | Comma |\n| colon | Colon |\n| dash | Dash |\n| lparen | Left parenthesis |\n| rparen | Right parenthesis |\n| X | Any non-numeric character |\n\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\n\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\n\n## CSV and SSV Delimiters\n\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\n\nThe rules for a CSV-delimited field are:\n\n- The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n- Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\n  ```\n  \"There is a double quote \"\" here\"\n  ```\n\n  is translated to the table value:\n\n  ```\n  There is a double quote \" here\n  ```\n\n  Whitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\n- Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\n\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\n\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \"counted\" formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)\n\nCopy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\n\n## With Null Clause for Copy\n\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\n\n### With Null (value) Clause\n\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\n\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.",
            "To prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\n\nFor example, this example of a value is incorrect:\n\n```\nc0comma with null(0)\n```\n\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\n\n```\nc0comma with null('0')\n```\n\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\n\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\n\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\n\n```sql\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\n```\n\nThe correct version specifies a 4-character format for the column.\n\n```sql\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\n```\n\n### With Null Clause Omitting Value\n\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\n\n## Filename Specification for Copy\n\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\n\nUNIX: For copy into, if the file already exists, copy overwrites it.\n\n## Windows File Types for Copy\n\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\n\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\n\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\n\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\n\nThe binary-copy forms (copy () from or copy () into) use binary mode.\n\nNote: Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.\n\nCopy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\n\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\n\n## With Clause for Copy\n\nValid with clause options for the copy statement are as follows:\n\n### On_error=TERMINATE|CONTINUE\n\nDirects copy to continue after encountering conversion errors.\n\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\n\nBy default, copy terminates when an error occurs while converting between table format and file format\n\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\n\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\n\n### Error_count=n\n\nSpecifies how many errors can occur before processing terminates.\n\nDefault: 1.\n\nIf on_error is set to continue, setting error_count has no effect.",
            "Default: 1.\n\nIf on_error is set to continue, setting error_count has no effect.\n\n### Log='filename'\n\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\n\nLogging works as follows:\n\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\n\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\n\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\n\n### Rollback=ENABLED|DISABLED\n\nEnables or disables rollback, as follows:\n\n- ENABLED: Directs the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\n- DISABLED: Retains the appended rows.\n\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\n\nDefault: ENABLED\n\nWhen copying to a file, the with rollback clause has no effect.\n\n### Row_estimate\n\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\n\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\n\n## Permissions\n\nTo use the copy statement, one of the following must apply:\n\n- You own the table.\n- The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n- You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\n\n## Locking\n\n- When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n- When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n- When performing a non-bulk copy into a table, the DBMS server takes an \"intent exclusive\" lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\n\n## Restrictions and Considerations\n\n- Copy cannot be used to add data to a view, index, or system catalog.\n- When copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\n- When copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\n- The copy statement does not fire any rules defined against the table.\n- Values cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\n- Copy treats a present-but-empty field in the data file as:\n  - A blank default for character-based columns\n  - A zero default for numeric columns\n  - December 31 00-1 for date and timestamp columns\n  - 00:00:00 for time columns (and the time component in a timestamp)",
            "For example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\n\n## Related Statements\n\n- Create Table Statement\n- Modify Statement\n\n## Examples--Copy Statement\n\nThe following examples illustrate the correct use of the copy statement:\n\n1. In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\n\n   ```\n   ename     char(15)\n   age       integer4\n   dept      char(10)\n   comment   varchar(20)\n   ```\n\n   The emp.txt file contains the following data:\n\n   ```\n   Jones,J. 32 Anytown,USA toy,00017A This is a comment\n   Smith,P. 41 New York,NY admin,00015 Another comment\n   ```\n\n   The following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\n   - A dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\n   - The department field is delimited by a comma.\n   - The comment field is a variable-length varchar field, preceded by a five-character length specifier.\n\n2. Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\n\n   ```sql\n   copy table employee (eno=integer2, ename=char(10),\n       age=integer2, job=integer2, sal=float4,\n       dept=integer2, xxx=d1)\n       from 'myfile.in';\n   ```\n\n3. Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\n\n   ```sql\n   copy table employee (ename=char(0)comma,\n       eno=char(0)comma, sal= char(0)nl)\n       into 'mfile.out';\n   ```\n\n   Joe Smith , 101, $25000.00\n   \n   Shirley Scott , 102, $30000.00\n\n4. The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\n\n   ```sql\n   copy table employee (ename = text(0)csv,\n       eno = text(0)csv, sal = text(0)csv)\n       into 'mfile.out';\n   ```\n    \n   Joe Smith,101,$25000.00\n   Shirley Scott,102,$30000.00\n\n5. Bulk copy the employee table into a file. The resulting data file contains binary data.\n\n   ```sql\n   copy table employee () into 'ourfile.dat';\n   ```\n\n6. Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\n\n   ```sql\n   copy table other_employee_table () from 'ourfile.dat';\n   ```\n\n7. Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\n\n   ```sql\n   copy table acct_recv\n       (acct_name=char(0)'%',\n       address='d0%',\n       credit=char(0)'%' with null('xx'),\n       debit=char(0)'%' with null('xx'),\n       acct_mngr=char(15),\n       xx=d0nl)\n       into 'qtr_result';\n   ```\n\n   Smith Corp%% $12345.00% $-67890.00%Jones\n   ABC Oil %% $54321.00% $-98765.00%Green\n   Spring Omc%%xx %xx %Namroc\n\n8. Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\n\n   ```sql\n   copy table gifts\n       (item_name=char(0)tab,\n       date_recd=char(0)tab,\n       sender=char(20)nl with null('anonymous'))\n       into 'giftdata';\n   ```\n\n   toaster 04-mar-1993 Nicholas\n   sled 10-oct-1993 anonymous\n   rocket 01-dec-1993 Francisco\n\n9. Create a table and load it using bulk copy, specifying structural options.\n\n   ```sql\n   create table mytable (name char 25, ...);\n   \n   modify mytable to hash;\n   \n   copy mytable() from 'myfile' with minpages = 16384,\n   maxpages = 16384, allocation = 16384;\n   ```"
        ]
    },
    {
        "instruction": "What is the purpose of delimiters in Actian 4GL SQL COPY statements and what options are available to specify them?",
        "input": "",
        "output": "Delimiters separate data values within a text file, allowing the copy statement to understand where one record ends and another begins. In Actian 4GL SQL COPY, you can specify delimiters using the delim option in the format section of the COPY INTO statement. Available options for this parameter include comma, semicolon, tab, and pipe characters. Additionally, you can customize the delimiter by specifying a unique string as your custom delimiter.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "# Copy Statement\n\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\n\nThis statement has the following syntax:\n\n```sql\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\n```\n\n## Parameters--Copy Statement\n\nThis statement has the following parameters:\n\n- **table_name**: Specifies an existing table from which data is read or to which data is written.\n- **column_name**: Specifies the column from which data is read or to which data is written.\n- **format**: Specifies the format in which a value is stored in the file.\n- **filename**: Specifies the file from which data is read or to which data is written.\n- **type**: (Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\n\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\n\n- **with_clause**: Consists of the word with, followed by a comma-separated list of one or more of the following items:\n  - on_error = TERMINATE | CONTINUE\n  - error_count = n\n  - rollback = ENABLED | DISABLED\n  - log = 'filename'\n\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\n- allocation = n\n- extend = n\n- fillfactor = n (ISAM, Hash, and Btree only)\n- minpages = n (Hash only)\n- maxpages = n (Hash only)\n- leaffill = n (Btree only)\n- nonleaffill = n (Btree only)\n- row_estimate = n\n\n## Unformatted Copying\n\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\n\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\n\n```sql\ncopy table employee () into 'emp_name';\n```\n\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\n\nNote: An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\n\n## Formatted Copying\n\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\n\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\n\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\n\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\n\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).",
            "The values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.\n\nNote: If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\n\n```sql\ncopy table t (col1=c20, col2=c30, d0=nl) into 't.out':\n```\n\n## Bulk Copying\n\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\n\nThe requirements for performing a bulk copy are:\n\n- The table is not journaled\n- The table has no secondary indexes\n- For storage structures other than heap, the table is empty and occupies fewer than 18 pages\n\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\n\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\n\n## Column Formats for Copy\n\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\n\nNote: When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\n\n### Character (Text) Formats\n\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\n\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\n\nThe subtle differences between the various character formats are described in Copy Format Details.\n\n### Counted Character Formats\n\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\n\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\n\nNote: Nvarchar(0) is not a counted format.\n\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\n\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\n\n### Dummy Format\n\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\n\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\n\n### Unicode Formats\n\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\n\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\n\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\n\n### Binary Formats",
            "### Binary Formats\n\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\n\nCertainly. I'll convert the provided documentation into a Markdown (.md) file format, maintaining the content while adjusting only the formatting. Here's the result:\n\n### Copy Format Details\n\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\n- Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n- When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n- The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\n\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).",
            "| Format | How Stored (copy into) | How Read (copy from) |\n|--------|------------------------|----------------------|\n| boolean | Written as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format) | Same format as copy into |\n| byte(0) | Same as byte(n) where n is the display length of the corresponding table column. | Read as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. |\n| byte(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded. |\n| byte varying(0) | Same as byte varying(n) where n is the display length of the table column. | Read as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |\n| byte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |\n| C0 | Same as Cn where n is the display length of the corresponding table column | Read as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Any control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\. |\n| Cn | Written as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Any control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\. |\n| char(0) | Same as char(n) where n is the display length of the corresponding table column. | Read as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Unlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is. |\n| char(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding. Unlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Unlike C format, char does not convert control characters or tabs. File data is read as is. |\n| D0 | Instead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.) Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed. | Dummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value. Any \\ found in the input means that the next character is to be taken literally, and is not a delimiter. |\n| Dn | Dummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1. | Dummy field. N characters are read and discarded. Copy from does not allow a delimiter specification with a fixed-length dummy field. |\n| date | Written as a date. (A binary format) | Read as a date. (A binary format) |\n| decimal | Written as a decimal number. (A binary format.) | Read as a decimal number. (A binary format) |\n| float | Written as double\u2011precision floating point. (A binary format) | Read as double\u2011precision floating point. (A binary format) |\n| float4 | Written as single\u2011precision floating point. (A binary format) | Read as single\u2011precision floating point. (A binary format) |\n| integer | Written as integer of 4\u2011byte length. (A binary format) | Read as integer of 4\u2011byte length. (A binary format) |",
            "| integer1 | Written as integer of 1\u2011byte length. (A binary format) | Read as integer of 1\u2011byte length. (A binary format) |\n| long byte(0) | Identical to long varchar | Identical to long varchar |\n| long nvarchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). The maximum segment size for the long nvarchar segment is 32727 bytes. The UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment. If a delimiter is specified, it is written immediately following the last segment. | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| long varchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767. The following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long: 5 abcde10 abcdefghij 0 (with a space after the terminating 0 character) (In this example, the data that is in the originating table column is abcdeabcdefghij) | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| money | Written as a scaled floating point value (a money value). (A binary format) | Read as a scaled floating-point values (a money value). (A binary format) |\n| nchar(0) | Written as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value. | Read as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered. |\n| nvarchar(0) | Same as nchar(0) | Same as nchar(0) |\n| nchar(n) | Written as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| nvarchar(n) | Written as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding. The byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| smallint | Written as an integer of 2\u2011byte length. (A binary format.) | Read as integer of 2\u2011byte length. (A binary format) |\n| text(0) | Written as a variable length string. If a delimiter is specified, it is written after the value. If the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding. Copy into using text(0) format is the way to get variable width output with no padding. | Read as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value |\n| text(n) | Written as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding. | Reads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded. |\n| varchar(0) | Same as varchar(n), where n is the display length of the corresponding table column. | Read as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |",
            "| varchar(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length. | Read as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |",
            "Note: The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\n\nFor user-defined data types (UDTs), use char or varchar.\n\nCertainly. I'll create a single Markdown (.md) file based on the provided documentation, focusing on formatting the content without modifying it. Here's the Markdown version:\n\n### Delimiters in the Data File\n\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\n\n| Delimiter | Description |\n|-----------|-------------|\n| nl | Newline character |\n| tab | Tab character |\n| sp | Space |\n| csv | Comma separated values |\n| ssv | Semicolon separated values |\n| nul or null | Null/zero character |\n| comma | Comma |\n| colon | Colon |\n| dash | Dash |\n| lparen | Left parenthesis |\n| rparen | Right parenthesis |\n| X | Any non-numeric character |\n\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\n\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\n\n## CSV and SSV Delimiters\n\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\n\nThe rules for a CSV-delimited field are:\n\n- The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n- Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\n  ```\n  \"There is a double quote \"\" here\"\n  ```\n\n  is translated to the table value:\n\n  ```\n  There is a double quote \" here\n  ```\n\n  Whitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\n- Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\n\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\n\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \"counted\" formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)\n\nCopy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\n\n## With Null Clause for Copy\n\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\n\n### With Null (value) Clause\n\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\n\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.",
            "To prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\n\nFor example, this example of a value is incorrect:\n\n```\nc0comma with null(0)\n```\n\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\n\n```\nc0comma with null('0')\n```\n\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\n\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\n\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\n\n```sql\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\n```\n\nThe correct version specifies a 4-character format for the column.\n\n```sql\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\n```\n\n### With Null Clause Omitting Value\n\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\n\n## Filename Specification for Copy\n\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\n\nUNIX: For copy into, if the file already exists, copy overwrites it.\n\n## Windows File Types for Copy\n\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\n\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\n\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\n\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\n\nThe binary-copy forms (copy () from or copy () into) use binary mode.\n\nNote: Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.\n\nCopy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\n\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\n\n## With Clause for Copy\n\nValid with clause options for the copy statement are as follows:\n\n### On_error=TERMINATE|CONTINUE\n\nDirects copy to continue after encountering conversion errors.\n\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\n\nBy default, copy terminates when an error occurs while converting between table format and file format\n\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\n\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\n\n### Error_count=n\n\nSpecifies how many errors can occur before processing terminates.\n\nDefault: 1.\n\nIf on_error is set to continue, setting error_count has no effect.",
            "Default: 1.\n\nIf on_error is set to continue, setting error_count has no effect.\n\n### Log='filename'\n\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\n\nLogging works as follows:\n\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\n\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\n\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\n\n### Rollback=ENABLED|DISABLED\n\nEnables or disables rollback, as follows:\n\n- ENABLED: Directs the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\n- DISABLED: Retains the appended rows.\n\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\n\nDefault: ENABLED\n\nWhen copying to a file, the with rollback clause has no effect.\n\n### Row_estimate\n\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\n\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\n\n## Permissions\n\nTo use the copy statement, one of the following must apply:\n\n- You own the table.\n- The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n- You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\n\n## Locking\n\n- When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n- When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n- When performing a non-bulk copy into a table, the DBMS server takes an \"intent exclusive\" lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\n\n## Restrictions and Considerations\n\n- Copy cannot be used to add data to a view, index, or system catalog.\n- When copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\n- When copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\n- The copy statement does not fire any rules defined against the table.\n- Values cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\n- Copy treats a present-but-empty field in the data file as:\n  - A blank default for character-based columns\n  - A zero default for numeric columns\n  - December 31 00-1 for date and timestamp columns\n  - 00:00:00 for time columns (and the time component in a timestamp)",
            "For example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\n\n## Related Statements\n\n- Create Table Statement\n- Modify Statement\n\n## Examples--Copy Statement\n\nThe following examples illustrate the correct use of the copy statement:\n\n1. In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\n\n   ```\n   ename     char(15)\n   age       integer4\n   dept      char(10)\n   comment   varchar(20)\n   ```\n\n   The emp.txt file contains the following data:\n\n   ```\n   Jones,J. 32 Anytown,USA toy,00017A This is a comment\n   Smith,P. 41 New York,NY admin,00015 Another comment\n   ```\n\n   The following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\n   - A dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\n   - The department field is delimited by a comma.\n   - The comment field is a variable-length varchar field, preceded by a five-character length specifier.\n\n2. Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\n\n   ```sql\n   copy table employee (eno=integer2, ename=char(10),\n       age=integer2, job=integer2, sal=float4,\n       dept=integer2, xxx=d1)\n       from 'myfile.in';\n   ```\n\n3. Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\n\n   ```sql\n   copy table employee (ename=char(0)comma,\n       eno=char(0)comma, sal= char(0)nl)\n       into 'mfile.out';\n   ```\n\n   Joe Smith , 101, $25000.00\n   \n   Shirley Scott , 102, $30000.00\n\n4. The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\n\n   ```sql\n   copy table employee (ename = text(0)csv,\n       eno = text(0)csv, sal = text(0)csv)\n       into 'mfile.out';\n   ```\n    \n   Joe Smith,101,$25000.00\n   Shirley Scott,102,$30000.00\n\n5. Bulk copy the employee table into a file. The resulting data file contains binary data.\n\n   ```sql\n   copy table employee () into 'ourfile.dat';\n   ```\n\n6. Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\n\n   ```sql\n   copy table other_employee_table () from 'ourfile.dat';\n   ```\n\n7. Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\n\n   ```sql\n   copy table acct_recv\n       (acct_name=char(0)'%',\n       address='d0%',\n       credit=char(0)'%' with null('xx'),\n       debit=char(0)'%' with null('xx'),\n       acct_mngr=char(15),\n       xx=d0nl)\n       into 'qtr_result';\n   ```\n\n   Smith Corp%% $12345.00% $-67890.00%Jones\n   ABC Oil %% $54321.00% $-98765.00%Green\n   Spring Omc%%xx %xx %Namroc\n\n8. Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\n\n   ```sql\n   copy table gifts\n       (item_name=char(0)tab,\n       date_recd=char(0)tab,\n       sender=char(20)nl with null('anonymous'))\n       into 'giftdata';\n   ```\n\n   toaster 04-mar-1993 Nicholas\n   sled 10-oct-1993 anonymous\n   rocket 01-dec-1993 Francisco\n\n9. Create a table and load it using bulk copy, specifying structural options.\n\n   ```sql\n   create table mytable (name char 25, ...);\n   \n   modify mytable to hash;\n   \n   copy mytable() from 'myfile' with minpages = 16384,\n   maxpages = 16384, allocation = 16384;\n   ```"
        ]
    },
    {
        "instruction": "What is the purpose of the `with_clause` parameter in Actian 4GL SQL COPY statements, and what are some common options available?",
        "input": "",
        "output": "The `with_clause` parameter in Actian 4GL SQL COPY statements consists of additional options that can be specified to customize the behavior of the copy operation. Some commonly used options include:\n- `on_error = TERMINATE | CONTINUE`: This determines whether the operation continues after an error (CONTINUE) or stops (TERMINATE).\n- `error_count = n`: This sets a limit on the number of errors that can occur before the operation is terminated.\n- `rollback = ENABLED | DISABLED`: This determines whether a rollback occurs if an error occurs during the copy operation. A ROLLBACK enables it, while DISABLED disables it.\n- `log = 'filename'`: This specifies a log file where errors and informational messages are logged during the copy operation.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "# Copy Statement\n\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\n\nThis statement has the following syntax:\n\n```sql\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\n```\n\n## Parameters--Copy Statement\n\nThis statement has the following parameters:\n\n- **table_name**: Specifies an existing table from which data is read or to which data is written.\n- **column_name**: Specifies the column from which data is read or to which data is written.\n- **format**: Specifies the format in which a value is stored in the file.\n- **filename**: Specifies the file from which data is read or to which data is written.\n- **type**: (Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\n\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\n\n- **with_clause**: Consists of the word with, followed by a comma-separated list of one or more of the following items:\n  - on_error = TERMINATE | CONTINUE\n  - error_count = n\n  - rollback = ENABLED | DISABLED\n  - log = 'filename'\n\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\n- allocation = n\n- extend = n\n- fillfactor = n (ISAM, Hash, and Btree only)\n- minpages = n (Hash only)\n- maxpages = n (Hash only)\n- leaffill = n (Btree only)\n- nonleaffill = n (Btree only)\n- row_estimate = n\n\n## Unformatted Copying\n\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\n\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\n\n```sql\ncopy table employee () into 'emp_name';\n```\n\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\n\nNote: An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\n\n## Formatted Copying\n\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\n\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\n\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\n\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\n\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).",
            "The values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.\n\nNote: If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\n\n```sql\ncopy table t (col1=c20, col2=c30, d0=nl) into 't.out':\n```\n\n## Bulk Copying\n\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\n\nThe requirements for performing a bulk copy are:\n\n- The table is not journaled\n- The table has no secondary indexes\n- For storage structures other than heap, the table is empty and occupies fewer than 18 pages\n\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\n\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\n\n## Column Formats for Copy\n\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\n\nNote: When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\n\n### Character (Text) Formats\n\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\n\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\n\nThe subtle differences between the various character formats are described in Copy Format Details.\n\n### Counted Character Formats\n\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\n\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\n\nNote: Nvarchar(0) is not a counted format.\n\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\n\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\n\n### Dummy Format\n\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\n\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\n\n### Unicode Formats\n\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\n\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\n\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\n\n### Binary Formats",
            "### Binary Formats\n\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\n\nCertainly. I'll convert the provided documentation into a Markdown (.md) file format, maintaining the content while adjusting only the formatting. Here's the result:\n\n### Copy Format Details\n\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\n- Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n- When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n- The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\n\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).",
            "| Format | How Stored (copy into) | How Read (copy from) |\n|--------|------------------------|----------------------|\n| boolean | Written as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format) | Same format as copy into |\n| byte(0) | Same as byte(n) where n is the display length of the corresponding table column. | Read as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. |\n| byte(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded. |\n| byte varying(0) | Same as byte varying(n) where n is the display length of the table column. | Read as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |\n| byte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |\n| C0 | Same as Cn where n is the display length of the corresponding table column | Read as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Any control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\. |\n| Cn | Written as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Any control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\. |\n| char(0) | Same as char(n) where n is the display length of the corresponding table column. | Read as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Unlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is. |\n| char(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding. Unlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Unlike C format, char does not convert control characters or tabs. File data is read as is. |\n| D0 | Instead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.) Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed. | Dummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value. Any \\ found in the input means that the next character is to be taken literally, and is not a delimiter. |\n| Dn | Dummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1. | Dummy field. N characters are read and discarded. Copy from does not allow a delimiter specification with a fixed-length dummy field. |\n| date | Written as a date. (A binary format) | Read as a date. (A binary format) |\n| decimal | Written as a decimal number. (A binary format.) | Read as a decimal number. (A binary format) |\n| float | Written as double\u2011precision floating point. (A binary format) | Read as double\u2011precision floating point. (A binary format) |\n| float4 | Written as single\u2011precision floating point. (A binary format) | Read as single\u2011precision floating point. (A binary format) |\n| integer | Written as integer of 4\u2011byte length. (A binary format) | Read as integer of 4\u2011byte length. (A binary format) |",
            "| integer1 | Written as integer of 1\u2011byte length. (A binary format) | Read as integer of 1\u2011byte length. (A binary format) |\n| long byte(0) | Identical to long varchar | Identical to long varchar |\n| long nvarchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). The maximum segment size for the long nvarchar segment is 32727 bytes. The UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment. If a delimiter is specified, it is written immediately following the last segment. | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| long varchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767. The following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long: 5 abcde10 abcdefghij 0 (with a space after the terminating 0 character) (In this example, the data that is in the originating table column is abcdeabcdefghij) | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| money | Written as a scaled floating point value (a money value). (A binary format) | Read as a scaled floating-point values (a money value). (A binary format) |\n| nchar(0) | Written as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value. | Read as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered. |\n| nvarchar(0) | Same as nchar(0) | Same as nchar(0) |\n| nchar(n) | Written as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| nvarchar(n) | Written as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding. The byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| smallint | Written as an integer of 2\u2011byte length. (A binary format.) | Read as integer of 2\u2011byte length. (A binary format) |\n| text(0) | Written as a variable length string. If a delimiter is specified, it is written after the value. If the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding. Copy into using text(0) format is the way to get variable width output with no padding. | Read as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value |\n| text(n) | Written as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding. | Reads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded. |\n| varchar(0) | Same as varchar(n), where n is the display length of the corresponding table column. | Read as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |",
            "| varchar(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length. | Read as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |",
            "Note: The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\n\nFor user-defined data types (UDTs), use char or varchar.\n\nCertainly. I'll create a single Markdown (.md) file based on the provided documentation, focusing on formatting the content without modifying it. Here's the Markdown version:\n\n### Delimiters in the Data File\n\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\n\n| Delimiter | Description |\n|-----------|-------------|\n| nl | Newline character |\n| tab | Tab character |\n| sp | Space |\n| csv | Comma separated values |\n| ssv | Semicolon separated values |\n| nul or null | Null/zero character |\n| comma | Comma |\n| colon | Colon |\n| dash | Dash |\n| lparen | Left parenthesis |\n| rparen | Right parenthesis |\n| X | Any non-numeric character |\n\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\n\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\n\n## CSV and SSV Delimiters\n\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\n\nThe rules for a CSV-delimited field are:\n\n- The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n- Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\n  ```\n  \"There is a double quote \"\" here\"\n  ```\n\n  is translated to the table value:\n\n  ```\n  There is a double quote \" here\n  ```\n\n  Whitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\n- Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\n\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\n\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \"counted\" formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)\n\nCopy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\n\n## With Null Clause for Copy\n\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\n\n### With Null (value) Clause\n\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\n\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.",
            "To prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\n\nFor example, this example of a value is incorrect:\n\n```\nc0comma with null(0)\n```\n\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\n\n```\nc0comma with null('0')\n```\n\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\n\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\n\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\n\n```sql\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\n```\n\nThe correct version specifies a 4-character format for the column.\n\n```sql\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\n```\n\n### With Null Clause Omitting Value\n\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\n\n## Filename Specification for Copy\n\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\n\nUNIX: For copy into, if the file already exists, copy overwrites it.\n\n## Windows File Types for Copy\n\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\n\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\n\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\n\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\n\nThe binary-copy forms (copy () from or copy () into) use binary mode.\n\nNote: Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.\n\nCopy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\n\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\n\n## With Clause for Copy\n\nValid with clause options for the copy statement are as follows:\n\n### On_error=TERMINATE|CONTINUE\n\nDirects copy to continue after encountering conversion errors.\n\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\n\nBy default, copy terminates when an error occurs while converting between table format and file format\n\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\n\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\n\n### Error_count=n\n\nSpecifies how many errors can occur before processing terminates.\n\nDefault: 1.\n\nIf on_error is set to continue, setting error_count has no effect.",
            "Default: 1.\n\nIf on_error is set to continue, setting error_count has no effect.\n\n### Log='filename'\n\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\n\nLogging works as follows:\n\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\n\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\n\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\n\n### Rollback=ENABLED|DISABLED\n\nEnables or disables rollback, as follows:\n\n- ENABLED: Directs the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\n- DISABLED: Retains the appended rows.\n\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\n\nDefault: ENABLED\n\nWhen copying to a file, the with rollback clause has no effect.\n\n### Row_estimate\n\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\n\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\n\n## Permissions\n\nTo use the copy statement, one of the following must apply:\n\n- You own the table.\n- The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n- You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\n\n## Locking\n\n- When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n- When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n- When performing a non-bulk copy into a table, the DBMS server takes an \"intent exclusive\" lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\n\n## Restrictions and Considerations\n\n- Copy cannot be used to add data to a view, index, or system catalog.\n- When copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\n- When copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\n- The copy statement does not fire any rules defined against the table.\n- Values cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\n- Copy treats a present-but-empty field in the data file as:\n  - A blank default for character-based columns\n  - A zero default for numeric columns\n  - December 31 00-1 for date and timestamp columns\n  - 00:00:00 for time columns (and the time component in a timestamp)",
            "For example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\n\n## Related Statements\n\n- Create Table Statement\n- Modify Statement\n\n## Examples--Copy Statement\n\nThe following examples illustrate the correct use of the copy statement:\n\n1. In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\n\n   ```\n   ename     char(15)\n   age       integer4\n   dept      char(10)\n   comment   varchar(20)\n   ```\n\n   The emp.txt file contains the following data:\n\n   ```\n   Jones,J. 32 Anytown,USA toy,00017A This is a comment\n   Smith,P. 41 New York,NY admin,00015 Another comment\n   ```\n\n   The following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\n   - A dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\n   - The department field is delimited by a comma.\n   - The comment field is a variable-length varchar field, preceded by a five-character length specifier.\n\n2. Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\n\n   ```sql\n   copy table employee (eno=integer2, ename=char(10),\n       age=integer2, job=integer2, sal=float4,\n       dept=integer2, xxx=d1)\n       from 'myfile.in';\n   ```\n\n3. Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\n\n   ```sql\n   copy table employee (ename=char(0)comma,\n       eno=char(0)comma, sal= char(0)nl)\n       into 'mfile.out';\n   ```\n\n   Joe Smith , 101, $25000.00\n   \n   Shirley Scott , 102, $30000.00\n\n4. The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\n\n   ```sql\n   copy table employee (ename = text(0)csv,\n       eno = text(0)csv, sal = text(0)csv)\n       into 'mfile.out';\n   ```\n    \n   Joe Smith,101,$25000.00\n   Shirley Scott,102,$30000.00\n\n5. Bulk copy the employee table into a file. The resulting data file contains binary data.\n\n   ```sql\n   copy table employee () into 'ourfile.dat';\n   ```\n\n6. Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\n\n   ```sql\n   copy table other_employee_table () from 'ourfile.dat';\n   ```\n\n7. Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\n\n   ```sql\n   copy table acct_recv\n       (acct_name=char(0)'%',\n       address='d0%',\n       credit=char(0)'%' with null('xx'),\n       debit=char(0)'%' with null('xx'),\n       acct_mngr=char(15),\n       xx=d0nl)\n       into 'qtr_result';\n   ```\n\n   Smith Corp%% $12345.00% $-67890.00%Jones\n   ABC Oil %% $54321.00% $-98765.00%Green\n   Spring Omc%%xx %xx %Namroc\n\n8. Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\n\n   ```sql\n   copy table gifts\n       (item_name=char(0)tab,\n       date_recd=char(0)tab,\n       sender=char(20)nl with null('anonymous'))\n       into 'giftdata';\n   ```\n\n   toaster 04-mar-1993 Nicholas\n   sled 10-oct-1993 anonymous\n   rocket 01-dec-1993 Francisco\n\n9. Create a table and load it using bulk copy, specifying structural options.\n\n   ```sql\n   create table mytable (name char 25, ...);\n   \n   modify mytable to hash;\n   \n   copy mytable() from 'myfile' with minpages = 16384,\n   maxpages = 16384, allocation = 16384;\n   ```"
        ]
    },
    {
        "instruction": "Explain the purpose of the LOG option in Actian 4GL SQL COPY statements with an example scenario.",
        "input": "",
        "output": "The LOG option is used to store any rows that COPY cannot process into a specified file. This feature is particularly helpful when dealing with large datasets, as it allows users to identify and rectify errors in the data during import or export operations.\n\nFor example, if you're copying data from a CSV file into an Actian table but encounter some corrupted rows that cannot be processed, setting the LOG option will save those rows to a specified log file so they can be inspected and fixed later. This ensures the integrity of your imported or exported dataset while providing transparency during the process.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "# Copy Statement\n\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\n\nThis statement has the following syntax:\n\n```sql\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\n```\n\n## Parameters--Copy Statement\n\nThis statement has the following parameters:\n\n- **table_name**: Specifies an existing table from which data is read or to which data is written.\n- **column_name**: Specifies the column from which data is read or to which data is written.\n- **format**: Specifies the format in which a value is stored in the file.\n- **filename**: Specifies the file from which data is read or to which data is written.\n- **type**: (Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\n\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\n\n- **with_clause**: Consists of the word with, followed by a comma-separated list of one or more of the following items:\n  - on_error = TERMINATE | CONTINUE\n  - error_count = n\n  - rollback = ENABLED | DISABLED\n  - log = 'filename'\n\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\n- allocation = n\n- extend = n\n- fillfactor = n (ISAM, Hash, and Btree only)\n- minpages = n (Hash only)\n- maxpages = n (Hash only)\n- leaffill = n (Btree only)\n- nonleaffill = n (Btree only)\n- row_estimate = n\n\n## Unformatted Copying\n\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\n\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\n\n```sql\ncopy table employee () into 'emp_name';\n```\n\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\n\nNote: An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\n\n## Formatted Copying\n\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\n\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\n\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\n\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\n\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).",
            "The values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.\n\nNote: If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\n\n```sql\ncopy table t (col1=c20, col2=c30, d0=nl) into 't.out':\n```\n\n## Bulk Copying\n\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\n\nThe requirements for performing a bulk copy are:\n\n- The table is not journaled\n- The table has no secondary indexes\n- For storage structures other than heap, the table is empty and occupies fewer than 18 pages\n\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\n\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\n\n## Column Formats for Copy\n\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\n\nNote: When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\n\n### Character (Text) Formats\n\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\n\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\n\nThe subtle differences between the various character formats are described in Copy Format Details.\n\n### Counted Character Formats\n\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\n\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\n\nNote: Nvarchar(0) is not a counted format.\n\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\n\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\n\n### Dummy Format\n\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\n\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\n\n### Unicode Formats\n\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\n\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\n\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\n\n### Binary Formats",
            "### Binary Formats\n\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\n\nCertainly. I'll convert the provided documentation into a Markdown (.md) file format, maintaining the content while adjusting only the formatting. Here's the result:\n\n### Copy Format Details\n\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\n- Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n- When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n- The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\n\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).",
            "| Format | How Stored (copy into) | How Read (copy from) |\n|--------|------------------------|----------------------|\n| boolean | Written as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format) | Same format as copy into |\n| byte(0) | Same as byte(n) where n is the display length of the corresponding table column. | Read as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. |\n| byte(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded. |\n| byte varying(0) | Same as byte varying(n) where n is the display length of the table column. | Read as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |\n| byte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |\n| C0 | Same as Cn where n is the display length of the corresponding table column | Read as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Any control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\. |\n| Cn | Written as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Any control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\. |\n| char(0) | Same as char(n) where n is the display length of the corresponding table column. | Read as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Unlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is. |\n| char(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding. Unlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Unlike C format, char does not convert control characters or tabs. File data is read as is. |\n| D0 | Instead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.) Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed. | Dummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value. Any \\ found in the input means that the next character is to be taken literally, and is not a delimiter. |\n| Dn | Dummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1. | Dummy field. N characters are read and discarded. Copy from does not allow a delimiter specification with a fixed-length dummy field. |\n| date | Written as a date. (A binary format) | Read as a date. (A binary format) |\n| decimal | Written as a decimal number. (A binary format.) | Read as a decimal number. (A binary format) |\n| float | Written as double\u2011precision floating point. (A binary format) | Read as double\u2011precision floating point. (A binary format) |\n| float4 | Written as single\u2011precision floating point. (A binary format) | Read as single\u2011precision floating point. (A binary format) |\n| integer | Written as integer of 4\u2011byte length. (A binary format) | Read as integer of 4\u2011byte length. (A binary format) |",
            "| integer1 | Written as integer of 1\u2011byte length. (A binary format) | Read as integer of 1\u2011byte length. (A binary format) |\n| long byte(0) | Identical to long varchar | Identical to long varchar |\n| long nvarchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). The maximum segment size for the long nvarchar segment is 32727 bytes. The UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment. If a delimiter is specified, it is written immediately following the last segment. | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| long varchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767. The following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long: 5 abcde10 abcdefghij 0 (with a space after the terminating 0 character) (In this example, the data that is in the originating table column is abcdeabcdefghij) | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| money | Written as a scaled floating point value (a money value). (A binary format) | Read as a scaled floating-point values (a money value). (A binary format) |\n| nchar(0) | Written as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value. | Read as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered. |\n| nvarchar(0) | Same as nchar(0) | Same as nchar(0) |\n| nchar(n) | Written as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| nvarchar(n) | Written as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding. The byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| smallint | Written as an integer of 2\u2011byte length. (A binary format.) | Read as integer of 2\u2011byte length. (A binary format) |\n| text(0) | Written as a variable length string. If a delimiter is specified, it is written after the value. If the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding. Copy into using text(0) format is the way to get variable width output with no padding. | Read as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value |\n| text(n) | Written as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding. | Reads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded. |\n| varchar(0) | Same as varchar(n), where n is the display length of the corresponding table column. | Read as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |",
            "| varchar(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length. | Read as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |",
            "Note: The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\n\nFor user-defined data types (UDTs), use char or varchar.\n\nCertainly. I'll create a single Markdown (.md) file based on the provided documentation, focusing on formatting the content without modifying it. Here's the Markdown version:\n\n### Delimiters in the Data File\n\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\n\n| Delimiter | Description |\n|-----------|-------------|\n| nl | Newline character |\n| tab | Tab character |\n| sp | Space |\n| csv | Comma separated values |\n| ssv | Semicolon separated values |\n| nul or null | Null/zero character |\n| comma | Comma |\n| colon | Colon |\n| dash | Dash |\n| lparen | Left parenthesis |\n| rparen | Right parenthesis |\n| X | Any non-numeric character |\n\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\n\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\n\n## CSV and SSV Delimiters\n\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\n\nThe rules for a CSV-delimited field are:\n\n- The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n- Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\n  ```\n  \"There is a double quote \"\" here\"\n  ```\n\n  is translated to the table value:\n\n  ```\n  There is a double quote \" here\n  ```\n\n  Whitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\n- Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\n\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\n\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \"counted\" formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)\n\nCopy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\n\n## With Null Clause for Copy\n\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\n\n### With Null (value) Clause\n\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\n\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.",
            "To prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\n\nFor example, this example of a value is incorrect:\n\n```\nc0comma with null(0)\n```\n\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\n\n```\nc0comma with null('0')\n```\n\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\n\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\n\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\n\n```sql\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\n```\n\nThe correct version specifies a 4-character format for the column.\n\n```sql\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\n```\n\n### With Null Clause Omitting Value\n\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\n\n## Filename Specification for Copy\n\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\n\nUNIX: For copy into, if the file already exists, copy overwrites it.\n\n## Windows File Types for Copy\n\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\n\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\n\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\n\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\n\nThe binary-copy forms (copy () from or copy () into) use binary mode.\n\nNote: Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.\n\nCopy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\n\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\n\n## With Clause for Copy\n\nValid with clause options for the copy statement are as follows:\n\n### On_error=TERMINATE|CONTINUE\n\nDirects copy to continue after encountering conversion errors.\n\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\n\nBy default, copy terminates when an error occurs while converting between table format and file format\n\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\n\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\n\n### Error_count=n\n\nSpecifies how many errors can occur before processing terminates.\n\nDefault: 1.\n\nIf on_error is set to continue, setting error_count has no effect.",
            "Default: 1.\n\nIf on_error is set to continue, setting error_count has no effect.\n\n### Log='filename'\n\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\n\nLogging works as follows:\n\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\n\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\n\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\n\n### Rollback=ENABLED|DISABLED\n\nEnables or disables rollback, as follows:\n\n- ENABLED: Directs the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\n- DISABLED: Retains the appended rows.\n\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\n\nDefault: ENABLED\n\nWhen copying to a file, the with rollback clause has no effect.\n\n### Row_estimate\n\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\n\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\n\n## Permissions\n\nTo use the copy statement, one of the following must apply:\n\n- You own the table.\n- The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n- You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\n\n## Locking\n\n- When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n- When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n- When performing a non-bulk copy into a table, the DBMS server takes an \"intent exclusive\" lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\n\n## Restrictions and Considerations\n\n- Copy cannot be used to add data to a view, index, or system catalog.\n- When copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\n- When copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\n- The copy statement does not fire any rules defined against the table.\n- Values cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\n- Copy treats a present-but-empty field in the data file as:\n  - A blank default for character-based columns\n  - A zero default for numeric columns\n  - December 31 00-1 for date and timestamp columns\n  - 00:00:00 for time columns (and the time component in a timestamp)",
            "For example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\n\n## Related Statements\n\n- Create Table Statement\n- Modify Statement\n\n## Examples--Copy Statement\n\nThe following examples illustrate the correct use of the copy statement:\n\n1. In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\n\n   ```\n   ename     char(15)\n   age       integer4\n   dept      char(10)\n   comment   varchar(20)\n   ```\n\n   The emp.txt file contains the following data:\n\n   ```\n   Jones,J. 32 Anytown,USA toy,00017A This is a comment\n   Smith,P. 41 New York,NY admin,00015 Another comment\n   ```\n\n   The following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\n   - A dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\n   - The department field is delimited by a comma.\n   - The comment field is a variable-length varchar field, preceded by a five-character length specifier.\n\n2. Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\n\n   ```sql\n   copy table employee (eno=integer2, ename=char(10),\n       age=integer2, job=integer2, sal=float4,\n       dept=integer2, xxx=d1)\n       from 'myfile.in';\n   ```\n\n3. Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\n\n   ```sql\n   copy table employee (ename=char(0)comma,\n       eno=char(0)comma, sal= char(0)nl)\n       into 'mfile.out';\n   ```\n\n   Joe Smith , 101, $25000.00\n   \n   Shirley Scott , 102, $30000.00\n\n4. The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\n\n   ```sql\n   copy table employee (ename = text(0)csv,\n       eno = text(0)csv, sal = text(0)csv)\n       into 'mfile.out';\n   ```\n    \n   Joe Smith,101,$25000.00\n   Shirley Scott,102,$30000.00\n\n5. Bulk copy the employee table into a file. The resulting data file contains binary data.\n\n   ```sql\n   copy table employee () into 'ourfile.dat';\n   ```\n\n6. Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\n\n   ```sql\n   copy table other_employee_table () from 'ourfile.dat';\n   ```\n\n7. Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\n\n   ```sql\n   copy table acct_recv\n       (acct_name=char(0)'%',\n       address='d0%',\n       credit=char(0)'%' with null('xx'),\n       debit=char(0)'%' with null('xx'),\n       acct_mngr=char(15),\n       xx=d0nl)\n       into 'qtr_result';\n   ```\n\n   Smith Corp%% $12345.00% $-67890.00%Jones\n   ABC Oil %% $54321.00% $-98765.00%Green\n   Spring Omc%%xx %xx %Namroc\n\n8. Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\n\n   ```sql\n   copy table gifts\n       (item_name=char(0)tab,\n       date_recd=char(0)tab,\n       sender=char(20)nl with null('anonymous'))\n       into 'giftdata';\n   ```\n\n   toaster 04-mar-1993 Nicholas\n   sled 10-oct-1993 anonymous\n   rocket 01-dec-1993 Francisco\n\n9. Create a table and load it using bulk copy, specifying structural options.\n\n   ```sql\n   create table mytable (name char 25, ...);\n   \n   modify mytable to hash;\n   \n   copy mytable() from 'myfile' with minpages = 16384,\n   maxpages = 16384, allocation = 16384;\n   ```"
        ]
    },
    {
        "instruction": "Explain the rollback=ENABLED|DISABLED option in Actian 4GL SQL COPY statements with its default value and implications for data retention.",
        "input": "",
        "output": "The rollback=ENABLED|DISABLED option determines whether the DBMS Server rolls back all rows appended by the COPY statement if an error occurs during the operation. By setting it to ENABLED, you can instruct the server to undo the entire COPY operation if necessary. The default value for this option is ENABLED, meaning that if an error occurs, any added rows will be rolled back. When copying to a file, the rollback=DISABLED option has no effect because there is no permanent change in the database.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "# Copy Statement\n\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\n\nThis statement has the following syntax:\n\n```sql\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\n```\n\n## Parameters--Copy Statement\n\nThis statement has the following parameters:\n\n- **table_name**: Specifies an existing table from which data is read or to which data is written.\n- **column_name**: Specifies the column from which data is read or to which data is written.\n- **format**: Specifies the format in which a value is stored in the file.\n- **filename**: Specifies the file from which data is read or to which data is written.\n- **type**: (Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\n\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\n\n- **with_clause**: Consists of the word with, followed by a comma-separated list of one or more of the following items:\n  - on_error = TERMINATE | CONTINUE\n  - error_count = n\n  - rollback = ENABLED | DISABLED\n  - log = 'filename'\n\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\n- allocation = n\n- extend = n\n- fillfactor = n (ISAM, Hash, and Btree only)\n- minpages = n (Hash only)\n- maxpages = n (Hash only)\n- leaffill = n (Btree only)\n- nonleaffill = n (Btree only)\n- row_estimate = n\n\n## Unformatted Copying\n\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\n\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\n\n```sql\ncopy table employee () into 'emp_name';\n```\n\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\n\nNote: An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\n\n## Formatted Copying\n\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\n\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\n\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\n\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\n\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).",
            "The values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.\n\nNote: If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\n\n```sql\ncopy table t (col1=c20, col2=c30, d0=nl) into 't.out':\n```\n\n## Bulk Copying\n\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\n\nThe requirements for performing a bulk copy are:\n\n- The table is not journaled\n- The table has no secondary indexes\n- For storage structures other than heap, the table is empty and occupies fewer than 18 pages\n\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\n\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\n\n## Column Formats for Copy\n\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\n\nNote: When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\n\n### Character (Text) Formats\n\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\n\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\n\nThe subtle differences between the various character formats are described in Copy Format Details.\n\n### Counted Character Formats\n\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\n\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\n\nNote: Nvarchar(0) is not a counted format.\n\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\n\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\n\n### Dummy Format\n\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\n\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\n\n### Unicode Formats\n\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\n\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\n\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\n\n### Binary Formats",
            "### Binary Formats\n\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\n\nCertainly. I'll convert the provided documentation into a Markdown (.md) file format, maintaining the content while adjusting only the formatting. Here's the result:\n\n### Copy Format Details\n\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\n- Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n- When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n- The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\n\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).",
            "| Format | How Stored (copy into) | How Read (copy from) |\n|--------|------------------------|----------------------|\n| boolean | Written as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format) | Same format as copy into |\n| byte(0) | Same as byte(n) where n is the display length of the corresponding table column. | Read as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. |\n| byte(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded. |\n| byte varying(0) | Same as byte varying(n) where n is the display length of the table column. | Read as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |\n| byte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |\n| C0 | Same as Cn where n is the display length of the corresponding table column | Read as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Any control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\. |\n| Cn | Written as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Any control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\. |\n| char(0) | Same as char(n) where n is the display length of the corresponding table column. | Read as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Unlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is. |\n| char(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding. Unlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Unlike C format, char does not convert control characters or tabs. File data is read as is. |\n| D0 | Instead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.) Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed. | Dummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value. Any \\ found in the input means that the next character is to be taken literally, and is not a delimiter. |\n| Dn | Dummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1. | Dummy field. N characters are read and discarded. Copy from does not allow a delimiter specification with a fixed-length dummy field. |\n| date | Written as a date. (A binary format) | Read as a date. (A binary format) |\n| decimal | Written as a decimal number. (A binary format.) | Read as a decimal number. (A binary format) |\n| float | Written as double\u2011precision floating point. (A binary format) | Read as double\u2011precision floating point. (A binary format) |\n| float4 | Written as single\u2011precision floating point. (A binary format) | Read as single\u2011precision floating point. (A binary format) |\n| integer | Written as integer of 4\u2011byte length. (A binary format) | Read as integer of 4\u2011byte length. (A binary format) |",
            "| integer1 | Written as integer of 1\u2011byte length. (A binary format) | Read as integer of 1\u2011byte length. (A binary format) |\n| long byte(0) | Identical to long varchar | Identical to long varchar |\n| long nvarchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). The maximum segment size for the long nvarchar segment is 32727 bytes. The UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment. If a delimiter is specified, it is written immediately following the last segment. | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| long varchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767. The following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long: 5 abcde10 abcdefghij 0 (with a space after the terminating 0 character) (In this example, the data that is in the originating table column is abcdeabcdefghij) | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| money | Written as a scaled floating point value (a money value). (A binary format) | Read as a scaled floating-point values (a money value). (A binary format) |\n| nchar(0) | Written as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value. | Read as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered. |\n| nvarchar(0) | Same as nchar(0) | Same as nchar(0) |\n| nchar(n) | Written as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| nvarchar(n) | Written as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding. The byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| smallint | Written as an integer of 2\u2011byte length. (A binary format.) | Read as integer of 2\u2011byte length. (A binary format) |\n| text(0) | Written as a variable length string. If a delimiter is specified, it is written after the value. If the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding. Copy into using text(0) format is the way to get variable width output with no padding. | Read as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value |\n| text(n) | Written as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding. | Reads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded. |\n| varchar(0) | Same as varchar(n), where n is the display length of the corresponding table column. | Read as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |",
            "| varchar(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length. | Read as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |",
            "Note: The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\n\nFor user-defined data types (UDTs), use char or varchar.\n\nCertainly. I'll create a single Markdown (.md) file based on the provided documentation, focusing on formatting the content without modifying it. Here's the Markdown version:\n\n### Delimiters in the Data File\n\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\n\n| Delimiter | Description |\n|-----------|-------------|\n| nl | Newline character |\n| tab | Tab character |\n| sp | Space |\n| csv | Comma separated values |\n| ssv | Semicolon separated values |\n| nul or null | Null/zero character |\n| comma | Comma |\n| colon | Colon |\n| dash | Dash |\n| lparen | Left parenthesis |\n| rparen | Right parenthesis |\n| X | Any non-numeric character |\n\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\n\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\n\n## CSV and SSV Delimiters\n\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\n\nThe rules for a CSV-delimited field are:\n\n- The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n- Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\n  ```\n  \"There is a double quote \"\" here\"\n  ```\n\n  is translated to the table value:\n\n  ```\n  There is a double quote \" here\n  ```\n\n  Whitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\n- Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\n\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\n\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \"counted\" formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)\n\nCopy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\n\n## With Null Clause for Copy\n\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\n\n### With Null (value) Clause\n\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\n\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.",
            "To prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\n\nFor example, this example of a value is incorrect:\n\n```\nc0comma with null(0)\n```\n\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\n\n```\nc0comma with null('0')\n```\n\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\n\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\n\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\n\n```sql\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\n```\n\nThe correct version specifies a 4-character format for the column.\n\n```sql\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\n```\n\n### With Null Clause Omitting Value\n\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\n\n## Filename Specification for Copy\n\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\n\nUNIX: For copy into, if the file already exists, copy overwrites it.\n\n## Windows File Types for Copy\n\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\n\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\n\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\n\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\n\nThe binary-copy forms (copy () from or copy () into) use binary mode.\n\nNote: Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.\n\nCopy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\n\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\n\n## With Clause for Copy\n\nValid with clause options for the copy statement are as follows:\n\n### On_error=TERMINATE|CONTINUE\n\nDirects copy to continue after encountering conversion errors.\n\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\n\nBy default, copy terminates when an error occurs while converting between table format and file format\n\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\n\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\n\n### Error_count=n\n\nSpecifies how many errors can occur before processing terminates.\n\nDefault: 1.\n\nIf on_error is set to continue, setting error_count has no effect.",
            "Default: 1.\n\nIf on_error is set to continue, setting error_count has no effect.\n\n### Log='filename'\n\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\n\nLogging works as follows:\n\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\n\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\n\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\n\n### Rollback=ENABLED|DISABLED\n\nEnables or disables rollback, as follows:\n\n- ENABLED: Directs the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\n- DISABLED: Retains the appended rows.\n\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\n\nDefault: ENABLED\n\nWhen copying to a file, the with rollback clause has no effect.\n\n### Row_estimate\n\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\n\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\n\n## Permissions\n\nTo use the copy statement, one of the following must apply:\n\n- You own the table.\n- The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n- You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\n\n## Locking\n\n- When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n- When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n- When performing a non-bulk copy into a table, the DBMS server takes an \"intent exclusive\" lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\n\n## Restrictions and Considerations\n\n- Copy cannot be used to add data to a view, index, or system catalog.\n- When copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\n- When copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\n- The copy statement does not fire any rules defined against the table.\n- Values cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\n- Copy treats a present-but-empty field in the data file as:\n  - A blank default for character-based columns\n  - A zero default for numeric columns\n  - December 31 00-1 for date and timestamp columns\n  - 00:00:00 for time columns (and the time component in a timestamp)",
            "For example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\n\n## Related Statements\n\n- Create Table Statement\n- Modify Statement\n\n## Examples--Copy Statement\n\nThe following examples illustrate the correct use of the copy statement:\n\n1. In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\n\n   ```\n   ename     char(15)\n   age       integer4\n   dept      char(10)\n   comment   varchar(20)\n   ```\n\n   The emp.txt file contains the following data:\n\n   ```\n   Jones,J. 32 Anytown,USA toy,00017A This is a comment\n   Smith,P. 41 New York,NY admin,00015 Another comment\n   ```\n\n   The following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\n   - A dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\n   - The department field is delimited by a comma.\n   - The comment field is a variable-length varchar field, preceded by a five-character length specifier.\n\n2. Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\n\n   ```sql\n   copy table employee (eno=integer2, ename=char(10),\n       age=integer2, job=integer2, sal=float4,\n       dept=integer2, xxx=d1)\n       from 'myfile.in';\n   ```\n\n3. Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\n\n   ```sql\n   copy table employee (ename=char(0)comma,\n       eno=char(0)comma, sal= char(0)nl)\n       into 'mfile.out';\n   ```\n\n   Joe Smith , 101, $25000.00\n   \n   Shirley Scott , 102, $30000.00\n\n4. The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\n\n   ```sql\n   copy table employee (ename = text(0)csv,\n       eno = text(0)csv, sal = text(0)csv)\n       into 'mfile.out';\n   ```\n    \n   Joe Smith,101,$25000.00\n   Shirley Scott,102,$30000.00\n\n5. Bulk copy the employee table into a file. The resulting data file contains binary data.\n\n   ```sql\n   copy table employee () into 'ourfile.dat';\n   ```\n\n6. Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\n\n   ```sql\n   copy table other_employee_table () from 'ourfile.dat';\n   ```\n\n7. Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\n\n   ```sql\n   copy table acct_recv\n       (acct_name=char(0)'%',\n       address='d0%',\n       credit=char(0)'%' with null('xx'),\n       debit=char(0)'%' with null('xx'),\n       acct_mngr=char(15),\n       xx=d0nl)\n       into 'qtr_result';\n   ```\n\n   Smith Corp%% $12345.00% $-67890.00%Jones\n   ABC Oil %% $54321.00% $-98765.00%Green\n   Spring Omc%%xx %xx %Namroc\n\n8. Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\n\n   ```sql\n   copy table gifts\n       (item_name=char(0)tab,\n       date_recd=char(0)tab,\n       sender=char(20)nl with null('anonymous'))\n       into 'giftdata';\n   ```\n\n   toaster 04-mar-1993 Nicholas\n   sled 10-oct-1993 anonymous\n   rocket 01-dec-1993 Francisco\n\n9. Create a table and load it using bulk copy, specifying structural options.\n\n   ```sql\n   create table mytable (name char 25, ...);\n   \n   modify mytable to hash;\n   \n   copy mytable() from 'myfile' with minpages = 16384,\n   maxpages = 16384, allocation = 16384;\n   ```"
        ]
    },
    {
        "instruction": "Explain the concept of delimiters in Actian 4GL SQL COPY statements, including examples for different types of delimiters.",
        "input": "",
        "output": "Delimiters in Actian 4GL SQL COPY statements are characters that separate or mark the boundaries between data fields during data import and export operations. Common delimiters include commas (,), tabs (\\t), semicolons (;), and space characters. In examples from the document, the department field is delimited by a comma, and the comment field is preceded by a five-character length specifier to indicate its variable-length format. Other examples demonstrate the use of percent sign (%) as a field delimiter or tab character (\\t) to separate columns in data files.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "# Copy Statement\n\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\n\nThis statement has the following syntax:\n\n```sql\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\n```\n\n## Parameters--Copy Statement\n\nThis statement has the following parameters:\n\n- **table_name**: Specifies an existing table from which data is read or to which data is written.\n- **column_name**: Specifies the column from which data is read or to which data is written.\n- **format**: Specifies the format in which a value is stored in the file.\n- **filename**: Specifies the file from which data is read or to which data is written.\n- **type**: (Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\n\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\n\n- **with_clause**: Consists of the word with, followed by a comma-separated list of one or more of the following items:\n  - on_error = TERMINATE | CONTINUE\n  - error_count = n\n  - rollback = ENABLED | DISABLED\n  - log = 'filename'\n\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\n- allocation = n\n- extend = n\n- fillfactor = n (ISAM, Hash, and Btree only)\n- minpages = n (Hash only)\n- maxpages = n (Hash only)\n- leaffill = n (Btree only)\n- nonleaffill = n (Btree only)\n- row_estimate = n\n\n## Unformatted Copying\n\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\n\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\n\n```sql\ncopy table employee () into 'emp_name';\n```\n\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\n\nNote: An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\n\n## Formatted Copying\n\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\n\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\n\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\n\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\n\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).",
            "The values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.\n\nNote: If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\n\n```sql\ncopy table t (col1=c20, col2=c30, d0=nl) into 't.out':\n```\n\n## Bulk Copying\n\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\n\nThe requirements for performing a bulk copy are:\n\n- The table is not journaled\n- The table has no secondary indexes\n- For storage structures other than heap, the table is empty and occupies fewer than 18 pages\n\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\n\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\n\n## Column Formats for Copy\n\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\n\nNote: When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\n\n### Character (Text) Formats\n\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\n\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\n\nThe subtle differences between the various character formats are described in Copy Format Details.\n\n### Counted Character Formats\n\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\n\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\n\nNote: Nvarchar(0) is not a counted format.\n\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\n\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\n\n### Dummy Format\n\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\n\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\n\n### Unicode Formats\n\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\n\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\n\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\n\n### Binary Formats",
            "### Binary Formats\n\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\n\nCertainly. I'll convert the provided documentation into a Markdown (.md) file format, maintaining the content while adjusting only the formatting. Here's the result:\n\n### Copy Format Details\n\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\n- Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n- When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n- The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\n\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).",
            "| Format | How Stored (copy into) | How Read (copy from) |\n|--------|------------------------|----------------------|\n| boolean | Written as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format) | Same format as copy into |\n| byte(0) | Same as byte(n) where n is the display length of the corresponding table column. | Read as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. |\n| byte(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded. |\n| byte varying(0) | Same as byte varying(n) where n is the display length of the table column. | Read as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |\n| byte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |\n| C0 | Same as Cn where n is the display length of the corresponding table column | Read as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Any control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\. |\n| Cn | Written as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Any control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\. |\n| char(0) | Same as char(n) where n is the display length of the corresponding table column. | Read as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Unlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is. |\n| char(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding. Unlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Unlike C format, char does not convert control characters or tabs. File data is read as is. |\n| D0 | Instead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.) Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed. | Dummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value. Any \\ found in the input means that the next character is to be taken literally, and is not a delimiter. |\n| Dn | Dummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1. | Dummy field. N characters are read and discarded. Copy from does not allow a delimiter specification with a fixed-length dummy field. |\n| date | Written as a date. (A binary format) | Read as a date. (A binary format) |\n| decimal | Written as a decimal number. (A binary format.) | Read as a decimal number. (A binary format) |\n| float | Written as double\u2011precision floating point. (A binary format) | Read as double\u2011precision floating point. (A binary format) |\n| float4 | Written as single\u2011precision floating point. (A binary format) | Read as single\u2011precision floating point. (A binary format) |\n| integer | Written as integer of 4\u2011byte length. (A binary format) | Read as integer of 4\u2011byte length. (A binary format) |",
            "| integer1 | Written as integer of 1\u2011byte length. (A binary format) | Read as integer of 1\u2011byte length. (A binary format) |\n| long byte(0) | Identical to long varchar | Identical to long varchar |\n| long nvarchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). The maximum segment size for the long nvarchar segment is 32727 bytes. The UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment. If a delimiter is specified, it is written immediately following the last segment. | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| long varchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767. The following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long: 5 abcde10 abcdefghij 0 (with a space after the terminating 0 character) (In this example, the data that is in the originating table column is abcdeabcdefghij) | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| money | Written as a scaled floating point value (a money value). (A binary format) | Read as a scaled floating-point values (a money value). (A binary format) |\n| nchar(0) | Written as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value. | Read as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered. |\n| nvarchar(0) | Same as nchar(0) | Same as nchar(0) |\n| nchar(n) | Written as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| nvarchar(n) | Written as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding. The byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| smallint | Written as an integer of 2\u2011byte length. (A binary format.) | Read as integer of 2\u2011byte length. (A binary format) |\n| text(0) | Written as a variable length string. If a delimiter is specified, it is written after the value. If the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding. Copy into using text(0) format is the way to get variable width output with no padding. | Read as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value |\n| text(n) | Written as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding. | Reads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded. |\n| varchar(0) | Same as varchar(n), where n is the display length of the corresponding table column. | Read as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |",
            "| varchar(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length. | Read as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |",
            "Note: The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\n\nFor user-defined data types (UDTs), use char or varchar.\n\nCertainly. I'll create a single Markdown (.md) file based on the provided documentation, focusing on formatting the content without modifying it. Here's the Markdown version:\n\n### Delimiters in the Data File\n\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\n\n| Delimiter | Description |\n|-----------|-------------|\n| nl | Newline character |\n| tab | Tab character |\n| sp | Space |\n| csv | Comma separated values |\n| ssv | Semicolon separated values |\n| nul or null | Null/zero character |\n| comma | Comma |\n| colon | Colon |\n| dash | Dash |\n| lparen | Left parenthesis |\n| rparen | Right parenthesis |\n| X | Any non-numeric character |\n\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\n\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\n\n## CSV and SSV Delimiters\n\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\n\nThe rules for a CSV-delimited field are:\n\n- The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n- Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\n  ```\n  \"There is a double quote \"\" here\"\n  ```\n\n  is translated to the table value:\n\n  ```\n  There is a double quote \" here\n  ```\n\n  Whitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\n- Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\n\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\n\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \"counted\" formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)\n\nCopy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\n\n## With Null Clause for Copy\n\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\n\n### With Null (value) Clause\n\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\n\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.",
            "To prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\n\nFor example, this example of a value is incorrect:\n\n```\nc0comma with null(0)\n```\n\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\n\n```\nc0comma with null('0')\n```\n\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\n\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\n\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\n\n```sql\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\n```\n\nThe correct version specifies a 4-character format for the column.\n\n```sql\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\n```\n\n### With Null Clause Omitting Value\n\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\n\n## Filename Specification for Copy\n\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\n\nUNIX: For copy into, if the file already exists, copy overwrites it.\n\n## Windows File Types for Copy\n\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\n\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\n\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\n\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\n\nThe binary-copy forms (copy () from or copy () into) use binary mode.\n\nNote: Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.\n\nCopy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\n\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\n\n## With Clause for Copy\n\nValid with clause options for the copy statement are as follows:\n\n### On_error=TERMINATE|CONTINUE\n\nDirects copy to continue after encountering conversion errors.\n\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\n\nBy default, copy terminates when an error occurs while converting between table format and file format\n\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\n\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\n\n### Error_count=n\n\nSpecifies how many errors can occur before processing terminates.\n\nDefault: 1.\n\nIf on_error is set to continue, setting error_count has no effect.",
            "Default: 1.\n\nIf on_error is set to continue, setting error_count has no effect.\n\n### Log='filename'\n\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\n\nLogging works as follows:\n\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\n\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\n\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\n\n### Rollback=ENABLED|DISABLED\n\nEnables or disables rollback, as follows:\n\n- ENABLED: Directs the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\n- DISABLED: Retains the appended rows.\n\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\n\nDefault: ENABLED\n\nWhen copying to a file, the with rollback clause has no effect.\n\n### Row_estimate\n\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\n\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\n\n## Permissions\n\nTo use the copy statement, one of the following must apply:\n\n- You own the table.\n- The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n- You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\n\n## Locking\n\n- When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n- When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n- When performing a non-bulk copy into a table, the DBMS server takes an \"intent exclusive\" lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\n\n## Restrictions and Considerations\n\n- Copy cannot be used to add data to a view, index, or system catalog.\n- When copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\n- When copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\n- The copy statement does not fire any rules defined against the table.\n- Values cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\n- Copy treats a present-but-empty field in the data file as:\n  - A blank default for character-based columns\n  - A zero default for numeric columns\n  - December 31 00-1 for date and timestamp columns\n  - 00:00:00 for time columns (and the time component in a timestamp)",
            "For example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\n\n## Related Statements\n\n- Create Table Statement\n- Modify Statement\n\n## Examples--Copy Statement\n\nThe following examples illustrate the correct use of the copy statement:\n\n1. In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\n\n   ```\n   ename     char(15)\n   age       integer4\n   dept      char(10)\n   comment   varchar(20)\n   ```\n\n   The emp.txt file contains the following data:\n\n   ```\n   Jones,J. 32 Anytown,USA toy,00017A This is a comment\n   Smith,P. 41 New York,NY admin,00015 Another comment\n   ```\n\n   The following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\n   - A dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\n   - The department field is delimited by a comma.\n   - The comment field is a variable-length varchar field, preceded by a five-character length specifier.\n\n2. Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\n\n   ```sql\n   copy table employee (eno=integer2, ename=char(10),\n       age=integer2, job=integer2, sal=float4,\n       dept=integer2, xxx=d1)\n       from 'myfile.in';\n   ```\n\n3. Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\n\n   ```sql\n   copy table employee (ename=char(0)comma,\n       eno=char(0)comma, sal= char(0)nl)\n       into 'mfile.out';\n   ```\n\n   Joe Smith , 101, $25000.00\n   \n   Shirley Scott , 102, $30000.00\n\n4. The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\n\n   ```sql\n   copy table employee (ename = text(0)csv,\n       eno = text(0)csv, sal = text(0)csv)\n       into 'mfile.out';\n   ```\n    \n   Joe Smith,101,$25000.00\n   Shirley Scott,102,$30000.00\n\n5. Bulk copy the employee table into a file. The resulting data file contains binary data.\n\n   ```sql\n   copy table employee () into 'ourfile.dat';\n   ```\n\n6. Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\n\n   ```sql\n   copy table other_employee_table () from 'ourfile.dat';\n   ```\n\n7. Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\n\n   ```sql\n   copy table acct_recv\n       (acct_name=char(0)'%',\n       address='d0%',\n       credit=char(0)'%' with null('xx'),\n       debit=char(0)'%' with null('xx'),\n       acct_mngr=char(15),\n       xx=d0nl)\n       into 'qtr_result';\n   ```\n\n   Smith Corp%% $12345.00% $-67890.00%Jones\n   ABC Oil %% $54321.00% $-98765.00%Green\n   Spring Omc%%xx %xx %Namroc\n\n8. Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\n\n   ```sql\n   copy table gifts\n       (item_name=char(0)tab,\n       date_recd=char(0)tab,\n       sender=char(20)nl with null('anonymous'))\n       into 'giftdata';\n   ```\n\n   toaster 04-mar-1993 Nicholas\n   sled 10-oct-1993 anonymous\n   rocket 01-dec-1993 Francisco\n\n9. Create a table and load it using bulk copy, specifying structural options.\n\n   ```sql\n   create table mytable (name char 25, ...);\n   \n   modify mytable to hash;\n   \n   copy mytable() from 'myfile' with minpages = 16384,\n   maxpages = 16384, allocation = 16384;\n   ```"
        ]
    },
    {
        "instruction": "What are some advanced options available for Actian 4GL SQL COPY statements, and how can they be useful when importing/exporting large datasets?",
        "input": "",
        "output": "Advanced options available for Actian 4GL SQL COPY statements help in managing the performance of data import and export operations, especially with large datasets. Some examples include `minpages`, `maxpages`, and `allocation`. These options can be used to specify the minimum number of pages to read or write at a time, the maximum number of pages to read or write, and the allocation size per page respectively. These settings can help optimize performance by reducing disk I/O and improving data transfer rates during bulk operations on large datasets.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "# Copy Statement\n\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\n\nThis statement has the following syntax:\n\n```sql\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\n```\n\n## Parameters--Copy Statement\n\nThis statement has the following parameters:\n\n- **table_name**: Specifies an existing table from which data is read or to which data is written.\n- **column_name**: Specifies the column from which data is read or to which data is written.\n- **format**: Specifies the format in which a value is stored in the file.\n- **filename**: Specifies the file from which data is read or to which data is written.\n- **type**: (Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\n\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\n\n- **with_clause**: Consists of the word with, followed by a comma-separated list of one or more of the following items:\n  - on_error = TERMINATE | CONTINUE\n  - error_count = n\n  - rollback = ENABLED | DISABLED\n  - log = 'filename'\n\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\n- allocation = n\n- extend = n\n- fillfactor = n (ISAM, Hash, and Btree only)\n- minpages = n (Hash only)\n- maxpages = n (Hash only)\n- leaffill = n (Btree only)\n- nonleaffill = n (Btree only)\n- row_estimate = n\n\n## Unformatted Copying\n\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\n\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\n\n```sql\ncopy table employee () into 'emp_name';\n```\n\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\n\nNote: An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\n\n## Formatted Copying\n\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\n\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\n\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\n\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\n\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).",
            "The values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.\n\nNote: If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\n\n```sql\ncopy table t (col1=c20, col2=c30, d0=nl) into 't.out':\n```\n\n## Bulk Copying\n\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\n\nThe requirements for performing a bulk copy are:\n\n- The table is not journaled\n- The table has no secondary indexes\n- For storage structures other than heap, the table is empty and occupies fewer than 18 pages\n\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\n\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\n\n## Column Formats for Copy\n\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\n\nNote: When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\n\n### Character (Text) Formats\n\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\n\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\n\nThe subtle differences between the various character formats are described in Copy Format Details.\n\n### Counted Character Formats\n\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\n\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\n\nNote: Nvarchar(0) is not a counted format.\n\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\n\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\n\n### Dummy Format\n\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\n\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\n\n### Unicode Formats\n\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\n\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\n\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\n\n### Binary Formats",
            "### Binary Formats\n\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\n\nCertainly. I'll convert the provided documentation into a Markdown (.md) file format, maintaining the content while adjusting only the formatting. Here's the result:\n\n### Copy Format Details\n\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\n- Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n- When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n- The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\n\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).",
            "| Format | How Stored (copy into) | How Read (copy from) |\n|--------|------------------------|----------------------|\n| boolean | Written as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format) | Same format as copy into |\n| byte(0) | Same as byte(n) where n is the display length of the corresponding table column. | Read as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. |\n| byte(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded. |\n| byte varying(0) | Same as byte varying(n) where n is the display length of the table column. | Read as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |\n| byte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |\n| C0 | Same as Cn where n is the display length of the corresponding table column | Read as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Any control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\. |\n| Cn | Written as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Any control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\. |\n| char(0) | Same as char(n) where n is the display length of the corresponding table column. | Read as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Unlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is. |\n| char(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding. Unlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Unlike C format, char does not convert control characters or tabs. File data is read as is. |\n| D0 | Instead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.) Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed. | Dummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value. Any \\ found in the input means that the next character is to be taken literally, and is not a delimiter. |\n| Dn | Dummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1. | Dummy field. N characters are read and discarded. Copy from does not allow a delimiter specification with a fixed-length dummy field. |\n| date | Written as a date. (A binary format) | Read as a date. (A binary format) |\n| decimal | Written as a decimal number. (A binary format.) | Read as a decimal number. (A binary format) |\n| float | Written as double\u2011precision floating point. (A binary format) | Read as double\u2011precision floating point. (A binary format) |\n| float4 | Written as single\u2011precision floating point. (A binary format) | Read as single\u2011precision floating point. (A binary format) |\n| integer | Written as integer of 4\u2011byte length. (A binary format) | Read as integer of 4\u2011byte length. (A binary format) |",
            "| integer1 | Written as integer of 1\u2011byte length. (A binary format) | Read as integer of 1\u2011byte length. (A binary format) |\n| long byte(0) | Identical to long varchar | Identical to long varchar |\n| long nvarchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). The maximum segment size for the long nvarchar segment is 32727 bytes. The UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment. If a delimiter is specified, it is written immediately following the last segment. | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| long varchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767. The following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long: 5 abcde10 abcdefghij 0 (with a space after the terminating 0 character) (In this example, the data that is in the originating table column is abcdeabcdefghij) | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| money | Written as a scaled floating point value (a money value). (A binary format) | Read as a scaled floating-point values (a money value). (A binary format) |\n| nchar(0) | Written as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value. | Read as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered. |\n| nvarchar(0) | Same as nchar(0) | Same as nchar(0) |\n| nchar(n) | Written as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| nvarchar(n) | Written as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding. The byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| smallint | Written as an integer of 2\u2011byte length. (A binary format.) | Read as integer of 2\u2011byte length. (A binary format) |\n| text(0) | Written as a variable length string. If a delimiter is specified, it is written after the value. If the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding. Copy into using text(0) format is the way to get variable width output with no padding. | Read as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value |\n| text(n) | Written as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding. | Reads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded. |\n| varchar(0) | Same as varchar(n), where n is the display length of the corresponding table column. | Read as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |",
            "| varchar(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length. | Read as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |",
            "Note: The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\n\nFor user-defined data types (UDTs), use char or varchar.\n\nCertainly. I'll create a single Markdown (.md) file based on the provided documentation, focusing on formatting the content without modifying it. Here's the Markdown version:\n\n### Delimiters in the Data File\n\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\n\n| Delimiter | Description |\n|-----------|-------------|\n| nl | Newline character |\n| tab | Tab character |\n| sp | Space |\n| csv | Comma separated values |\n| ssv | Semicolon separated values |\n| nul or null | Null/zero character |\n| comma | Comma |\n| colon | Colon |\n| dash | Dash |\n| lparen | Left parenthesis |\n| rparen | Right parenthesis |\n| X | Any non-numeric character |\n\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\n\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\n\n## CSV and SSV Delimiters\n\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\n\nThe rules for a CSV-delimited field are:\n\n- The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n- Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\n  ```\n  \"There is a double quote \"\" here\"\n  ```\n\n  is translated to the table value:\n\n  ```\n  There is a double quote \" here\n  ```\n\n  Whitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\n- Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\n\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\n\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \"counted\" formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)\n\nCopy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\n\n## With Null Clause for Copy\n\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\n\n### With Null (value) Clause\n\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\n\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.",
            "To prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\n\nFor example, this example of a value is incorrect:\n\n```\nc0comma with null(0)\n```\n\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\n\n```\nc0comma with null('0')\n```\n\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\n\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\n\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\n\n```sql\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\n```\n\nThe correct version specifies a 4-character format for the column.\n\n```sql\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\n```\n\n### With Null Clause Omitting Value\n\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\n\n## Filename Specification for Copy\n\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\n\nUNIX: For copy into, if the file already exists, copy overwrites it.\n\n## Windows File Types for Copy\n\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\n\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\n\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\n\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\n\nThe binary-copy forms (copy () from or copy () into) use binary mode.\n\nNote: Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.\n\nCopy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\n\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\n\n## With Clause for Copy\n\nValid with clause options for the copy statement are as follows:\n\n### On_error=TERMINATE|CONTINUE\n\nDirects copy to continue after encountering conversion errors.\n\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\n\nBy default, copy terminates when an error occurs while converting between table format and file format\n\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\n\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\n\n### Error_count=n\n\nSpecifies how many errors can occur before processing terminates.\n\nDefault: 1.\n\nIf on_error is set to continue, setting error_count has no effect.",
            "Default: 1.\n\nIf on_error is set to continue, setting error_count has no effect.\n\n### Log='filename'\n\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\n\nLogging works as follows:\n\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\n\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\n\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\n\n### Rollback=ENABLED|DISABLED\n\nEnables or disables rollback, as follows:\n\n- ENABLED: Directs the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\n- DISABLED: Retains the appended rows.\n\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\n\nDefault: ENABLED\n\nWhen copying to a file, the with rollback clause has no effect.\n\n### Row_estimate\n\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\n\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\n\n## Permissions\n\nTo use the copy statement, one of the following must apply:\n\n- You own the table.\n- The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n- You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\n\n## Locking\n\n- When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n- When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n- When performing a non-bulk copy into a table, the DBMS server takes an \"intent exclusive\" lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\n\n## Restrictions and Considerations\n\n- Copy cannot be used to add data to a view, index, or system catalog.\n- When copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\n- When copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\n- The copy statement does not fire any rules defined against the table.\n- Values cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\n- Copy treats a present-but-empty field in the data file as:\n  - A blank default for character-based columns\n  - A zero default for numeric columns\n  - December 31 00-1 for date and timestamp columns\n  - 00:00:00 for time columns (and the time component in a timestamp)",
            "For example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\n\n## Related Statements\n\n- Create Table Statement\n- Modify Statement\n\n## Examples--Copy Statement\n\nThe following examples illustrate the correct use of the copy statement:\n\n1. In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\n\n   ```\n   ename     char(15)\n   age       integer4\n   dept      char(10)\n   comment   varchar(20)\n   ```\n\n   The emp.txt file contains the following data:\n\n   ```\n   Jones,J. 32 Anytown,USA toy,00017A This is a comment\n   Smith,P. 41 New York,NY admin,00015 Another comment\n   ```\n\n   The following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\n   - A dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\n   - The department field is delimited by a comma.\n   - The comment field is a variable-length varchar field, preceded by a five-character length specifier.\n\n2. Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\n\n   ```sql\n   copy table employee (eno=integer2, ename=char(10),\n       age=integer2, job=integer2, sal=float4,\n       dept=integer2, xxx=d1)\n       from 'myfile.in';\n   ```\n\n3. Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\n\n   ```sql\n   copy table employee (ename=char(0)comma,\n       eno=char(0)comma, sal= char(0)nl)\n       into 'mfile.out';\n   ```\n\n   Joe Smith , 101, $25000.00\n   \n   Shirley Scott , 102, $30000.00\n\n4. The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\n\n   ```sql\n   copy table employee (ename = text(0)csv,\n       eno = text(0)csv, sal = text(0)csv)\n       into 'mfile.out';\n   ```\n    \n   Joe Smith,101,$25000.00\n   Shirley Scott,102,$30000.00\n\n5. Bulk copy the employee table into a file. The resulting data file contains binary data.\n\n   ```sql\n   copy table employee () into 'ourfile.dat';\n   ```\n\n6. Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\n\n   ```sql\n   copy table other_employee_table () from 'ourfile.dat';\n   ```\n\n7. Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\n\n   ```sql\n   copy table acct_recv\n       (acct_name=char(0)'%',\n       address='d0%',\n       credit=char(0)'%' with null('xx'),\n       debit=char(0)'%' with null('xx'),\n       acct_mngr=char(15),\n       xx=d0nl)\n       into 'qtr_result';\n   ```\n\n   Smith Corp%% $12345.00% $-67890.00%Jones\n   ABC Oil %% $54321.00% $-98765.00%Green\n   Spring Omc%%xx %xx %Namroc\n\n8. Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\n\n   ```sql\n   copy table gifts\n       (item_name=char(0)tab,\n       date_recd=char(0)tab,\n       sender=char(20)nl with null('anonymous'))\n       into 'giftdata';\n   ```\n\n   toaster 04-mar-1993 Nicholas\n   sled 10-oct-1993 anonymous\n   rocket 01-dec-1993 Francisco\n\n9. Create a table and load it using bulk copy, specifying structural options.\n\n   ```sql\n   create table mytable (name char 25, ...);\n   \n   modify mytable to hash;\n   \n   copy mytable() from 'myfile' with minpages = 16384,\n   maxpages = 16384, allocation = 16384;\n   ```"
        ]
    },
    {
        "instruction": "Describe the role and usage of delimiters in Actian 4GL SQL COPY statements with examples.",
        "input": "",
        "output": "Delimiters play a crucial role in Actian 4GL SQL COPY statements when handling delimited values such as CSV (Comma Separated Values). By default, the values are considered space-delimited if no specific delimiter is defined. A delimiter can be explicitly specified by including it in the copy list. For example:\n\n```sql\ncopy table t (col1=c20, col2=c30, d0=nl, col3=c10, delim=',')\n    into 't.out';\n```\nIn this case, the `delim=','` specifies that the data file values for columns `col1`, `col2`, and `col3` are separated by commas. Using a specified delimiter ensures accurate reading of the data from a file during the import process and allows better control over how the data is organized.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "# Copy Statement\n\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\n\nThis statement has the following syntax:\n\n```sql\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\n```\n\n## Parameters--Copy Statement\n\nThis statement has the following parameters:\n\n- **table_name**: Specifies an existing table from which data is read or to which data is written.\n- **column_name**: Specifies the column from which data is read or to which data is written.\n- **format**: Specifies the format in which a value is stored in the file.\n- **filename**: Specifies the file from which data is read or to which data is written.\n- **type**: (Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\n\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\n\n- **with_clause**: Consists of the word with, followed by a comma-separated list of one or more of the following items:\n  - on_error = TERMINATE | CONTINUE\n  - error_count = n\n  - rollback = ENABLED | DISABLED\n  - log = 'filename'\n\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\n- allocation = n\n- extend = n\n- fillfactor = n (ISAM, Hash, and Btree only)\n- minpages = n (Hash only)\n- maxpages = n (Hash only)\n- leaffill = n (Btree only)\n- nonleaffill = n (Btree only)\n- row_estimate = n\n\n## Unformatted Copying\n\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\n\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\n\n```sql\ncopy table employee () into 'emp_name';\n```\n\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\n\nNote: An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\n\n## Formatted Copying\n\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\n\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\n\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\n\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\n\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).",
            "The values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.\n\nNote: If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\n\n```sql\ncopy table t (col1=c20, col2=c30, d0=nl) into 't.out':\n```\n\n## Bulk Copying\n\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\n\nThe requirements for performing a bulk copy are:\n\n- The table is not journaled\n- The table has no secondary indexes\n- For storage structures other than heap, the table is empty and occupies fewer than 18 pages\n\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\n\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\n\n## Column Formats for Copy\n\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\n\nNote: When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\n\n### Character (Text) Formats\n\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\n\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\n\nThe subtle differences between the various character formats are described in Copy Format Details.\n\n### Counted Character Formats\n\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\n\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\n\nNote: Nvarchar(0) is not a counted format.\n\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\n\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\n\n### Dummy Format\n\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\n\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\n\n### Unicode Formats\n\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\n\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\n\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\n\n### Binary Formats",
            "### Binary Formats\n\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\n\nCertainly. I'll convert the provided documentation into a Markdown (.md) file format, maintaining the content while adjusting only the formatting. Here's the result:\n\n### Copy Format Details\n\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\n- Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n- When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n- The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\n\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).",
            "| Format | How Stored (copy into) | How Read (copy from) |\n|--------|------------------------|----------------------|\n| boolean | Written as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format) | Same format as copy into |\n| byte(0) | Same as byte(n) where n is the display length of the corresponding table column. | Read as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. |\n| byte(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded. |\n| byte varying(0) | Same as byte varying(n) where n is the display length of the table column. | Read as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |\n| byte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |\n| C0 | Same as Cn where n is the display length of the corresponding table column | Read as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Any control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\. |\n| Cn | Written as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Any control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\. |\n| char(0) | Same as char(n) where n is the display length of the corresponding table column. | Read as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Unlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is. |\n| char(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding. Unlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Unlike C format, char does not convert control characters or tabs. File data is read as is. |\n| D0 | Instead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.) Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed. | Dummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value. Any \\ found in the input means that the next character is to be taken literally, and is not a delimiter. |\n| Dn | Dummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1. | Dummy field. N characters are read and discarded. Copy from does not allow a delimiter specification with a fixed-length dummy field. |\n| date | Written as a date. (A binary format) | Read as a date. (A binary format) |\n| decimal | Written as a decimal number. (A binary format.) | Read as a decimal number. (A binary format) |\n| float | Written as double\u2011precision floating point. (A binary format) | Read as double\u2011precision floating point. (A binary format) |\n| float4 | Written as single\u2011precision floating point. (A binary format) | Read as single\u2011precision floating point. (A binary format) |\n| integer | Written as integer of 4\u2011byte length. (A binary format) | Read as integer of 4\u2011byte length. (A binary format) |",
            "| integer1 | Written as integer of 1\u2011byte length. (A binary format) | Read as integer of 1\u2011byte length. (A binary format) |\n| long byte(0) | Identical to long varchar | Identical to long varchar |\n| long nvarchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). The maximum segment size for the long nvarchar segment is 32727 bytes. The UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment. If a delimiter is specified, it is written immediately following the last segment. | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| long varchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767. The following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long: 5 abcde10 abcdefghij 0 (with a space after the terminating 0 character) (In this example, the data that is in the originating table column is abcdeabcdefghij) | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| money | Written as a scaled floating point value (a money value). (A binary format) | Read as a scaled floating-point values (a money value). (A binary format) |\n| nchar(0) | Written as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value. | Read as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered. |\n| nvarchar(0) | Same as nchar(0) | Same as nchar(0) |\n| nchar(n) | Written as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| nvarchar(n) | Written as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding. The byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| smallint | Written as an integer of 2\u2011byte length. (A binary format.) | Read as integer of 2\u2011byte length. (A binary format) |\n| text(0) | Written as a variable length string. If a delimiter is specified, it is written after the value. If the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding. Copy into using text(0) format is the way to get variable width output with no padding. | Read as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value |\n| text(n) | Written as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding. | Reads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded. |\n| varchar(0) | Same as varchar(n), where n is the display length of the corresponding table column. | Read as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |",
            "| varchar(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length. | Read as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |",
            "Note: The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\n\nFor user-defined data types (UDTs), use char or varchar.\n\nCertainly. I'll create a single Markdown (.md) file based on the provided documentation, focusing on formatting the content without modifying it. Here's the Markdown version:\n\n### Delimiters in the Data File\n\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\n\n| Delimiter | Description |\n|-----------|-------------|\n| nl | Newline character |\n| tab | Tab character |\n| sp | Space |\n| csv | Comma separated values |\n| ssv | Semicolon separated values |\n| nul or null | Null/zero character |\n| comma | Comma |\n| colon | Colon |\n| dash | Dash |\n| lparen | Left parenthesis |\n| rparen | Right parenthesis |\n| X | Any non-numeric character |\n\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\n\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\n\n## CSV and SSV Delimiters\n\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\n\nThe rules for a CSV-delimited field are:\n\n- The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n- Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\n  ```\n  \"There is a double quote \"\" here\"\n  ```\n\n  is translated to the table value:\n\n  ```\n  There is a double quote \" here\n  ```\n\n  Whitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\n- Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\n\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\n\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \"counted\" formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)\n\nCopy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\n\n## With Null Clause for Copy\n\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\n\n### With Null (value) Clause\n\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\n\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.",
            "To prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\n\nFor example, this example of a value is incorrect:\n\n```\nc0comma with null(0)\n```\n\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\n\n```\nc0comma with null('0')\n```\n\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\n\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\n\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\n\n```sql\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\n```\n\nThe correct version specifies a 4-character format for the column.\n\n```sql\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\n```\n\n### With Null Clause Omitting Value\n\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\n\n## Filename Specification for Copy\n\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\n\nUNIX: For copy into, if the file already exists, copy overwrites it.\n\n## Windows File Types for Copy\n\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\n\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\n\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\n\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\n\nThe binary-copy forms (copy () from or copy () into) use binary mode.\n\nNote: Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.\n\nCopy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\n\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\n\n## With Clause for Copy\n\nValid with clause options for the copy statement are as follows:\n\n### On_error=TERMINATE|CONTINUE\n\nDirects copy to continue after encountering conversion errors.\n\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\n\nBy default, copy terminates when an error occurs while converting between table format and file format\n\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\n\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\n\n### Error_count=n\n\nSpecifies how many errors can occur before processing terminates.\n\nDefault: 1.\n\nIf on_error is set to continue, setting error_count has no effect.",
            "Default: 1.\n\nIf on_error is set to continue, setting error_count has no effect.\n\n### Log='filename'\n\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\n\nLogging works as follows:\n\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\n\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\n\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\n\n### Rollback=ENABLED|DISABLED\n\nEnables or disables rollback, as follows:\n\n- ENABLED: Directs the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\n- DISABLED: Retains the appended rows.\n\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\n\nDefault: ENABLED\n\nWhen copying to a file, the with rollback clause has no effect.\n\n### Row_estimate\n\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\n\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\n\n## Permissions\n\nTo use the copy statement, one of the following must apply:\n\n- You own the table.\n- The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n- You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\n\n## Locking\n\n- When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n- When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n- When performing a non-bulk copy into a table, the DBMS server takes an \"intent exclusive\" lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\n\n## Restrictions and Considerations\n\n- Copy cannot be used to add data to a view, index, or system catalog.\n- When copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\n- When copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\n- The copy statement does not fire any rules defined against the table.\n- Values cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\n- Copy treats a present-but-empty field in the data file as:\n  - A blank default for character-based columns\n  - A zero default for numeric columns\n  - December 31 00-1 for date and timestamp columns\n  - 00:00:00 for time columns (and the time component in a timestamp)",
            "For example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\n\n## Related Statements\n\n- Create Table Statement\n- Modify Statement\n\n## Examples--Copy Statement\n\nThe following examples illustrate the correct use of the copy statement:\n\n1. In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\n\n   ```\n   ename     char(15)\n   age       integer4\n   dept      char(10)\n   comment   varchar(20)\n   ```\n\n   The emp.txt file contains the following data:\n\n   ```\n   Jones,J. 32 Anytown,USA toy,00017A This is a comment\n   Smith,P. 41 New York,NY admin,00015 Another comment\n   ```\n\n   The following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\n   - A dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\n   - The department field is delimited by a comma.\n   - The comment field is a variable-length varchar field, preceded by a five-character length specifier.\n\n2. Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\n\n   ```sql\n   copy table employee (eno=integer2, ename=char(10),\n       age=integer2, job=integer2, sal=float4,\n       dept=integer2, xxx=d1)\n       from 'myfile.in';\n   ```\n\n3. Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\n\n   ```sql\n   copy table employee (ename=char(0)comma,\n       eno=char(0)comma, sal= char(0)nl)\n       into 'mfile.out';\n   ```\n\n   Joe Smith , 101, $25000.00\n   \n   Shirley Scott , 102, $30000.00\n\n4. The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\n\n   ```sql\n   copy table employee (ename = text(0)csv,\n       eno = text(0)csv, sal = text(0)csv)\n       into 'mfile.out';\n   ```\n    \n   Joe Smith,101,$25000.00\n   Shirley Scott,102,$30000.00\n\n5. Bulk copy the employee table into a file. The resulting data file contains binary data.\n\n   ```sql\n   copy table employee () into 'ourfile.dat';\n   ```\n\n6. Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\n\n   ```sql\n   copy table other_employee_table () from 'ourfile.dat';\n   ```\n\n7. Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\n\n   ```sql\n   copy table acct_recv\n       (acct_name=char(0)'%',\n       address='d0%',\n       credit=char(0)'%' with null('xx'),\n       debit=char(0)'%' with null('xx'),\n       acct_mngr=char(15),\n       xx=d0nl)\n       into 'qtr_result';\n   ```\n\n   Smith Corp%% $12345.00% $-67890.00%Jones\n   ABC Oil %% $54321.00% $-98765.00%Green\n   Spring Omc%%xx %xx %Namroc\n\n8. Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\n\n   ```sql\n   copy table gifts\n       (item_name=char(0)tab,\n       date_recd=char(0)tab,\n       sender=char(20)nl with null('anonymous'))\n       into 'giftdata';\n   ```\n\n   toaster 04-mar-1993 Nicholas\n   sled 10-oct-1993 anonymous\n   rocket 01-dec-1993 Francisco\n\n9. Create a table and load it using bulk copy, specifying structural options.\n\n   ```sql\n   create table mytable (name char 25, ...);\n   \n   modify mytable to hash;\n   \n   copy mytable() from 'myfile' with minpages = 16384,\n   maxpages = 16384, allocation = 16384;\n   ```"
        ]
    },
    {
        "instruction": "Explain how to estimate the number of rows for bulk copy operations in Actian 4GL SQL COPY statements.",
        "input": "",
        "output": "To estimate the number of rows for bulk copy operations, you can use the `row_estimate` clause during copying. This allows the DBMS Server to optimize the data transfer by estimating the required memory and I/O resources. The syntax is as follows:\n```sql\ncopy table <table_name> (<column_list>) into '<output_file>' with row_estimate=<rows>;\n```\nReplace `<table_name>`, `<column_list>`, `<output_file>`, and `<rows>` with appropriate values. For instance, if you're importing 10,000 rows into a table named \"employees\" from a file called \"employees_data.csv\", the command would be:\n```sql\ncopy table employees (eno=integer2, ename=char(10), age=integer2, dept=char(10))\n    into 'employees_data.csv' with row_estimate=10000;\n```",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "# Copy Statement\n\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\n\nThis statement has the following syntax:\n\n```sql\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\n```\n\n## Parameters--Copy Statement\n\nThis statement has the following parameters:\n\n- **table_name**: Specifies an existing table from which data is read or to which data is written.\n- **column_name**: Specifies the column from which data is read or to which data is written.\n- **format**: Specifies the format in which a value is stored in the file.\n- **filename**: Specifies the file from which data is read or to which data is written.\n- **type**: (Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\n\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\n\n- **with_clause**: Consists of the word with, followed by a comma-separated list of one or more of the following items:\n  - on_error = TERMINATE | CONTINUE\n  - error_count = n\n  - rollback = ENABLED | DISABLED\n  - log = 'filename'\n\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\n- allocation = n\n- extend = n\n- fillfactor = n (ISAM, Hash, and Btree only)\n- minpages = n (Hash only)\n- maxpages = n (Hash only)\n- leaffill = n (Btree only)\n- nonleaffill = n (Btree only)\n- row_estimate = n\n\n## Unformatted Copying\n\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\n\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\n\n```sql\ncopy table employee () into 'emp_name';\n```\n\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\n\nNote: An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\n\n## Formatted Copying\n\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\n\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\n\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\n\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\n\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).",
            "The values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.\n\nNote: If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\n\n```sql\ncopy table t (col1=c20, col2=c30, d0=nl) into 't.out':\n```\n\n## Bulk Copying\n\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\n\nThe requirements for performing a bulk copy are:\n\n- The table is not journaled\n- The table has no secondary indexes\n- For storage structures other than heap, the table is empty and occupies fewer than 18 pages\n\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\n\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\n\n## Column Formats for Copy\n\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\n\nNote: When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\n\n### Character (Text) Formats\n\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\n\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\n\nThe subtle differences between the various character formats are described in Copy Format Details.\n\n### Counted Character Formats\n\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\n\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\n\nNote: Nvarchar(0) is not a counted format.\n\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\n\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\n\n### Dummy Format\n\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\n\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\n\n### Unicode Formats\n\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\n\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\n\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\n\n### Binary Formats",
            "### Binary Formats\n\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\n\nCertainly. I'll convert the provided documentation into a Markdown (.md) file format, maintaining the content while adjusting only the formatting. Here's the result:\n\n### Copy Format Details\n\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\n- Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n- When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n- The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\n\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).",
            "| Format | How Stored (copy into) | How Read (copy from) |\n|--------|------------------------|----------------------|\n| boolean | Written as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format) | Same format as copy into |\n| byte(0) | Same as byte(n) where n is the display length of the corresponding table column. | Read as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. |\n| byte(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded. |\n| byte varying(0) | Same as byte varying(n) where n is the display length of the table column. | Read as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |\n| byte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |\n| C0 | Same as Cn where n is the display length of the corresponding table column | Read as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Any control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\. |\n| Cn | Written as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Any control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\. |\n| char(0) | Same as char(n) where n is the display length of the corresponding table column. | Read as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Unlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is. |\n| char(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding. Unlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Unlike C format, char does not convert control characters or tabs. File data is read as is. |\n| D0 | Instead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.) Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed. | Dummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value. Any \\ found in the input means that the next character is to be taken literally, and is not a delimiter. |\n| Dn | Dummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1. | Dummy field. N characters are read and discarded. Copy from does not allow a delimiter specification with a fixed-length dummy field. |\n| date | Written as a date. (A binary format) | Read as a date. (A binary format) |\n| decimal | Written as a decimal number. (A binary format.) | Read as a decimal number. (A binary format) |\n| float | Written as double\u2011precision floating point. (A binary format) | Read as double\u2011precision floating point. (A binary format) |\n| float4 | Written as single\u2011precision floating point. (A binary format) | Read as single\u2011precision floating point. (A binary format) |\n| integer | Written as integer of 4\u2011byte length. (A binary format) | Read as integer of 4\u2011byte length. (A binary format) |",
            "| integer1 | Written as integer of 1\u2011byte length. (A binary format) | Read as integer of 1\u2011byte length. (A binary format) |\n| long byte(0) | Identical to long varchar | Identical to long varchar |\n| long nvarchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). The maximum segment size for the long nvarchar segment is 32727 bytes. The UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment. If a delimiter is specified, it is written immediately following the last segment. | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| long varchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767. The following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long: 5 abcde10 abcdefghij 0 (with a space after the terminating 0 character) (In this example, the data that is in the originating table column is abcdeabcdefghij) | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| money | Written as a scaled floating point value (a money value). (A binary format) | Read as a scaled floating-point values (a money value). (A binary format) |\n| nchar(0) | Written as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value. | Read as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered. |\n| nvarchar(0) | Same as nchar(0) | Same as nchar(0) |\n| nchar(n) | Written as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| nvarchar(n) | Written as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding. The byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| smallint | Written as an integer of 2\u2011byte length. (A binary format.) | Read as integer of 2\u2011byte length. (A binary format) |\n| text(0) | Written as a variable length string. If a delimiter is specified, it is written after the value. If the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding. Copy into using text(0) format is the way to get variable width output with no padding. | Read as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value |\n| text(n) | Written as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding. | Reads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded. |\n| varchar(0) | Same as varchar(n), where n is the display length of the corresponding table column. | Read as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |",
            "| varchar(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length. | Read as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |",
            "Note: The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\n\nFor user-defined data types (UDTs), use char or varchar.\n\nCertainly. I'll create a single Markdown (.md) file based on the provided documentation, focusing on formatting the content without modifying it. Here's the Markdown version:\n\n### Delimiters in the Data File\n\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\n\n| Delimiter | Description |\n|-----------|-------------|\n| nl | Newline character |\n| tab | Tab character |\n| sp | Space |\n| csv | Comma separated values |\n| ssv | Semicolon separated values |\n| nul or null | Null/zero character |\n| comma | Comma |\n| colon | Colon |\n| dash | Dash |\n| lparen | Left parenthesis |\n| rparen | Right parenthesis |\n| X | Any non-numeric character |\n\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\n\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\n\n## CSV and SSV Delimiters\n\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\n\nThe rules for a CSV-delimited field are:\n\n- The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n- Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\n  ```\n  \"There is a double quote \"\" here\"\n  ```\n\n  is translated to the table value:\n\n  ```\n  There is a double quote \" here\n  ```\n\n  Whitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\n- Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\n\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\n\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \"counted\" formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)\n\nCopy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\n\n## With Null Clause for Copy\n\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\n\n### With Null (value) Clause\n\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\n\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.",
            "To prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\n\nFor example, this example of a value is incorrect:\n\n```\nc0comma with null(0)\n```\n\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\n\n```\nc0comma with null('0')\n```\n\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\n\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\n\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\n\n```sql\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\n```\n\nThe correct version specifies a 4-character format for the column.\n\n```sql\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\n```\n\n### With Null Clause Omitting Value\n\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\n\n## Filename Specification for Copy\n\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\n\nUNIX: For copy into, if the file already exists, copy overwrites it.\n\n## Windows File Types for Copy\n\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\n\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\n\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\n\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\n\nThe binary-copy forms (copy () from or copy () into) use binary mode.\n\nNote: Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.\n\nCopy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\n\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\n\n## With Clause for Copy\n\nValid with clause options for the copy statement are as follows:\n\n### On_error=TERMINATE|CONTINUE\n\nDirects copy to continue after encountering conversion errors.\n\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\n\nBy default, copy terminates when an error occurs while converting between table format and file format\n\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\n\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\n\n### Error_count=n\n\nSpecifies how many errors can occur before processing terminates.\n\nDefault: 1.\n\nIf on_error is set to continue, setting error_count has no effect.",
            "Default: 1.\n\nIf on_error is set to continue, setting error_count has no effect.\n\n### Log='filename'\n\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\n\nLogging works as follows:\n\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\n\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\n\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\n\n### Rollback=ENABLED|DISABLED\n\nEnables or disables rollback, as follows:\n\n- ENABLED: Directs the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\n- DISABLED: Retains the appended rows.\n\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\n\nDefault: ENABLED\n\nWhen copying to a file, the with rollback clause has no effect.\n\n### Row_estimate\n\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\n\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\n\n## Permissions\n\nTo use the copy statement, one of the following must apply:\n\n- You own the table.\n- The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n- You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\n\n## Locking\n\n- When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n- When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n- When performing a non-bulk copy into a table, the DBMS server takes an \"intent exclusive\" lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\n\n## Restrictions and Considerations\n\n- Copy cannot be used to add data to a view, index, or system catalog.\n- When copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\n- When copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\n- The copy statement does not fire any rules defined against the table.\n- Values cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\n- Copy treats a present-but-empty field in the data file as:\n  - A blank default for character-based columns\n  - A zero default for numeric columns\n  - December 31 00-1 for date and timestamp columns\n  - 00:00:00 for time columns (and the time component in a timestamp)",
            "For example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\n\n## Related Statements\n\n- Create Table Statement\n- Modify Statement\n\n## Examples--Copy Statement\n\nThe following examples illustrate the correct use of the copy statement:\n\n1. In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\n\n   ```\n   ename     char(15)\n   age       integer4\n   dept      char(10)\n   comment   varchar(20)\n   ```\n\n   The emp.txt file contains the following data:\n\n   ```\n   Jones,J. 32 Anytown,USA toy,00017A This is a comment\n   Smith,P. 41 New York,NY admin,00015 Another comment\n   ```\n\n   The following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\n   - A dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\n   - The department field is delimited by a comma.\n   - The comment field is a variable-length varchar field, preceded by a five-character length specifier.\n\n2. Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\n\n   ```sql\n   copy table employee (eno=integer2, ename=char(10),\n       age=integer2, job=integer2, sal=float4,\n       dept=integer2, xxx=d1)\n       from 'myfile.in';\n   ```\n\n3. Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\n\n   ```sql\n   copy table employee (ename=char(0)comma,\n       eno=char(0)comma, sal= char(0)nl)\n       into 'mfile.out';\n   ```\n\n   Joe Smith , 101, $25000.00\n   \n   Shirley Scott , 102, $30000.00\n\n4. The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\n\n   ```sql\n   copy table employee (ename = text(0)csv,\n       eno = text(0)csv, sal = text(0)csv)\n       into 'mfile.out';\n   ```\n    \n   Joe Smith,101,$25000.00\n   Shirley Scott,102,$30000.00\n\n5. Bulk copy the employee table into a file. The resulting data file contains binary data.\n\n   ```sql\n   copy table employee () into 'ourfile.dat';\n   ```\n\n6. Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\n\n   ```sql\n   copy table other_employee_table () from 'ourfile.dat';\n   ```\n\n7. Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\n\n   ```sql\n   copy table acct_recv\n       (acct_name=char(0)'%',\n       address='d0%',\n       credit=char(0)'%' with null('xx'),\n       debit=char(0)'%' with null('xx'),\n       acct_mngr=char(15),\n       xx=d0nl)\n       into 'qtr_result';\n   ```\n\n   Smith Corp%% $12345.00% $-67890.00%Jones\n   ABC Oil %% $54321.00% $-98765.00%Green\n   Spring Omc%%xx %xx %Namroc\n\n8. Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\n\n   ```sql\n   copy table gifts\n       (item_name=char(0)tab,\n       date_recd=char(0)tab,\n       sender=char(20)nl with null('anonymous'))\n       into 'giftdata';\n   ```\n\n   toaster 04-mar-1993 Nicholas\n   sled 10-oct-1993 anonymous\n   rocket 01-dec-1993 Francisco\n\n9. Create a table and load it using bulk copy, specifying structural options.\n\n   ```sql\n   create table mytable (name char 25, ...);\n   \n   modify mytable to hash;\n   \n   copy mytable() from 'myfile' with minpages = 16384,\n   maxpages = 16384, allocation = 16384;\n   ```"
        ]
    },
    {
        "instruction": "What is the purpose of the `Log` option in Actian 4GL SQL COPY statements?",
        "input": "",
        "output": "The `Log` option in Actian 4GL SQL COPY statements stores rows that cannot be processed by copy into a specified file. If the on_error parameter is set to continue, copy places any failed rows into the specified log file for further analysis or correction.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "# Copy Statement\n\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\n\nThis statement has the following syntax:\n\n```sql\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\n```\n\n## Parameters--Copy Statement\n\nThis statement has the following parameters:\n\n- **table_name**: Specifies an existing table from which data is read or to which data is written.\n- **column_name**: Specifies the column from which data is read or to which data is written.\n- **format**: Specifies the format in which a value is stored in the file.\n- **filename**: Specifies the file from which data is read or to which data is written.\n- **type**: (Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\n\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\n\n- **with_clause**: Consists of the word with, followed by a comma-separated list of one or more of the following items:\n  - on_error = TERMINATE | CONTINUE\n  - error_count = n\n  - rollback = ENABLED | DISABLED\n  - log = 'filename'\n\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\n- allocation = n\n- extend = n\n- fillfactor = n (ISAM, Hash, and Btree only)\n- minpages = n (Hash only)\n- maxpages = n (Hash only)\n- leaffill = n (Btree only)\n- nonleaffill = n (Btree only)\n- row_estimate = n\n\n## Unformatted Copying\n\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\n\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\n\n```sql\ncopy table employee () into 'emp_name';\n```\n\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\n\nNote: An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\n\n## Formatted Copying\n\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\n\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\n\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\n\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\n\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).",
            "The values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.\n\nNote: If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\n\n```sql\ncopy table t (col1=c20, col2=c30, d0=nl) into 't.out':\n```\n\n## Bulk Copying\n\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\n\nThe requirements for performing a bulk copy are:\n\n- The table is not journaled\n- The table has no secondary indexes\n- For storage structures other than heap, the table is empty and occupies fewer than 18 pages\n\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\n\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\n\n## Column Formats for Copy\n\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\n\nNote: When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\n\n### Character (Text) Formats\n\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\n\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\n\nThe subtle differences between the various character formats are described in Copy Format Details.\n\n### Counted Character Formats\n\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\n\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\n\nNote: Nvarchar(0) is not a counted format.\n\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\n\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\n\n### Dummy Format\n\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\n\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\n\n### Unicode Formats\n\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\n\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\n\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\n\n### Binary Formats",
            "### Binary Formats\n\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\n\nCertainly. I'll convert the provided documentation into a Markdown (.md) file format, maintaining the content while adjusting only the formatting. Here's the result:\n\n### Copy Format Details\n\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\n- Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n- When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n- The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\n\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).",
            "| Format | How Stored (copy into) | How Read (copy from) |\n|--------|------------------------|----------------------|\n| boolean | Written as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format) | Same format as copy into |\n| byte(0) | Same as byte(n) where n is the display length of the corresponding table column. | Read as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. |\n| byte(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded. |\n| byte varying(0) | Same as byte varying(n) where n is the display length of the table column. | Read as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |\n| byte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |\n| C0 | Same as Cn where n is the display length of the corresponding table column | Read as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Any control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\. |\n| Cn | Written as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Any control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\. |\n| char(0) | Same as char(n) where n is the display length of the corresponding table column. | Read as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Unlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is. |\n| char(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding. Unlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Unlike C format, char does not convert control characters or tabs. File data is read as is. |\n| D0 | Instead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.) Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed. | Dummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value. Any \\ found in the input means that the next character is to be taken literally, and is not a delimiter. |\n| Dn | Dummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1. | Dummy field. N characters are read and discarded. Copy from does not allow a delimiter specification with a fixed-length dummy field. |\n| date | Written as a date. (A binary format) | Read as a date. (A binary format) |\n| decimal | Written as a decimal number. (A binary format.) | Read as a decimal number. (A binary format) |\n| float | Written as double\u2011precision floating point. (A binary format) | Read as double\u2011precision floating point. (A binary format) |\n| float4 | Written as single\u2011precision floating point. (A binary format) | Read as single\u2011precision floating point. (A binary format) |\n| integer | Written as integer of 4\u2011byte length. (A binary format) | Read as integer of 4\u2011byte length. (A binary format) |",
            "| integer1 | Written as integer of 1\u2011byte length. (A binary format) | Read as integer of 1\u2011byte length. (A binary format) |\n| long byte(0) | Identical to long varchar | Identical to long varchar |\n| long nvarchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). The maximum segment size for the long nvarchar segment is 32727 bytes. The UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment. If a delimiter is specified, it is written immediately following the last segment. | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| long varchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767. The following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long: 5 abcde10 abcdefghij 0 (with a space after the terminating 0 character) (In this example, the data that is in the originating table column is abcdeabcdefghij) | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| money | Written as a scaled floating point value (a money value). (A binary format) | Read as a scaled floating-point values (a money value). (A binary format) |\n| nchar(0) | Written as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value. | Read as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered. |\n| nvarchar(0) | Same as nchar(0) | Same as nchar(0) |\n| nchar(n) | Written as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| nvarchar(n) | Written as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding. The byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| smallint | Written as an integer of 2\u2011byte length. (A binary format.) | Read as integer of 2\u2011byte length. (A binary format) |\n| text(0) | Written as a variable length string. If a delimiter is specified, it is written after the value. If the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding. Copy into using text(0) format is the way to get variable width output with no padding. | Read as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value |\n| text(n) | Written as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding. | Reads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded. |\n| varchar(0) | Same as varchar(n), where n is the display length of the corresponding table column. | Read as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |",
            "| varchar(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length. | Read as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |",
            "Note: The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\n\nFor user-defined data types (UDTs), use char or varchar.\n\nCertainly. I'll create a single Markdown (.md) file based on the provided documentation, focusing on formatting the content without modifying it. Here's the Markdown version:\n\n### Delimiters in the Data File\n\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\n\n| Delimiter | Description |\n|-----------|-------------|\n| nl | Newline character |\n| tab | Tab character |\n| sp | Space |\n| csv | Comma separated values |\n| ssv | Semicolon separated values |\n| nul or null | Null/zero character |\n| comma | Comma |\n| colon | Colon |\n| dash | Dash |\n| lparen | Left parenthesis |\n| rparen | Right parenthesis |\n| X | Any non-numeric character |\n\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\n\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\n\n## CSV and SSV Delimiters\n\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\n\nThe rules for a CSV-delimited field are:\n\n- The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n- Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\n  ```\n  \"There is a double quote \"\" here\"\n  ```\n\n  is translated to the table value:\n\n  ```\n  There is a double quote \" here\n  ```\n\n  Whitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\n- Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\n\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\n\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \"counted\" formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)\n\nCopy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\n\n## With Null Clause for Copy\n\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\n\n### With Null (value) Clause\n\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\n\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.",
            "To prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\n\nFor example, this example of a value is incorrect:\n\n```\nc0comma with null(0)\n```\n\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\n\n```\nc0comma with null('0')\n```\n\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\n\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\n\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\n\n```sql\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\n```\n\nThe correct version specifies a 4-character format for the column.\n\n```sql\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\n```\n\n### With Null Clause Omitting Value\n\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\n\n## Filename Specification for Copy\n\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\n\nUNIX: For copy into, if the file already exists, copy overwrites it.\n\n## Windows File Types for Copy\n\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\n\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\n\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\n\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\n\nThe binary-copy forms (copy () from or copy () into) use binary mode.\n\nNote: Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.\n\nCopy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\n\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\n\n## With Clause for Copy\n\nValid with clause options for the copy statement are as follows:\n\n### On_error=TERMINATE|CONTINUE\n\nDirects copy to continue after encountering conversion errors.\n\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\n\nBy default, copy terminates when an error occurs while converting between table format and file format\n\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\n\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\n\n### Error_count=n\n\nSpecifies how many errors can occur before processing terminates.\n\nDefault: 1.\n\nIf on_error is set to continue, setting error_count has no effect.",
            "Default: 1.\n\nIf on_error is set to continue, setting error_count has no effect.\n\n### Log='filename'\n\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\n\nLogging works as follows:\n\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\n\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\n\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\n\n### Rollback=ENABLED|DISABLED\n\nEnables or disables rollback, as follows:\n\n- ENABLED: Directs the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\n- DISABLED: Retains the appended rows.\n\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\n\nDefault: ENABLED\n\nWhen copying to a file, the with rollback clause has no effect.\n\n### Row_estimate\n\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\n\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\n\n## Permissions\n\nTo use the copy statement, one of the following must apply:\n\n- You own the table.\n- The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n- You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\n\n## Locking\n\n- When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n- When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n- When performing a non-bulk copy into a table, the DBMS server takes an \"intent exclusive\" lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\n\n## Restrictions and Considerations\n\n- Copy cannot be used to add data to a view, index, or system catalog.\n- When copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\n- When copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\n- The copy statement does not fire any rules defined against the table.\n- Values cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\n- Copy treats a present-but-empty field in the data file as:\n  - A blank default for character-based columns\n  - A zero default for numeric columns\n  - December 31 00-1 for date and timestamp columns\n  - 00:00:00 for time columns (and the time component in a timestamp)",
            "For example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\n\n## Related Statements\n\n- Create Table Statement\n- Modify Statement\n\n## Examples--Copy Statement\n\nThe following examples illustrate the correct use of the copy statement:\n\n1. In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\n\n   ```\n   ename     char(15)\n   age       integer4\n   dept      char(10)\n   comment   varchar(20)\n   ```\n\n   The emp.txt file contains the following data:\n\n   ```\n   Jones,J. 32 Anytown,USA toy,00017A This is a comment\n   Smith,P. 41 New York,NY admin,00015 Another comment\n   ```\n\n   The following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\n   - A dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\n   - The department field is delimited by a comma.\n   - The comment field is a variable-length varchar field, preceded by a five-character length specifier.\n\n2. Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\n\n   ```sql\n   copy table employee (eno=integer2, ename=char(10),\n       age=integer2, job=integer2, sal=float4,\n       dept=integer2, xxx=d1)\n       from 'myfile.in';\n   ```\n\n3. Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\n\n   ```sql\n   copy table employee (ename=char(0)comma,\n       eno=char(0)comma, sal= char(0)nl)\n       into 'mfile.out';\n   ```\n\n   Joe Smith , 101, $25000.00\n   \n   Shirley Scott , 102, $30000.00\n\n4. The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\n\n   ```sql\n   copy table employee (ename = text(0)csv,\n       eno = text(0)csv, sal = text(0)csv)\n       into 'mfile.out';\n   ```\n    \n   Joe Smith,101,$25000.00\n   Shirley Scott,102,$30000.00\n\n5. Bulk copy the employee table into a file. The resulting data file contains binary data.\n\n   ```sql\n   copy table employee () into 'ourfile.dat';\n   ```\n\n6. Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\n\n   ```sql\n   copy table other_employee_table () from 'ourfile.dat';\n   ```\n\n7. Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\n\n   ```sql\n   copy table acct_recv\n       (acct_name=char(0)'%',\n       address='d0%',\n       credit=char(0)'%' with null('xx'),\n       debit=char(0)'%' with null('xx'),\n       acct_mngr=char(15),\n       xx=d0nl)\n       into 'qtr_result';\n   ```\n\n   Smith Corp%% $12345.00% $-67890.00%Jones\n   ABC Oil %% $54321.00% $-98765.00%Green\n   Spring Omc%%xx %xx %Namroc\n\n8. Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\n\n   ```sql\n   copy table gifts\n       (item_name=char(0)tab,\n       date_recd=char(0)tab,\n       sender=char(20)nl with null('anonymous'))\n       into 'giftdata';\n   ```\n\n   toaster 04-mar-1993 Nicholas\n   sled 10-oct-1993 anonymous\n   rocket 01-dec-1993 Francisco\n\n9. Create a table and load it using bulk copy, specifying structural options.\n\n   ```sql\n   create table mytable (name char 25, ...);\n   \n   modify mytable to hash;\n   \n   copy mytable() from 'myfile' with minpages = 16384,\n   maxpages = 16384, allocation = 16384;\n   ```"
        ]
    },
    {
        "instruction": "What does the `Rollback` clause do in Actian 4GL SQL COPY statements?",
        "input": "",
        "output": "The `Rollback` clause in Actian 4GL SQL COPY statements specifies whether to roll back any rows that copy cannot process. The `ENABLED` option directs the DBMS Server to roll back all appended rows, while the `DISABLED` option retains them. The `Rollback=DISABLED` option does not mean that the operation cannot be rolled back; it can still be rolled back through the database server's transaction management system or when encountering data corruption errors.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "# Copy Statement\n\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\n\nThis statement has the following syntax:\n\n```sql\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\n```\n\n## Parameters--Copy Statement\n\nThis statement has the following parameters:\n\n- **table_name**: Specifies an existing table from which data is read or to which data is written.\n- **column_name**: Specifies the column from which data is read or to which data is written.\n- **format**: Specifies the format in which a value is stored in the file.\n- **filename**: Specifies the file from which data is read or to which data is written.\n- **type**: (Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\n\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\n\n- **with_clause**: Consists of the word with, followed by a comma-separated list of one or more of the following items:\n  - on_error = TERMINATE | CONTINUE\n  - error_count = n\n  - rollback = ENABLED | DISABLED\n  - log = 'filename'\n\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\n- allocation = n\n- extend = n\n- fillfactor = n (ISAM, Hash, and Btree only)\n- minpages = n (Hash only)\n- maxpages = n (Hash only)\n- leaffill = n (Btree only)\n- nonleaffill = n (Btree only)\n- row_estimate = n\n\n## Unformatted Copying\n\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\n\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\n\n```sql\ncopy table employee () into 'emp_name';\n```\n\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\n\nNote: An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\n\n## Formatted Copying\n\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\n\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\n\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\n\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\n\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).",
            "The values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.\n\nNote: If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\n\n```sql\ncopy table t (col1=c20, col2=c30, d0=nl) into 't.out':\n```\n\n## Bulk Copying\n\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\n\nThe requirements for performing a bulk copy are:\n\n- The table is not journaled\n- The table has no secondary indexes\n- For storage structures other than heap, the table is empty and occupies fewer than 18 pages\n\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\n\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\n\n## Column Formats for Copy\n\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\n\nNote: When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\n\n### Character (Text) Formats\n\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\n\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\n\nThe subtle differences between the various character formats are described in Copy Format Details.\n\n### Counted Character Formats\n\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\n\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\n\nNote: Nvarchar(0) is not a counted format.\n\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\n\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\n\n### Dummy Format\n\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\n\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\n\n### Unicode Formats\n\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\n\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\n\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\n\n### Binary Formats",
            "### Binary Formats\n\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\n\nCertainly. I'll convert the provided documentation into a Markdown (.md) file format, maintaining the content while adjusting only the formatting. Here's the result:\n\n### Copy Format Details\n\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\n- Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n- When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n- The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\n\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).",
            "| Format | How Stored (copy into) | How Read (copy from) |\n|--------|------------------------|----------------------|\n| boolean | Written as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format) | Same format as copy into |\n| byte(0) | Same as byte(n) where n is the display length of the corresponding table column. | Read as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. |\n| byte(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded. |\n| byte varying(0) | Same as byte varying(n) where n is the display length of the table column. | Read as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |\n| byte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |\n| C0 | Same as Cn where n is the display length of the corresponding table column | Read as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Any control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\. |\n| Cn | Written as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Any control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\. |\n| char(0) | Same as char(n) where n is the display length of the corresponding table column. | Read as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Unlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is. |\n| char(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding. Unlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Unlike C format, char does not convert control characters or tabs. File data is read as is. |\n| D0 | Instead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.) Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed. | Dummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value. Any \\ found in the input means that the next character is to be taken literally, and is not a delimiter. |\n| Dn | Dummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1. | Dummy field. N characters are read and discarded. Copy from does not allow a delimiter specification with a fixed-length dummy field. |\n| date | Written as a date. (A binary format) | Read as a date. (A binary format) |\n| decimal | Written as a decimal number. (A binary format.) | Read as a decimal number. (A binary format) |\n| float | Written as double\u2011precision floating point. (A binary format) | Read as double\u2011precision floating point. (A binary format) |\n| float4 | Written as single\u2011precision floating point. (A binary format) | Read as single\u2011precision floating point. (A binary format) |\n| integer | Written as integer of 4\u2011byte length. (A binary format) | Read as integer of 4\u2011byte length. (A binary format) |",
            "| integer1 | Written as integer of 1\u2011byte length. (A binary format) | Read as integer of 1\u2011byte length. (A binary format) |\n| long byte(0) | Identical to long varchar | Identical to long varchar |\n| long nvarchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). The maximum segment size for the long nvarchar segment is 32727 bytes. The UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment. If a delimiter is specified, it is written immediately following the last segment. | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| long varchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767. The following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long: 5 abcde10 abcdefghij 0 (with a space after the terminating 0 character) (In this example, the data that is in the originating table column is abcdeabcdefghij) | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| money | Written as a scaled floating point value (a money value). (A binary format) | Read as a scaled floating-point values (a money value). (A binary format) |\n| nchar(0) | Written as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value. | Read as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered. |\n| nvarchar(0) | Same as nchar(0) | Same as nchar(0) |\n| nchar(n) | Written as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| nvarchar(n) | Written as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding. The byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| smallint | Written as an integer of 2\u2011byte length. (A binary format.) | Read as integer of 2\u2011byte length. (A binary format) |\n| text(0) | Written as a variable length string. If a delimiter is specified, it is written after the value. If the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding. Copy into using text(0) format is the way to get variable width output with no padding. | Read as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value |\n| text(n) | Written as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding. | Reads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded. |\n| varchar(0) | Same as varchar(n), where n is the display length of the corresponding table column. | Read as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |",
            "| varchar(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length. | Read as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |",
            "Note: The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\n\nFor user-defined data types (UDTs), use char or varchar.\n\nCertainly. I'll create a single Markdown (.md) file based on the provided documentation, focusing on formatting the content without modifying it. Here's the Markdown version:\n\n### Delimiters in the Data File\n\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\n\n| Delimiter | Description |\n|-----------|-------------|\n| nl | Newline character |\n| tab | Tab character |\n| sp | Space |\n| csv | Comma separated values |\n| ssv | Semicolon separated values |\n| nul or null | Null/zero character |\n| comma | Comma |\n| colon | Colon |\n| dash | Dash |\n| lparen | Left parenthesis |\n| rparen | Right parenthesis |\n| X | Any non-numeric character |\n\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\n\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\n\n## CSV and SSV Delimiters\n\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\n\nThe rules for a CSV-delimited field are:\n\n- The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n- Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\n  ```\n  \"There is a double quote \"\" here\"\n  ```\n\n  is translated to the table value:\n\n  ```\n  There is a double quote \" here\n  ```\n\n  Whitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\n- Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\n\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\n\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \"counted\" formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)\n\nCopy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\n\n## With Null Clause for Copy\n\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\n\n### With Null (value) Clause\n\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\n\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.",
            "To prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\n\nFor example, this example of a value is incorrect:\n\n```\nc0comma with null(0)\n```\n\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\n\n```\nc0comma with null('0')\n```\n\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\n\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\n\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\n\n```sql\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\n```\n\nThe correct version specifies a 4-character format for the column.\n\n```sql\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\n```\n\n### With Null Clause Omitting Value\n\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\n\n## Filename Specification for Copy\n\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\n\nUNIX: For copy into, if the file already exists, copy overwrites it.\n\n## Windows File Types for Copy\n\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\n\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\n\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\n\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\n\nThe binary-copy forms (copy () from or copy () into) use binary mode.\n\nNote: Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.\n\nCopy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\n\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\n\n## With Clause for Copy\n\nValid with clause options for the copy statement are as follows:\n\n### On_error=TERMINATE|CONTINUE\n\nDirects copy to continue after encountering conversion errors.\n\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\n\nBy default, copy terminates when an error occurs while converting between table format and file format\n\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\n\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\n\n### Error_count=n\n\nSpecifies how many errors can occur before processing terminates.\n\nDefault: 1.\n\nIf on_error is set to continue, setting error_count has no effect.",
            "Default: 1.\n\nIf on_error is set to continue, setting error_count has no effect.\n\n### Log='filename'\n\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\n\nLogging works as follows:\n\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\n\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\n\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\n\n### Rollback=ENABLED|DISABLED\n\nEnables or disables rollback, as follows:\n\n- ENABLED: Directs the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\n- DISABLED: Retains the appended rows.\n\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\n\nDefault: ENABLED\n\nWhen copying to a file, the with rollback clause has no effect.\n\n### Row_estimate\n\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\n\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\n\n## Permissions\n\nTo use the copy statement, one of the following must apply:\n\n- You own the table.\n- The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n- You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\n\n## Locking\n\n- When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n- When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n- When performing a non-bulk copy into a table, the DBMS server takes an \"intent exclusive\" lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\n\n## Restrictions and Considerations\n\n- Copy cannot be used to add data to a view, index, or system catalog.\n- When copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\n- When copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\n- The copy statement does not fire any rules defined against the table.\n- Values cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\n- Copy treats a present-but-empty field in the data file as:\n  - A blank default for character-based columns\n  - A zero default for numeric columns\n  - December 31 00-1 for date and timestamp columns\n  - 00:00:00 for time columns (and the time component in a timestamp)",
            "For example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\n\n## Related Statements\n\n- Create Table Statement\n- Modify Statement\n\n## Examples--Copy Statement\n\nThe following examples illustrate the correct use of the copy statement:\n\n1. In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\n\n   ```\n   ename     char(15)\n   age       integer4\n   dept      char(10)\n   comment   varchar(20)\n   ```\n\n   The emp.txt file contains the following data:\n\n   ```\n   Jones,J. 32 Anytown,USA toy,00017A This is a comment\n   Smith,P. 41 New York,NY admin,00015 Another comment\n   ```\n\n   The following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\n   - A dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\n   - The department field is delimited by a comma.\n   - The comment field is a variable-length varchar field, preceded by a five-character length specifier.\n\n2. Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\n\n   ```sql\n   copy table employee (eno=integer2, ename=char(10),\n       age=integer2, job=integer2, sal=float4,\n       dept=integer2, xxx=d1)\n       from 'myfile.in';\n   ```\n\n3. Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\n\n   ```sql\n   copy table employee (ename=char(0)comma,\n       eno=char(0)comma, sal= char(0)nl)\n       into 'mfile.out';\n   ```\n\n   Joe Smith , 101, $25000.00\n   \n   Shirley Scott , 102, $30000.00\n\n4. The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\n\n   ```sql\n   copy table employee (ename = text(0)csv,\n       eno = text(0)csv, sal = text(0)csv)\n       into 'mfile.out';\n   ```\n    \n   Joe Smith,101,$25000.00\n   Shirley Scott,102,$30000.00\n\n5. Bulk copy the employee table into a file. The resulting data file contains binary data.\n\n   ```sql\n   copy table employee () into 'ourfile.dat';\n   ```\n\n6. Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\n\n   ```sql\n   copy table other_employee_table () from 'ourfile.dat';\n   ```\n\n7. Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\n\n   ```sql\n   copy table acct_recv\n       (acct_name=char(0)'%',\n       address='d0%',\n       credit=char(0)'%' with null('xx'),\n       debit=char(0)'%' with null('xx'),\n       acct_mngr=char(15),\n       xx=d0nl)\n       into 'qtr_result';\n   ```\n\n   Smith Corp%% $12345.00% $-67890.00%Jones\n   ABC Oil %% $54321.00% $-98765.00%Green\n   Spring Omc%%xx %xx %Namroc\n\n8. Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\n\n   ```sql\n   copy table gifts\n       (item_name=char(0)tab,\n       date_recd=char(0)tab,\n       sender=char(20)nl with null('anonymous'))\n       into 'giftdata';\n   ```\n\n   toaster 04-mar-1993 Nicholas\n   sled 10-oct-1993 anonymous\n   rocket 01-dec-1993 Francisco\n\n9. Create a table and load it using bulk copy, specifying structural options.\n\n   ```sql\n   create table mytable (name char 25, ...);\n   \n   modify mytable to hash;\n   \n   copy mytable() from 'myfile' with minpages = 16384,\n   maxpages = 16384, allocation = 16384;\n   ```"
        ]
    },
    {
        "instruction": "Explain the meaning and purpose of the `WITH NULL` clause in Actian 4GL SQL COPY statements.",
        "input": "",
        "output": "The `WITH NULL` clause is used in Actian 4GL SQL COPY statements to specify how missing or null values are represented during data import and export processes. A value can be specified to represent a missing or null value, which allows the DBMS Server to distinguish between actual data and missing/null values while reading and writing data files. This is essential for preventing conflicts between valid data and null entries and ensuring that data consistency is maintained during data operations.\nThe chosen value for nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values. If no value is specified for the `WITH NULL` clause, a trailing indicator byte is used to determine whether a file value is a null.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "# Copy Statement\n\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\n\nThis statement has the following syntax:\n\n```sql\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\n```\n\n## Parameters--Copy Statement\n\nThis statement has the following parameters:\n\n- **table_name**: Specifies an existing table from which data is read or to which data is written.\n- **column_name**: Specifies the column from which data is read or to which data is written.\n- **format**: Specifies the format in which a value is stored in the file.\n- **filename**: Specifies the file from which data is read or to which data is written.\n- **type**: (Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\n\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\n\n- **with_clause**: Consists of the word with, followed by a comma-separated list of one or more of the following items:\n  - on_error = TERMINATE | CONTINUE\n  - error_count = n\n  - rollback = ENABLED | DISABLED\n  - log = 'filename'\n\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\n- allocation = n\n- extend = n\n- fillfactor = n (ISAM, Hash, and Btree only)\n- minpages = n (Hash only)\n- maxpages = n (Hash only)\n- leaffill = n (Btree only)\n- nonleaffill = n (Btree only)\n- row_estimate = n\n\n## Unformatted Copying\n\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\n\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\n\n```sql\ncopy table employee () into 'emp_name';\n```\n\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\n\nNote: An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\n\n## Formatted Copying\n\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\n\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\n\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\n\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\n\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).",
            "The values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.\n\nNote: If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\n\n```sql\ncopy table t (col1=c20, col2=c30, d0=nl) into 't.out':\n```\n\n## Bulk Copying\n\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\n\nThe requirements for performing a bulk copy are:\n\n- The table is not journaled\n- The table has no secondary indexes\n- For storage structures other than heap, the table is empty and occupies fewer than 18 pages\n\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\n\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\n\n## Column Formats for Copy\n\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\n\nNote: When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\n\n### Character (Text) Formats\n\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\n\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\n\nThe subtle differences between the various character formats are described in Copy Format Details.\n\n### Counted Character Formats\n\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\n\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\n\nNote: Nvarchar(0) is not a counted format.\n\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\n\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\n\n### Dummy Format\n\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\n\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\n\n### Unicode Formats\n\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\n\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\n\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\n\n### Binary Formats",
            "### Binary Formats\n\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\n\nCertainly. I'll convert the provided documentation into a Markdown (.md) file format, maintaining the content while adjusting only the formatting. Here's the result:\n\n### Copy Format Details\n\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\n- Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n- When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n- The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\n\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).",
            "| Format | How Stored (copy into) | How Read (copy from) |\n|--------|------------------------|----------------------|\n| boolean | Written as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format) | Same format as copy into |\n| byte(0) | Same as byte(n) where n is the display length of the corresponding table column. | Read as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. |\n| byte(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded. |\n| byte varying(0) | Same as byte varying(n) where n is the display length of the table column. | Read as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |\n| byte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |\n| C0 | Same as Cn where n is the display length of the corresponding table column | Read as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Any control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\. |\n| Cn | Written as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Any control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\. |\n| char(0) | Same as char(n) where n is the display length of the corresponding table column. | Read as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Unlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is. |\n| char(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding. Unlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Unlike C format, char does not convert control characters or tabs. File data is read as is. |\n| D0 | Instead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.) Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed. | Dummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value. Any \\ found in the input means that the next character is to be taken literally, and is not a delimiter. |\n| Dn | Dummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1. | Dummy field. N characters are read and discarded. Copy from does not allow a delimiter specification with a fixed-length dummy field. |\n| date | Written as a date. (A binary format) | Read as a date. (A binary format) |\n| decimal | Written as a decimal number. (A binary format.) | Read as a decimal number. (A binary format) |\n| float | Written as double\u2011precision floating point. (A binary format) | Read as double\u2011precision floating point. (A binary format) |\n| float4 | Written as single\u2011precision floating point. (A binary format) | Read as single\u2011precision floating point. (A binary format) |\n| integer | Written as integer of 4\u2011byte length. (A binary format) | Read as integer of 4\u2011byte length. (A binary format) |",
            "| integer1 | Written as integer of 1\u2011byte length. (A binary format) | Read as integer of 1\u2011byte length. (A binary format) |\n| long byte(0) | Identical to long varchar | Identical to long varchar |\n| long nvarchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). The maximum segment size for the long nvarchar segment is 32727 bytes. The UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment. If a delimiter is specified, it is written immediately following the last segment. | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| long varchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767. The following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long: 5 abcde10 abcdefghij 0 (with a space after the terminating 0 character) (In this example, the data that is in the originating table column is abcdeabcdefghij) | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| money | Written as a scaled floating point value (a money value). (A binary format) | Read as a scaled floating-point values (a money value). (A binary format) |\n| nchar(0) | Written as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value. | Read as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered. |\n| nvarchar(0) | Same as nchar(0) | Same as nchar(0) |\n| nchar(n) | Written as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| nvarchar(n) | Written as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding. The byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| smallint | Written as an integer of 2\u2011byte length. (A binary format.) | Read as integer of 2\u2011byte length. (A binary format) |\n| text(0) | Written as a variable length string. If a delimiter is specified, it is written after the value. If the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding. Copy into using text(0) format is the way to get variable width output with no padding. | Read as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value |\n| text(n) | Written as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding. | Reads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded. |\n| varchar(0) | Same as varchar(n), where n is the display length of the corresponding table column. | Read as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |",
            "| varchar(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length. | Read as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |",
            "Note: The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\n\nFor user-defined data types (UDTs), use char or varchar.\n\nCertainly. I'll create a single Markdown (.md) file based on the provided documentation, focusing on formatting the content without modifying it. Here's the Markdown version:\n\n### Delimiters in the Data File\n\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\n\n| Delimiter | Description |\n|-----------|-------------|\n| nl | Newline character |\n| tab | Tab character |\n| sp | Space |\n| csv | Comma separated values |\n| ssv | Semicolon separated values |\n| nul or null | Null/zero character |\n| comma | Comma |\n| colon | Colon |\n| dash | Dash |\n| lparen | Left parenthesis |\n| rparen | Right parenthesis |\n| X | Any non-numeric character |\n\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\n\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\n\n## CSV and SSV Delimiters\n\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\n\nThe rules for a CSV-delimited field are:\n\n- The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n- Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\n  ```\n  \"There is a double quote \"\" here\"\n  ```\n\n  is translated to the table value:\n\n  ```\n  There is a double quote \" here\n  ```\n\n  Whitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\n- Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\n\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\n\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \"counted\" formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)\n\nCopy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\n\n## With Null Clause for Copy\n\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\n\n### With Null (value) Clause\n\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\n\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.",
            "To prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\n\nFor example, this example of a value is incorrect:\n\n```\nc0comma with null(0)\n```\n\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\n\n```\nc0comma with null('0')\n```\n\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\n\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\n\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\n\n```sql\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\n```\n\nThe correct version specifies a 4-character format for the column.\n\n```sql\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\n```\n\n### With Null Clause Omitting Value\n\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\n\n## Filename Specification for Copy\n\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\n\nUNIX: For copy into, if the file already exists, copy overwrites it.\n\n## Windows File Types for Copy\n\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\n\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\n\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\n\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\n\nThe binary-copy forms (copy () from or copy () into) use binary mode.\n\nNote: Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.\n\nCopy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\n\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\n\n## With Clause for Copy\n\nValid with clause options for the copy statement are as follows:\n\n### On_error=TERMINATE|CONTINUE\n\nDirects copy to continue after encountering conversion errors.\n\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\n\nBy default, copy terminates when an error occurs while converting between table format and file format\n\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\n\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\n\n### Error_count=n\n\nSpecifies how many errors can occur before processing terminates.\n\nDefault: 1.\n\nIf on_error is set to continue, setting error_count has no effect.",
            "Default: 1.\n\nIf on_error is set to continue, setting error_count has no effect.\n\n### Log='filename'\n\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\n\nLogging works as follows:\n\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\n\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\n\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\n\n### Rollback=ENABLED|DISABLED\n\nEnables or disables rollback, as follows:\n\n- ENABLED: Directs the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\n- DISABLED: Retains the appended rows.\n\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\n\nDefault: ENABLED\n\nWhen copying to a file, the with rollback clause has no effect.\n\n### Row_estimate\n\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\n\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\n\n## Permissions\n\nTo use the copy statement, one of the following must apply:\n\n- You own the table.\n- The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n- You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\n\n## Locking\n\n- When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n- When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n- When performing a non-bulk copy into a table, the DBMS server takes an \"intent exclusive\" lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\n\n## Restrictions and Considerations\n\n- Copy cannot be used to add data to a view, index, or system catalog.\n- When copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\n- When copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\n- The copy statement does not fire any rules defined against the table.\n- Values cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\n- Copy treats a present-but-empty field in the data file as:\n  - A blank default for character-based columns\n  - A zero default for numeric columns\n  - December 31 00-1 for date and timestamp columns\n  - 00:00:00 for time columns (and the time component in a timestamp)",
            "For example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\n\n## Related Statements\n\n- Create Table Statement\n- Modify Statement\n\n## Examples--Copy Statement\n\nThe following examples illustrate the correct use of the copy statement:\n\n1. In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\n\n   ```\n   ename     char(15)\n   age       integer4\n   dept      char(10)\n   comment   varchar(20)\n   ```\n\n   The emp.txt file contains the following data:\n\n   ```\n   Jones,J. 32 Anytown,USA toy,00017A This is a comment\n   Smith,P. 41 New York,NY admin,00015 Another comment\n   ```\n\n   The following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\n   - A dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\n   - The department field is delimited by a comma.\n   - The comment field is a variable-length varchar field, preceded by a five-character length specifier.\n\n2. Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\n\n   ```sql\n   copy table employee (eno=integer2, ename=char(10),\n       age=integer2, job=integer2, sal=float4,\n       dept=integer2, xxx=d1)\n       from 'myfile.in';\n   ```\n\n3. Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\n\n   ```sql\n   copy table employee (ename=char(0)comma,\n       eno=char(0)comma, sal= char(0)nl)\n       into 'mfile.out';\n   ```\n\n   Joe Smith , 101, $25000.00\n   \n   Shirley Scott , 102, $30000.00\n\n4. The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\n\n   ```sql\n   copy table employee (ename = text(0)csv,\n       eno = text(0)csv, sal = text(0)csv)\n       into 'mfile.out';\n   ```\n    \n   Joe Smith,101,$25000.00\n   Shirley Scott,102,$30000.00\n\n5. Bulk copy the employee table into a file. The resulting data file contains binary data.\n\n   ```sql\n   copy table employee () into 'ourfile.dat';\n   ```\n\n6. Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\n\n   ```sql\n   copy table other_employee_table () from 'ourfile.dat';\n   ```\n\n7. Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\n\n   ```sql\n   copy table acct_recv\n       (acct_name=char(0)'%',\n       address='d0%',\n       credit=char(0)'%' with null('xx'),\n       debit=char(0)'%' with null('xx'),\n       acct_mngr=char(15),\n       xx=d0nl)\n       into 'qtr_result';\n   ```\n\n   Smith Corp%% $12345.00% $-67890.00%Jones\n   ABC Oil %% $54321.00% $-98765.00%Green\n   Spring Omc%%xx %xx %Namroc\n\n8. Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\n\n   ```sql\n   copy table gifts\n       (item_name=char(0)tab,\n       date_recd=char(0)tab,\n       sender=char(20)nl with null('anonymous'))\n       into 'giftdata';\n   ```\n\n   toaster 04-mar-1993 Nicholas\n   sled 10-oct-1993 anonymous\n   rocket 01-dec-1993 Francisco\n\n9. Create a table and load it using bulk copy, specifying structural options.\n\n   ```sql\n   create table mytable (name char 25, ...);\n   \n   modify mytable to hash;\n   \n   copy mytable() from 'myfile' with minpages = 16384,\n   maxpages = 16384, allocation = 16384;\n   ```"
        ]
    },
    {
        "instruction": "Explain how Actian 4GL SQL COPY statements handle newline indicators between operating systems.",
        "input": "",
        "output": "Actian 4GL SQL COPY statements allow the user to specify the file type parameter (T for text or B for binary) to control translation between Windows and Unix-style newline indicators, as well as control-Z translation. By default, Actian uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\nCopy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode.\nFor copy into, on UNIX systems, if the file already exists, copy overwrites it. On Windows, if the file does not exist, copy creates the file.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "# Copy Statement\n\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\n\nThis statement has the following syntax:\n\n```sql\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\n```\n\n## Parameters--Copy Statement\n\nThis statement has the following parameters:\n\n- **table_name**: Specifies an existing table from which data is read or to which data is written.\n- **column_name**: Specifies the column from which data is read or to which data is written.\n- **format**: Specifies the format in which a value is stored in the file.\n- **filename**: Specifies the file from which data is read or to which data is written.\n- **type**: (Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\n\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\n\n- **with_clause**: Consists of the word with, followed by a comma-separated list of one or more of the following items:\n  - on_error = TERMINATE | CONTINUE\n  - error_count = n\n  - rollback = ENABLED | DISABLED\n  - log = 'filename'\n\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\n- allocation = n\n- extend = n\n- fillfactor = n (ISAM, Hash, and Btree only)\n- minpages = n (Hash only)\n- maxpages = n (Hash only)\n- leaffill = n (Btree only)\n- nonleaffill = n (Btree only)\n- row_estimate = n\n\n## Unformatted Copying\n\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\n\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\n\n```sql\ncopy table employee () into 'emp_name';\n```\n\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\n\nNote: An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\n\n## Formatted Copying\n\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\n\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\n\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\n\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\n\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).",
            "The values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.\n\nNote: If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\n\n```sql\ncopy table t (col1=c20, col2=c30, d0=nl) into 't.out':\n```\n\n## Bulk Copying\n\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\n\nThe requirements for performing a bulk copy are:\n\n- The table is not journaled\n- The table has no secondary indexes\n- For storage structures other than heap, the table is empty and occupies fewer than 18 pages\n\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\n\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\n\n## Column Formats for Copy\n\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\n\nNote: When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\n\n### Character (Text) Formats\n\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\n\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\n\nThe subtle differences between the various character formats are described in Copy Format Details.\n\n### Counted Character Formats\n\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\n\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\n\nNote: Nvarchar(0) is not a counted format.\n\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\n\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\n\n### Dummy Format\n\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\n\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\n\n### Unicode Formats\n\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\n\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\n\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\n\n### Binary Formats",
            "### Binary Formats\n\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\n\nCertainly. I'll convert the provided documentation into a Markdown (.md) file format, maintaining the content while adjusting only the formatting. Here's the result:\n\n### Copy Format Details\n\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\n- Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n- When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n- The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\n\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).",
            "| Format | How Stored (copy into) | How Read (copy from) |\n|--------|------------------------|----------------------|\n| boolean | Written as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format) | Same format as copy into |\n| byte(0) | Same as byte(n) where n is the display length of the corresponding table column. | Read as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. |\n| byte(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded. |\n| byte varying(0) | Same as byte varying(n) where n is the display length of the table column. | Read as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |\n| byte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |\n| C0 | Same as Cn where n is the display length of the corresponding table column | Read as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Any control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\. |\n| Cn | Written as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Any control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\. |\n| char(0) | Same as char(n) where n is the display length of the corresponding table column. | Read as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Unlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is. |\n| char(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding. Unlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Unlike C format, char does not convert control characters or tabs. File data is read as is. |\n| D0 | Instead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.) Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed. | Dummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value. Any \\ found in the input means that the next character is to be taken literally, and is not a delimiter. |\n| Dn | Dummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1. | Dummy field. N characters are read and discarded. Copy from does not allow a delimiter specification with a fixed-length dummy field. |\n| date | Written as a date. (A binary format) | Read as a date. (A binary format) |\n| decimal | Written as a decimal number. (A binary format.) | Read as a decimal number. (A binary format) |\n| float | Written as double\u2011precision floating point. (A binary format) | Read as double\u2011precision floating point. (A binary format) |\n| float4 | Written as single\u2011precision floating point. (A binary format) | Read as single\u2011precision floating point. (A binary format) |\n| integer | Written as integer of 4\u2011byte length. (A binary format) | Read as integer of 4\u2011byte length. (A binary format) |",
            "| integer1 | Written as integer of 1\u2011byte length. (A binary format) | Read as integer of 1\u2011byte length. (A binary format) |\n| long byte(0) | Identical to long varchar | Identical to long varchar |\n| long nvarchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). The maximum segment size for the long nvarchar segment is 32727 bytes. The UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment. If a delimiter is specified, it is written immediately following the last segment. | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| long varchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767. The following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long: 5 abcde10 abcdefghij 0 (with a space after the terminating 0 character) (In this example, the data that is in the originating table column is abcdeabcdefghij) | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| money | Written as a scaled floating point value (a money value). (A binary format) | Read as a scaled floating-point values (a money value). (A binary format) |\n| nchar(0) | Written as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value. | Read as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered. |\n| nvarchar(0) | Same as nchar(0) | Same as nchar(0) |\n| nchar(n) | Written as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| nvarchar(n) | Written as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding. The byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| smallint | Written as an integer of 2\u2011byte length. (A binary format.) | Read as integer of 2\u2011byte length. (A binary format) |\n| text(0) | Written as a variable length string. If a delimiter is specified, it is written after the value. If the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding. Copy into using text(0) format is the way to get variable width output with no padding. | Read as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value |\n| text(n) | Written as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding. | Reads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded. |\n| varchar(0) | Same as varchar(n), where n is the display length of the corresponding table column. | Read as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |",
            "| varchar(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length. | Read as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |",
            "Note: The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\n\nFor user-defined data types (UDTs), use char or varchar.\n\nCertainly. I'll create a single Markdown (.md) file based on the provided documentation, focusing on formatting the content without modifying it. Here's the Markdown version:\n\n### Delimiters in the Data File\n\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\n\n| Delimiter | Description |\n|-----------|-------------|\n| nl | Newline character |\n| tab | Tab character |\n| sp | Space |\n| csv | Comma separated values |\n| ssv | Semicolon separated values |\n| nul or null | Null/zero character |\n| comma | Comma |\n| colon | Colon |\n| dash | Dash |\n| lparen | Left parenthesis |\n| rparen | Right parenthesis |\n| X | Any non-numeric character |\n\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\n\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\n\n## CSV and SSV Delimiters\n\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\n\nThe rules for a CSV-delimited field are:\n\n- The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n- Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\n  ```\n  \"There is a double quote \"\" here\"\n  ```\n\n  is translated to the table value:\n\n  ```\n  There is a double quote \" here\n  ```\n\n  Whitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\n- Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\n\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\n\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \"counted\" formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)\n\nCopy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\n\n## With Null Clause for Copy\n\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\n\n### With Null (value) Clause\n\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\n\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.",
            "To prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\n\nFor example, this example of a value is incorrect:\n\n```\nc0comma with null(0)\n```\n\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\n\n```\nc0comma with null('0')\n```\n\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\n\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\n\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\n\n```sql\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\n```\n\nThe correct version specifies a 4-character format for the column.\n\n```sql\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\n```\n\n### With Null Clause Omitting Value\n\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\n\n## Filename Specification for Copy\n\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\n\nUNIX: For copy into, if the file already exists, copy overwrites it.\n\n## Windows File Types for Copy\n\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\n\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\n\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\n\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\n\nThe binary-copy forms (copy () from or copy () into) use binary mode.\n\nNote: Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.\n\nCopy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\n\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\n\n## With Clause for Copy\n\nValid with clause options for the copy statement are as follows:\n\n### On_error=TERMINATE|CONTINUE\n\nDirects copy to continue after encountering conversion errors.\n\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\n\nBy default, copy terminates when an error occurs while converting between table format and file format\n\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\n\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\n\n### Error_count=n\n\nSpecifies how many errors can occur before processing terminates.\n\nDefault: 1.\n\nIf on_error is set to continue, setting error_count has no effect.",
            "Default: 1.\n\nIf on_error is set to continue, setting error_count has no effect.\n\n### Log='filename'\n\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\n\nLogging works as follows:\n\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\n\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\n\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\n\n### Rollback=ENABLED|DISABLED\n\nEnables or disables rollback, as follows:\n\n- ENABLED: Directs the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\n- DISABLED: Retains the appended rows.\n\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\n\nDefault: ENABLED\n\nWhen copying to a file, the with rollback clause has no effect.\n\n### Row_estimate\n\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\n\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\n\n## Permissions\n\nTo use the copy statement, one of the following must apply:\n\n- You own the table.\n- The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n- You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\n\n## Locking\n\n- When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n- When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n- When performing a non-bulk copy into a table, the DBMS server takes an \"intent exclusive\" lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\n\n## Restrictions and Considerations\n\n- Copy cannot be used to add data to a view, index, or system catalog.\n- When copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\n- When copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\n- The copy statement does not fire any rules defined against the table.\n- Values cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\n- Copy treats a present-but-empty field in the data file as:\n  - A blank default for character-based columns\n  - A zero default for numeric columns\n  - December 31 00-1 for date and timestamp columns\n  - 00:00:00 for time columns (and the time component in a timestamp)",
            "For example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\n\n## Related Statements\n\n- Create Table Statement\n- Modify Statement\n\n## Examples--Copy Statement\n\nThe following examples illustrate the correct use of the copy statement:\n\n1. In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\n\n   ```\n   ename     char(15)\n   age       integer4\n   dept      char(10)\n   comment   varchar(20)\n   ```\n\n   The emp.txt file contains the following data:\n\n   ```\n   Jones,J. 32 Anytown,USA toy,00017A This is a comment\n   Smith,P. 41 New York,NY admin,00015 Another comment\n   ```\n\n   The following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\n   - A dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\n   - The department field is delimited by a comma.\n   - The comment field is a variable-length varchar field, preceded by a five-character length specifier.\n\n2. Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\n\n   ```sql\n   copy table employee (eno=integer2, ename=char(10),\n       age=integer2, job=integer2, sal=float4,\n       dept=integer2, xxx=d1)\n       from 'myfile.in';\n   ```\n\n3. Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\n\n   ```sql\n   copy table employee (ename=char(0)comma,\n       eno=char(0)comma, sal= char(0)nl)\n       into 'mfile.out';\n   ```\n\n   Joe Smith , 101, $25000.00\n   \n   Shirley Scott , 102, $30000.00\n\n4. The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\n\n   ```sql\n   copy table employee (ename = text(0)csv,\n       eno = text(0)csv, sal = text(0)csv)\n       into 'mfile.out';\n   ```\n    \n   Joe Smith,101,$25000.00\n   Shirley Scott,102,$30000.00\n\n5. Bulk copy the employee table into a file. The resulting data file contains binary data.\n\n   ```sql\n   copy table employee () into 'ourfile.dat';\n   ```\n\n6. Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\n\n   ```sql\n   copy table other_employee_table () from 'ourfile.dat';\n   ```\n\n7. Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\n\n   ```sql\n   copy table acct_recv\n       (acct_name=char(0)'%',\n       address='d0%',\n       credit=char(0)'%' with null('xx'),\n       debit=char(0)'%' with null('xx'),\n       acct_mngr=char(15),\n       xx=d0nl)\n       into 'qtr_result';\n   ```\n\n   Smith Corp%% $12345.00% $-67890.00%Jones\n   ABC Oil %% $54321.00% $-98765.00%Green\n   Spring Omc%%xx %xx %Namroc\n\n8. Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\n\n   ```sql\n   copy table gifts\n       (item_name=char(0)tab,\n       date_recd=char(0)tab,\n       sender=char(20)nl with null('anonymous'))\n       into 'giftdata';\n   ```\n\n   toaster 04-mar-1993 Nicholas\n   sled 10-oct-1993 anonymous\n   rocket 01-dec-1993 Francisco\n\n9. Create a table and load it using bulk copy, specifying structural options.\n\n   ```sql\n   create table mytable (name char 25, ...);\n   \n   modify mytable to hash;\n   \n   copy mytable() from 'myfile' with minpages = 16384,\n   maxpages = 16384, allocation = 16384;\n   ```"
        ]
    },
    {
        "instruction": "Explain how delimiters work in Actian 4GL SQL COPY statements and provide an example where they can be used.",
        "input": "",
        "output": "Delimiters are used to separate fields within a row during data import or export using the Actian 4GL SQL COPY statement. By specifying the delimiter, such as comma, semicolon, or tab, in the format clause of the COPY statement, you can ensure that data is loaded into the correct columns even if they don't match the physical column order or have different names than the data file fields.\nFor example, consider a CSV (Comma-Separated Values) file with data for a table called employees:\n\n```\nName,Age,Salary,Department\nJohn Doe,34,$80,Engineering\nJane Smith,27,$50,Sales\n```\nTo load this data into the employees table using COPY, you would use something like:\n\n```sql\ncopy table employees (name=char(10)comma, age=integer4comma, salary=float4comma, department=char(15)) from 'employees.csv';\n```\nIn this example, the comma delimiter is used to separate the fields in each row of the CSV file and load them into their respective columns in the employees table.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "# Copy Statement\n\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\n\nThis statement has the following syntax:\n\n```sql\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\n```\n\n## Parameters--Copy Statement\n\nThis statement has the following parameters:\n\n- **table_name**: Specifies an existing table from which data is read or to which data is written.\n- **column_name**: Specifies the column from which data is read or to which data is written.\n- **format**: Specifies the format in which a value is stored in the file.\n- **filename**: Specifies the file from which data is read or to which data is written.\n- **type**: (Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\n\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\n\n- **with_clause**: Consists of the word with, followed by a comma-separated list of one or more of the following items:\n  - on_error = TERMINATE | CONTINUE\n  - error_count = n\n  - rollback = ENABLED | DISABLED\n  - log = 'filename'\n\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\n- allocation = n\n- extend = n\n- fillfactor = n (ISAM, Hash, and Btree only)\n- minpages = n (Hash only)\n- maxpages = n (Hash only)\n- leaffill = n (Btree only)\n- nonleaffill = n (Btree only)\n- row_estimate = n\n\n## Unformatted Copying\n\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\n\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\n\n```sql\ncopy table employee () into 'emp_name';\n```\n\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\n\nNote: An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\n\n## Formatted Copying\n\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\n\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\n\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\n\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\n\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).",
            "The values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.\n\nNote: If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\n\n```sql\ncopy table t (col1=c20, col2=c30, d0=nl) into 't.out':\n```\n\n## Bulk Copying\n\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\n\nThe requirements for performing a bulk copy are:\n\n- The table is not journaled\n- The table has no secondary indexes\n- For storage structures other than heap, the table is empty and occupies fewer than 18 pages\n\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\n\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\n\n## Column Formats for Copy\n\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\n\nNote: When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\n\n### Character (Text) Formats\n\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\n\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\n\nThe subtle differences between the various character formats are described in Copy Format Details.\n\n### Counted Character Formats\n\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\n\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\n\nNote: Nvarchar(0) is not a counted format.\n\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\n\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\n\n### Dummy Format\n\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\n\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\n\n### Unicode Formats\n\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\n\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\n\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\n\n### Binary Formats",
            "### Binary Formats\n\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\n\nCertainly. I'll convert the provided documentation into a Markdown (.md) file format, maintaining the content while adjusting only the formatting. Here's the result:\n\n### Copy Format Details\n\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\n- Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n- When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n- The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\n\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).",
            "| Format | How Stored (copy into) | How Read (copy from) |\n|--------|------------------------|----------------------|\n| boolean | Written as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format) | Same format as copy into |\n| byte(0) | Same as byte(n) where n is the display length of the corresponding table column. | Read as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. |\n| byte(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded. |\n| byte varying(0) | Same as byte varying(n) where n is the display length of the table column. | Read as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |\n| byte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |\n| C0 | Same as Cn where n is the display length of the corresponding table column | Read as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Any control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\. |\n| Cn | Written as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Any control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\. |\n| char(0) | Same as char(n) where n is the display length of the corresponding table column. | Read as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Unlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is. |\n| char(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding. Unlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Unlike C format, char does not convert control characters or tabs. File data is read as is. |\n| D0 | Instead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.) Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed. | Dummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value. Any \\ found in the input means that the next character is to be taken literally, and is not a delimiter. |\n| Dn | Dummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1. | Dummy field. N characters are read and discarded. Copy from does not allow a delimiter specification with a fixed-length dummy field. |\n| date | Written as a date. (A binary format) | Read as a date. (A binary format) |\n| decimal | Written as a decimal number. (A binary format.) | Read as a decimal number. (A binary format) |\n| float | Written as double\u2011precision floating point. (A binary format) | Read as double\u2011precision floating point. (A binary format) |\n| float4 | Written as single\u2011precision floating point. (A binary format) | Read as single\u2011precision floating point. (A binary format) |\n| integer | Written as integer of 4\u2011byte length. (A binary format) | Read as integer of 4\u2011byte length. (A binary format) |",
            "| integer1 | Written as integer of 1\u2011byte length. (A binary format) | Read as integer of 1\u2011byte length. (A binary format) |\n| long byte(0) | Identical to long varchar | Identical to long varchar |\n| long nvarchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). The maximum segment size for the long nvarchar segment is 32727 bytes. The UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment. If a delimiter is specified, it is written immediately following the last segment. | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| long varchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767. The following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long: 5 abcde10 abcdefghij 0 (with a space after the terminating 0 character) (In this example, the data that is in the originating table column is abcdeabcdefghij) | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| money | Written as a scaled floating point value (a money value). (A binary format) | Read as a scaled floating-point values (a money value). (A binary format) |\n| nchar(0) | Written as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value. | Read as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered. |\n| nvarchar(0) | Same as nchar(0) | Same as nchar(0) |\n| nchar(n) | Written as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| nvarchar(n) | Written as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding. The byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| smallint | Written as an integer of 2\u2011byte length. (A binary format.) | Read as integer of 2\u2011byte length. (A binary format) |\n| text(0) | Written as a variable length string. If a delimiter is specified, it is written after the value. If the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding. Copy into using text(0) format is the way to get variable width output with no padding. | Read as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value |\n| text(n) | Written as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding. | Reads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded. |\n| varchar(0) | Same as varchar(n), where n is the display length of the corresponding table column. | Read as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |",
            "| varchar(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length. | Read as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |",
            "Note: The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\n\nFor user-defined data types (UDTs), use char or varchar.\n\nCertainly. I'll create a single Markdown (.md) file based on the provided documentation, focusing on formatting the content without modifying it. Here's the Markdown version:\n\n### Delimiters in the Data File\n\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\n\n| Delimiter | Description |\n|-----------|-------------|\n| nl | Newline character |\n| tab | Tab character |\n| sp | Space |\n| csv | Comma separated values |\n| ssv | Semicolon separated values |\n| nul or null | Null/zero character |\n| comma | Comma |\n| colon | Colon |\n| dash | Dash |\n| lparen | Left parenthesis |\n| rparen | Right parenthesis |\n| X | Any non-numeric character |\n\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\n\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\n\n## CSV and SSV Delimiters\n\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\n\nThe rules for a CSV-delimited field are:\n\n- The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n- Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\n  ```\n  \"There is a double quote \"\" here\"\n  ```\n\n  is translated to the table value:\n\n  ```\n  There is a double quote \" here\n  ```\n\n  Whitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\n- Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\n\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\n\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \"counted\" formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)\n\nCopy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\n\n## With Null Clause for Copy\n\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\n\n### With Null (value) Clause\n\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\n\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.",
            "To prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\n\nFor example, this example of a value is incorrect:\n\n```\nc0comma with null(0)\n```\n\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\n\n```\nc0comma with null('0')\n```\n\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\n\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\n\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\n\n```sql\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\n```\n\nThe correct version specifies a 4-character format for the column.\n\n```sql\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\n```\n\n### With Null Clause Omitting Value\n\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\n\n## Filename Specification for Copy\n\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\n\nUNIX: For copy into, if the file already exists, copy overwrites it.\n\n## Windows File Types for Copy\n\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\n\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\n\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\n\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\n\nThe binary-copy forms (copy () from or copy () into) use binary mode.\n\nNote: Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.\n\nCopy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\n\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\n\n## With Clause for Copy\n\nValid with clause options for the copy statement are as follows:\n\n### On_error=TERMINATE|CONTINUE\n\nDirects copy to continue after encountering conversion errors.\n\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\n\nBy default, copy terminates when an error occurs while converting between table format and file format\n\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\n\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\n\n### Error_count=n\n\nSpecifies how many errors can occur before processing terminates.\n\nDefault: 1.\n\nIf on_error is set to continue, setting error_count has no effect.",
            "Default: 1.\n\nIf on_error is set to continue, setting error_count has no effect.\n\n### Log='filename'\n\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\n\nLogging works as follows:\n\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\n\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\n\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\n\n### Rollback=ENABLED|DISABLED\n\nEnables or disables rollback, as follows:\n\n- ENABLED: Directs the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\n- DISABLED: Retains the appended rows.\n\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\n\nDefault: ENABLED\n\nWhen copying to a file, the with rollback clause has no effect.\n\n### Row_estimate\n\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\n\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\n\n## Permissions\n\nTo use the copy statement, one of the following must apply:\n\n- You own the table.\n- The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n- You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\n\n## Locking\n\n- When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n- When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n- When performing a non-bulk copy into a table, the DBMS server takes an \"intent exclusive\" lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\n\n## Restrictions and Considerations\n\n- Copy cannot be used to add data to a view, index, or system catalog.\n- When copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\n- When copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\n- The copy statement does not fire any rules defined against the table.\n- Values cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\n- Copy treats a present-but-empty field in the data file as:\n  - A blank default for character-based columns\n  - A zero default for numeric columns\n  - December 31 00-1 for date and timestamp columns\n  - 00:00:00 for time columns (and the time component in a timestamp)",
            "For example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\n\n## Related Statements\n\n- Create Table Statement\n- Modify Statement\n\n## Examples--Copy Statement\n\nThe following examples illustrate the correct use of the copy statement:\n\n1. In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\n\n   ```\n   ename     char(15)\n   age       integer4\n   dept      char(10)\n   comment   varchar(20)\n   ```\n\n   The emp.txt file contains the following data:\n\n   ```\n   Jones,J. 32 Anytown,USA toy,00017A This is a comment\n   Smith,P. 41 New York,NY admin,00015 Another comment\n   ```\n\n   The following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\n   - A dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\n   - The department field is delimited by a comma.\n   - The comment field is a variable-length varchar field, preceded by a five-character length specifier.\n\n2. Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\n\n   ```sql\n   copy table employee (eno=integer2, ename=char(10),\n       age=integer2, job=integer2, sal=float4,\n       dept=integer2, xxx=d1)\n       from 'myfile.in';\n   ```\n\n3. Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\n\n   ```sql\n   copy table employee (ename=char(0)comma,\n       eno=char(0)comma, sal= char(0)nl)\n       into 'mfile.out';\n   ```\n\n   Joe Smith , 101, $25000.00\n   \n   Shirley Scott , 102, $30000.00\n\n4. The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\n\n   ```sql\n   copy table employee (ename = text(0)csv,\n       eno = text(0)csv, sal = text(0)csv)\n       into 'mfile.out';\n   ```\n    \n   Joe Smith,101,$25000.00\n   Shirley Scott,102,$30000.00\n\n5. Bulk copy the employee table into a file. The resulting data file contains binary data.\n\n   ```sql\n   copy table employee () into 'ourfile.dat';\n   ```\n\n6. Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\n\n   ```sql\n   copy table other_employee_table () from 'ourfile.dat';\n   ```\n\n7. Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\n\n   ```sql\n   copy table acct_recv\n       (acct_name=char(0)'%',\n       address='d0%',\n       credit=char(0)'%' with null('xx'),\n       debit=char(0)'%' with null('xx'),\n       acct_mngr=char(15),\n       xx=d0nl)\n       into 'qtr_result';\n   ```\n\n   Smith Corp%% $12345.00% $-67890.00%Jones\n   ABC Oil %% $54321.00% $-98765.00%Green\n   Spring Omc%%xx %xx %Namroc\n\n8. Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\n\n   ```sql\n   copy table gifts\n       (item_name=char(0)tab,\n       date_recd=char(0)tab,\n       sender=char(20)nl with null('anonymous'))\n       into 'giftdata';\n   ```\n\n   toaster 04-mar-1993 Nicholas\n   sled 10-oct-1993 anonymous\n   rocket 01-dec-1993 Francisco\n\n9. Create a table and load it using bulk copy, specifying structural options.\n\n   ```sql\n   create table mytable (name char 25, ...);\n   \n   modify mytable to hash;\n   \n   copy mytable() from 'myfile' with minpages = 16384,\n   maxpages = 16384, allocation = 16384;\n   ```"
        ]
    },
    {
        "instruction": "List some advanced options available in Actian 4GL SQL COPY statements that are not typically used but can be useful for specific situations.",
        "input": "",
        "output": "Here are some advanced options available in Actian 4GL SQL COPY statements that can be used for special or specific cases:\n1. `on_error = TERMINATE` or `CONTINUE`: This option determines what happens when an error is encountered during the copy process. By default, `TERMINATE` will stop the entire operation if an error occurs; however, `CONTINUE` allows the process to continue even after an error is detected.\n2. `error_count = n`: This option specifies the maximum number of errors allowed before the operation is terminated. If an error count exceeds this value, the entire operation will be stopped.\n3. `rollback = ENABLED | DISABLED`: This option determines whether the data in the table being copied from will be rolled back if an error occurs during the copy process. By default, rolling back is enabled to protect existing data. However, setting it to `DISABLED` can help speed up the copy operation when dealing with large datasets.\n4. `allocation = n`, `extend = n`, `fillfactor = n`, `minpages = n`, and `maxpages = n`: These options are used for managing storage requirements during the copy process. They allow you to specify the number of pages required to store data, the fill factor (percentage of a page that needs to be filled before a new page is allocated), minimum and maximum pages allowed in hashed tables, and the leaf and non-leaf fill factors in Btree tables.\n5. `leaffill = n` and `nonleaffill = n`: These options control how much space is allocated for leaf and non-leaf nodes in a Btree table during the copy process. Setting these values appropriately can improve query performance on the resulting table.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "# Copy Statement\n\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\n\nThis statement has the following syntax:\n\n```sql\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\n```\n\n## Parameters--Copy Statement\n\nThis statement has the following parameters:\n\n- **table_name**: Specifies an existing table from which data is read or to which data is written.\n- **column_name**: Specifies the column from which data is read or to which data is written.\n- **format**: Specifies the format in which a value is stored in the file.\n- **filename**: Specifies the file from which data is read or to which data is written.\n- **type**: (Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\n\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\n\n- **with_clause**: Consists of the word with, followed by a comma-separated list of one or more of the following items:\n  - on_error = TERMINATE | CONTINUE\n  - error_count = n\n  - rollback = ENABLED | DISABLED\n  - log = 'filename'\n\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\n- allocation = n\n- extend = n\n- fillfactor = n (ISAM, Hash, and Btree only)\n- minpages = n (Hash only)\n- maxpages = n (Hash only)\n- leaffill = n (Btree only)\n- nonleaffill = n (Btree only)\n- row_estimate = n\n\n## Unformatted Copying\n\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\n\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\n\n```sql\ncopy table employee () into 'emp_name';\n```\n\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\n\nNote: An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\n\n## Formatted Copying\n\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\n\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\n\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\n\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\n\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).",
            "The values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.\n\nNote: If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\n\n```sql\ncopy table t (col1=c20, col2=c30, d0=nl) into 't.out':\n```\n\n## Bulk Copying\n\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\n\nThe requirements for performing a bulk copy are:\n\n- The table is not journaled\n- The table has no secondary indexes\n- For storage structures other than heap, the table is empty and occupies fewer than 18 pages\n\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\n\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\n\n## Column Formats for Copy\n\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\n\nNote: When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\n\n### Character (Text) Formats\n\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\n\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\n\nThe subtle differences between the various character formats are described in Copy Format Details.\n\n### Counted Character Formats\n\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\n\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\n\nNote: Nvarchar(0) is not a counted format.\n\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\n\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\n\n### Dummy Format\n\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\n\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\n\n### Unicode Formats\n\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\n\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\n\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\n\n### Binary Formats",
            "### Binary Formats\n\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\n\nCertainly. I'll convert the provided documentation into a Markdown (.md) file format, maintaining the content while adjusting only the formatting. Here's the result:\n\n### Copy Format Details\n\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\n- Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n- When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n- The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\n\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).",
            "| Format | How Stored (copy into) | How Read (copy from) |\n|--------|------------------------|----------------------|\n| boolean | Written as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format) | Same format as copy into |\n| byte(0) | Same as byte(n) where n is the display length of the corresponding table column. | Read as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. |\n| byte(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded. |\n| byte varying(0) | Same as byte varying(n) where n is the display length of the table column. | Read as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |\n| byte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |\n| C0 | Same as Cn where n is the display length of the corresponding table column | Read as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Any control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\. |\n| Cn | Written as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Any control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\. |\n| char(0) | Same as char(n) where n is the display length of the corresponding table column. | Read as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Unlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is. |\n| char(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding. Unlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Unlike C format, char does not convert control characters or tabs. File data is read as is. |\n| D0 | Instead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.) Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed. | Dummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value. Any \\ found in the input means that the next character is to be taken literally, and is not a delimiter. |\n| Dn | Dummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1. | Dummy field. N characters are read and discarded. Copy from does not allow a delimiter specification with a fixed-length dummy field. |\n| date | Written as a date. (A binary format) | Read as a date. (A binary format) |\n| decimal | Written as a decimal number. (A binary format.) | Read as a decimal number. (A binary format) |\n| float | Written as double\u2011precision floating point. (A binary format) | Read as double\u2011precision floating point. (A binary format) |\n| float4 | Written as single\u2011precision floating point. (A binary format) | Read as single\u2011precision floating point. (A binary format) |\n| integer | Written as integer of 4\u2011byte length. (A binary format) | Read as integer of 4\u2011byte length. (A binary format) |",
            "| integer1 | Written as integer of 1\u2011byte length. (A binary format) | Read as integer of 1\u2011byte length. (A binary format) |\n| long byte(0) | Identical to long varchar | Identical to long varchar |\n| long nvarchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). The maximum segment size for the long nvarchar segment is 32727 bytes. The UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment. If a delimiter is specified, it is written immediately following the last segment. | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| long varchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767. The following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long: 5 abcde10 abcdefghij 0 (with a space after the terminating 0 character) (In this example, the data that is in the originating table column is abcdeabcdefghij) | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| money | Written as a scaled floating point value (a money value). (A binary format) | Read as a scaled floating-point values (a money value). (A binary format) |\n| nchar(0) | Written as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value. | Read as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered. |\n| nvarchar(0) | Same as nchar(0) | Same as nchar(0) |\n| nchar(n) | Written as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| nvarchar(n) | Written as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding. The byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| smallint | Written as an integer of 2\u2011byte length. (A binary format.) | Read as integer of 2\u2011byte length. (A binary format) |\n| text(0) | Written as a variable length string. If a delimiter is specified, it is written after the value. If the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding. Copy into using text(0) format is the way to get variable width output with no padding. | Read as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value |\n| text(n) | Written as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding. | Reads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded. |\n| varchar(0) | Same as varchar(n), where n is the display length of the corresponding table column. | Read as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |",
            "| varchar(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length. | Read as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |",
            "Note: The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\n\nFor user-defined data types (UDTs), use char or varchar.\n\nCertainly. I'll create a single Markdown (.md) file based on the provided documentation, focusing on formatting the content without modifying it. Here's the Markdown version:\n\n### Delimiters in the Data File\n\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\n\n| Delimiter | Description |\n|-----------|-------------|\n| nl | Newline character |\n| tab | Tab character |\n| sp | Space |\n| csv | Comma separated values |\n| ssv | Semicolon separated values |\n| nul or null | Null/zero character |\n| comma | Comma |\n| colon | Colon |\n| dash | Dash |\n| lparen | Left parenthesis |\n| rparen | Right parenthesis |\n| X | Any non-numeric character |\n\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\n\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\n\n## CSV and SSV Delimiters\n\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\n\nThe rules for a CSV-delimited field are:\n\n- The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n- Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\n  ```\n  \"There is a double quote \"\" here\"\n  ```\n\n  is translated to the table value:\n\n  ```\n  There is a double quote \" here\n  ```\n\n  Whitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\n- Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\n\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\n\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \"counted\" formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)\n\nCopy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\n\n## With Null Clause for Copy\n\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\n\n### With Null (value) Clause\n\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\n\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.",
            "To prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\n\nFor example, this example of a value is incorrect:\n\n```\nc0comma with null(0)\n```\n\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\n\n```\nc0comma with null('0')\n```\n\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\n\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\n\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\n\n```sql\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\n```\n\nThe correct version specifies a 4-character format for the column.\n\n```sql\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\n```\n\n### With Null Clause Omitting Value\n\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\n\n## Filename Specification for Copy\n\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\n\nUNIX: For copy into, if the file already exists, copy overwrites it.\n\n## Windows File Types for Copy\n\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\n\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\n\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\n\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\n\nThe binary-copy forms (copy () from or copy () into) use binary mode.\n\nNote: Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.\n\nCopy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\n\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\n\n## With Clause for Copy\n\nValid with clause options for the copy statement are as follows:\n\n### On_error=TERMINATE|CONTINUE\n\nDirects copy to continue after encountering conversion errors.\n\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\n\nBy default, copy terminates when an error occurs while converting between table format and file format\n\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\n\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\n\n### Error_count=n\n\nSpecifies how many errors can occur before processing terminates.\n\nDefault: 1.\n\nIf on_error is set to continue, setting error_count has no effect.",
            "Default: 1.\n\nIf on_error is set to continue, setting error_count has no effect.\n\n### Log='filename'\n\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\n\nLogging works as follows:\n\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\n\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\n\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\n\n### Rollback=ENABLED|DISABLED\n\nEnables or disables rollback, as follows:\n\n- ENABLED: Directs the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\n- DISABLED: Retains the appended rows.\n\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\n\nDefault: ENABLED\n\nWhen copying to a file, the with rollback clause has no effect.\n\n### Row_estimate\n\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\n\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\n\n## Permissions\n\nTo use the copy statement, one of the following must apply:\n\n- You own the table.\n- The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n- You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\n\n## Locking\n\n- When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n- When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n- When performing a non-bulk copy into a table, the DBMS server takes an \"intent exclusive\" lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\n\n## Restrictions and Considerations\n\n- Copy cannot be used to add data to a view, index, or system catalog.\n- When copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\n- When copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\n- The copy statement does not fire any rules defined against the table.\n- Values cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\n- Copy treats a present-but-empty field in the data file as:\n  - A blank default for character-based columns\n  - A zero default for numeric columns\n  - December 31 00-1 for date and timestamp columns\n  - 00:00:00 for time columns (and the time component in a timestamp)",
            "For example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\n\n## Related Statements\n\n- Create Table Statement\n- Modify Statement\n\n## Examples--Copy Statement\n\nThe following examples illustrate the correct use of the copy statement:\n\n1. In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\n\n   ```\n   ename     char(15)\n   age       integer4\n   dept      char(10)\n   comment   varchar(20)\n   ```\n\n   The emp.txt file contains the following data:\n\n   ```\n   Jones,J. 32 Anytown,USA toy,00017A This is a comment\n   Smith,P. 41 New York,NY admin,00015 Another comment\n   ```\n\n   The following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\n   - A dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\n   - The department field is delimited by a comma.\n   - The comment field is a variable-length varchar field, preceded by a five-character length specifier.\n\n2. Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\n\n   ```sql\n   copy table employee (eno=integer2, ename=char(10),\n       age=integer2, job=integer2, sal=float4,\n       dept=integer2, xxx=d1)\n       from 'myfile.in';\n   ```\n\n3. Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\n\n   ```sql\n   copy table employee (ename=char(0)comma,\n       eno=char(0)comma, sal= char(0)nl)\n       into 'mfile.out';\n   ```\n\n   Joe Smith , 101, $25000.00\n   \n   Shirley Scott , 102, $30000.00\n\n4. The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\n\n   ```sql\n   copy table employee (ename = text(0)csv,\n       eno = text(0)csv, sal = text(0)csv)\n       into 'mfile.out';\n   ```\n    \n   Joe Smith,101,$25000.00\n   Shirley Scott,102,$30000.00\n\n5. Bulk copy the employee table into a file. The resulting data file contains binary data.\n\n   ```sql\n   copy table employee () into 'ourfile.dat';\n   ```\n\n6. Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\n\n   ```sql\n   copy table other_employee_table () from 'ourfile.dat';\n   ```\n\n7. Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\n\n   ```sql\n   copy table acct_recv\n       (acct_name=char(0)'%',\n       address='d0%',\n       credit=char(0)'%' with null('xx'),\n       debit=char(0)'%' with null('xx'),\n       acct_mngr=char(15),\n       xx=d0nl)\n       into 'qtr_result';\n   ```\n\n   Smith Corp%% $12345.00% $-67890.00%Jones\n   ABC Oil %% $54321.00% $-98765.00%Green\n   Spring Omc%%xx %xx %Namroc\n\n8. Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\n\n   ```sql\n   copy table gifts\n       (item_name=char(0)tab,\n       date_recd=char(0)tab,\n       sender=char(20)nl with null('anonymous'))\n       into 'giftdata';\n   ```\n\n   toaster 04-mar-1993 Nicholas\n   sled 10-oct-1993 anonymous\n   rocket 01-dec-1993 Francisco\n\n9. Create a table and load it using bulk copy, specifying structural options.\n\n   ```sql\n   create table mytable (name char 25, ...);\n   \n   modify mytable to hash;\n   \n   copy mytable() from 'myfile' with minpages = 16384,\n   maxpages = 16384, allocation = 16384;\n   ```"
        ]
    },
    {
        "instruction": "How does Actian 4GL handle null values in its SQL COPY statements and how can you specify them?",
        "input": "",
        "output": "Actian 4GL handles null values in SQL COPY statements using the `NULL` keyword, which signifies an empty or unknown value. To include a null value during data import or export using the COPY statement, simply use the `NULL` keyword where you would typically place a value. If no delimiter is specified, a single NULL character (0x00) will be used. For example:\n\n```sql\ncopy table employees (name=char(10), age=integer4, salary=float4, department=char(15)) from 'employees.csv' delimiters=comma null='NULL';\n```\nIn this case, the NULL keyword is specified to handle null values during data import or export and replace them with the string `NULL`.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "# Copy Statement\n\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\n\nThis statement has the following syntax:\n\n```sql\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\n```\n\n## Parameters--Copy Statement\n\nThis statement has the following parameters:\n\n- **table_name**: Specifies an existing table from which data is read or to which data is written.\n- **column_name**: Specifies the column from which data is read or to which data is written.\n- **format**: Specifies the format in which a value is stored in the file.\n- **filename**: Specifies the file from which data is read or to which data is written.\n- **type**: (Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\n\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\n\n- **with_clause**: Consists of the word with, followed by a comma-separated list of one or more of the following items:\n  - on_error = TERMINATE | CONTINUE\n  - error_count = n\n  - rollback = ENABLED | DISABLED\n  - log = 'filename'\n\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\n- allocation = n\n- extend = n\n- fillfactor = n (ISAM, Hash, and Btree only)\n- minpages = n (Hash only)\n- maxpages = n (Hash only)\n- leaffill = n (Btree only)\n- nonleaffill = n (Btree only)\n- row_estimate = n\n\n## Unformatted Copying\n\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\n\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\n\n```sql\ncopy table employee () into 'emp_name';\n```\n\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\n\nNote: An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\n\n## Formatted Copying\n\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\n\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\n\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\n\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\n\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).",
            "The values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.\n\nNote: If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\n\n```sql\ncopy table t (col1=c20, col2=c30, d0=nl) into 't.out':\n```\n\n## Bulk Copying\n\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\n\nThe requirements for performing a bulk copy are:\n\n- The table is not journaled\n- The table has no secondary indexes\n- For storage structures other than heap, the table is empty and occupies fewer than 18 pages\n\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\n\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\n\n## Column Formats for Copy\n\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\n\nNote: When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\n\n### Character (Text) Formats\n\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\n\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\n\nThe subtle differences between the various character formats are described in Copy Format Details.\n\n### Counted Character Formats\n\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\n\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\n\nNote: Nvarchar(0) is not a counted format.\n\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\n\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\n\n### Dummy Format\n\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\n\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\n\n### Unicode Formats\n\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\n\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\n\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\n\n### Binary Formats",
            "### Binary Formats\n\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\n\nCertainly. I'll convert the provided documentation into a Markdown (.md) file format, maintaining the content while adjusting only the formatting. Here's the result:\n\n### Copy Format Details\n\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\n- Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n- When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n- The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\n\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).",
            "| Format | How Stored (copy into) | How Read (copy from) |\n|--------|------------------------|----------------------|\n| boolean | Written as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format) | Same format as copy into |\n| byte(0) | Same as byte(n) where n is the display length of the corresponding table column. | Read as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. |\n| byte(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded. |\n| byte varying(0) | Same as byte varying(n) where n is the display length of the table column. | Read as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |\n| byte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |\n| C0 | Same as Cn where n is the display length of the corresponding table column | Read as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Any control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\. |\n| Cn | Written as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Any control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\. |\n| char(0) | Same as char(n) where n is the display length of the corresponding table column. | Read as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Unlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is. |\n| char(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding. Unlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Unlike C format, char does not convert control characters or tabs. File data is read as is. |\n| D0 | Instead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.) Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed. | Dummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value. Any \\ found in the input means that the next character is to be taken literally, and is not a delimiter. |\n| Dn | Dummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1. | Dummy field. N characters are read and discarded. Copy from does not allow a delimiter specification with a fixed-length dummy field. |\n| date | Written as a date. (A binary format) | Read as a date. (A binary format) |\n| decimal | Written as a decimal number. (A binary format.) | Read as a decimal number. (A binary format) |\n| float | Written as double\u2011precision floating point. (A binary format) | Read as double\u2011precision floating point. (A binary format) |\n| float4 | Written as single\u2011precision floating point. (A binary format) | Read as single\u2011precision floating point. (A binary format) |\n| integer | Written as integer of 4\u2011byte length. (A binary format) | Read as integer of 4\u2011byte length. (A binary format) |",
            "| integer1 | Written as integer of 1\u2011byte length. (A binary format) | Read as integer of 1\u2011byte length. (A binary format) |\n| long byte(0) | Identical to long varchar | Identical to long varchar |\n| long nvarchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). The maximum segment size for the long nvarchar segment is 32727 bytes. The UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment. If a delimiter is specified, it is written immediately following the last segment. | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| long varchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767. The following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long: 5 abcde10 abcdefghij 0 (with a space after the terminating 0 character) (In this example, the data that is in the originating table column is abcdeabcdefghij) | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| money | Written as a scaled floating point value (a money value). (A binary format) | Read as a scaled floating-point values (a money value). (A binary format) |\n| nchar(0) | Written as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value. | Read as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered. |\n| nvarchar(0) | Same as nchar(0) | Same as nchar(0) |\n| nchar(n) | Written as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| nvarchar(n) | Written as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding. The byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| smallint | Written as an integer of 2\u2011byte length. (A binary format.) | Read as integer of 2\u2011byte length. (A binary format) |\n| text(0) | Written as a variable length string. If a delimiter is specified, it is written after the value. If the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding. Copy into using text(0) format is the way to get variable width output with no padding. | Read as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value |\n| text(n) | Written as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding. | Reads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded. |\n| varchar(0) | Same as varchar(n), where n is the display length of the corresponding table column. | Read as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |",
            "| varchar(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length. | Read as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |",
            "Note: The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\n\nFor user-defined data types (UDTs), use char or varchar.\n\nCertainly. I'll create a single Markdown (.md) file based on the provided documentation, focusing on formatting the content without modifying it. Here's the Markdown version:\n\n### Delimiters in the Data File\n\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\n\n| Delimiter | Description |\n|-----------|-------------|\n| nl | Newline character |\n| tab | Tab character |\n| sp | Space |\n| csv | Comma separated values |\n| ssv | Semicolon separated values |\n| nul or null | Null/zero character |\n| comma | Comma |\n| colon | Colon |\n| dash | Dash |\n| lparen | Left parenthesis |\n| rparen | Right parenthesis |\n| X | Any non-numeric character |\n\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\n\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\n\n## CSV and SSV Delimiters\n\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\n\nThe rules for a CSV-delimited field are:\n\n- The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n- Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\n  ```\n  \"There is a double quote \"\" here\"\n  ```\n\n  is translated to the table value:\n\n  ```\n  There is a double quote \" here\n  ```\n\n  Whitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\n- Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\n\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\n\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \"counted\" formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)\n\nCopy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\n\n## With Null Clause for Copy\n\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\n\n### With Null (value) Clause\n\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\n\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.",
            "To prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\n\nFor example, this example of a value is incorrect:\n\n```\nc0comma with null(0)\n```\n\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\n\n```\nc0comma with null('0')\n```\n\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\n\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\n\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\n\n```sql\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\n```\n\nThe correct version specifies a 4-character format for the column.\n\n```sql\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\n```\n\n### With Null Clause Omitting Value\n\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\n\n## Filename Specification for Copy\n\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\n\nUNIX: For copy into, if the file already exists, copy overwrites it.\n\n## Windows File Types for Copy\n\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\n\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\n\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\n\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\n\nThe binary-copy forms (copy () from or copy () into) use binary mode.\n\nNote: Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.\n\nCopy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\n\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\n\n## With Clause for Copy\n\nValid with clause options for the copy statement are as follows:\n\n### On_error=TERMINATE|CONTINUE\n\nDirects copy to continue after encountering conversion errors.\n\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\n\nBy default, copy terminates when an error occurs while converting between table format and file format\n\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\n\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\n\n### Error_count=n\n\nSpecifies how many errors can occur before processing terminates.\n\nDefault: 1.\n\nIf on_error is set to continue, setting error_count has no effect.",
            "Default: 1.\n\nIf on_error is set to continue, setting error_count has no effect.\n\n### Log='filename'\n\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\n\nLogging works as follows:\n\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\n\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\n\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\n\n### Rollback=ENABLED|DISABLED\n\nEnables or disables rollback, as follows:\n\n- ENABLED: Directs the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\n- DISABLED: Retains the appended rows.\n\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\n\nDefault: ENABLED\n\nWhen copying to a file, the with rollback clause has no effect.\n\n### Row_estimate\n\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\n\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\n\n## Permissions\n\nTo use the copy statement, one of the following must apply:\n\n- You own the table.\n- The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n- You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\n\n## Locking\n\n- When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n- When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n- When performing a non-bulk copy into a table, the DBMS server takes an \"intent exclusive\" lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\n\n## Restrictions and Considerations\n\n- Copy cannot be used to add data to a view, index, or system catalog.\n- When copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\n- When copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\n- The copy statement does not fire any rules defined against the table.\n- Values cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\n- Copy treats a present-but-empty field in the data file as:\n  - A blank default for character-based columns\n  - A zero default for numeric columns\n  - December 31 00-1 for date and timestamp columns\n  - 00:00:00 for time columns (and the time component in a timestamp)",
            "For example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\n\n## Related Statements\n\n- Create Table Statement\n- Modify Statement\n\n## Examples--Copy Statement\n\nThe following examples illustrate the correct use of the copy statement:\n\n1. In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\n\n   ```\n   ename     char(15)\n   age       integer4\n   dept      char(10)\n   comment   varchar(20)\n   ```\n\n   The emp.txt file contains the following data:\n\n   ```\n   Jones,J. 32 Anytown,USA toy,00017A This is a comment\n   Smith,P. 41 New York,NY admin,00015 Another comment\n   ```\n\n   The following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\n   - A dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\n   - The department field is delimited by a comma.\n   - The comment field is a variable-length varchar field, preceded by a five-character length specifier.\n\n2. Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\n\n   ```sql\n   copy table employee (eno=integer2, ename=char(10),\n       age=integer2, job=integer2, sal=float4,\n       dept=integer2, xxx=d1)\n       from 'myfile.in';\n   ```\n\n3. Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\n\n   ```sql\n   copy table employee (ename=char(0)comma,\n       eno=char(0)comma, sal= char(0)nl)\n       into 'mfile.out';\n   ```\n\n   Joe Smith , 101, $25000.00\n   \n   Shirley Scott , 102, $30000.00\n\n4. The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\n\n   ```sql\n   copy table employee (ename = text(0)csv,\n       eno = text(0)csv, sal = text(0)csv)\n       into 'mfile.out';\n   ```\n    \n   Joe Smith,101,$25000.00\n   Shirley Scott,102,$30000.00\n\n5. Bulk copy the employee table into a file. The resulting data file contains binary data.\n\n   ```sql\n   copy table employee () into 'ourfile.dat';\n   ```\n\n6. Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\n\n   ```sql\n   copy table other_employee_table () from 'ourfile.dat';\n   ```\n\n7. Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\n\n   ```sql\n   copy table acct_recv\n       (acct_name=char(0)'%',\n       address='d0%',\n       credit=char(0)'%' with null('xx'),\n       debit=char(0)'%' with null('xx'),\n       acct_mngr=char(15),\n       xx=d0nl)\n       into 'qtr_result';\n   ```\n\n   Smith Corp%% $12345.00% $-67890.00%Jones\n   ABC Oil %% $54321.00% $-98765.00%Green\n   Spring Omc%%xx %xx %Namroc\n\n8. Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\n\n   ```sql\n   copy table gifts\n       (item_name=char(0)tab,\n       date_recd=char(0)tab,\n       sender=char(20)nl with null('anonymous'))\n       into 'giftdata';\n   ```\n\n   toaster 04-mar-1993 Nicholas\n   sled 10-oct-1993 anonymous\n   rocket 01-dec-1993 Francisco\n\n9. Create a table and load it using bulk copy, specifying structural options.\n\n   ```sql\n   create table mytable (name char 25, ...);\n   \n   modify mytable to hash;\n   \n   copy mytable() from 'myfile' with minpages = 16384,\n   maxpages = 16384, allocation = 16384;\n   ```"
        ]
    },
    {
        "instruction": "Explain how to use the on_error parameter in Actian 4GL SQL COPY statements and what happens if it is set to CONTINUE or TERMINATE.",
        "input": "",
        "output": "The on\\_error parameter in Actian 4GL SQL COPY statements determines what action to take when conversion errors occur during data import and export operations. If set to CONTINUE, copy continues after encountering conversion errors and skips the row that caused the error, displaying a warning for each error. If set to TERMINATE (the default), copy terminates immediately upon encountering a conversion error without skipping any rows.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "# Copy Statement\n\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\n\nThis statement has the following syntax:\n\n```sql\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\n```\n\n## Parameters--Copy Statement\n\nThis statement has the following parameters:\n\n- **table_name**: Specifies an existing table from which data is read or to which data is written.\n- **column_name**: Specifies the column from which data is read or to which data is written.\n- **format**: Specifies the format in which a value is stored in the file.\n- **filename**: Specifies the file from which data is read or to which data is written.\n- **type**: (Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\n\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\n\n- **with_clause**: Consists of the word with, followed by a comma-separated list of one or more of the following items:\n  - on_error = TERMINATE | CONTINUE\n  - error_count = n\n  - rollback = ENABLED | DISABLED\n  - log = 'filename'\n\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\n- allocation = n\n- extend = n\n- fillfactor = n (ISAM, Hash, and Btree only)\n- minpages = n (Hash only)\n- maxpages = n (Hash only)\n- leaffill = n (Btree only)\n- nonleaffill = n (Btree only)\n- row_estimate = n\n\n## Unformatted Copying\n\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\n\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\n\n```sql\ncopy table employee () into 'emp_name';\n```\n\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\n\nNote: An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\n\n## Formatted Copying\n\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\n\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\n\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\n\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\n\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).",
            "The values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.\n\nNote: If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\n\n```sql\ncopy table t (col1=c20, col2=c30, d0=nl) into 't.out':\n```\n\n## Bulk Copying\n\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\n\nThe requirements for performing a bulk copy are:\n\n- The table is not journaled\n- The table has no secondary indexes\n- For storage structures other than heap, the table is empty and occupies fewer than 18 pages\n\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\n\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\n\n## Column Formats for Copy\n\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\n\nNote: When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\n\n### Character (Text) Formats\n\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\n\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\n\nThe subtle differences between the various character formats are described in Copy Format Details.\n\n### Counted Character Formats\n\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\n\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\n\nNote: Nvarchar(0) is not a counted format.\n\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\n\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\n\n### Dummy Format\n\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\n\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\n\n### Unicode Formats\n\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\n\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\n\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\n\n### Binary Formats",
            "### Binary Formats\n\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\n\nCertainly. I'll convert the provided documentation into a Markdown (.md) file format, maintaining the content while adjusting only the formatting. Here's the result:\n\n### Copy Format Details\n\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\n- Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n- When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n- The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\n\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).",
            "| Format | How Stored (copy into) | How Read (copy from) |\n|--------|------------------------|----------------------|\n| boolean | Written as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format) | Same format as copy into |\n| byte(0) | Same as byte(n) where n is the display length of the corresponding table column. | Read as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. |\n| byte(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded. |\n| byte varying(0) | Same as byte varying(n) where n is the display length of the table column. | Read as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |\n| byte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000. | Written as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding. | Read as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |\n| C0 | Same as Cn where n is the display length of the corresponding table column | Read as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Any control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\. |\n| Cn | Written as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Any control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\. |\n| char(0) | Same as char(n) where n is the display length of the corresponding table column. | Read as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value. Unlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is. |\n| char(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding. Unlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is. | Read as a fixed-length string. If a delimiter is specified, one additional character is read and discarded. Unlike C format, char does not convert control characters or tabs. File data is read as is. |\n| D0 | Instead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.) Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed. | Dummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value. Any \\ found in the input means that the next character is to be taken literally, and is not a delimiter. |\n| Dn | Dummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1. | Dummy field. N characters are read and discarded. Copy from does not allow a delimiter specification with a fixed-length dummy field. |\n| date | Written as a date. (A binary format) | Read as a date. (A binary format) |\n| decimal | Written as a decimal number. (A binary format.) | Read as a decimal number. (A binary format) |\n| float | Written as double\u2011precision floating point. (A binary format) | Read as double\u2011precision floating point. (A binary format) |\n| float4 | Written as single\u2011precision floating point. (A binary format) | Read as single\u2011precision floating point. (A binary format) |\n| integer | Written as integer of 4\u2011byte length. (A binary format) | Read as integer of 4\u2011byte length. (A binary format) |",
            "| integer1 | Written as integer of 1\u2011byte length. (A binary format) | Read as integer of 1\u2011byte length. (A binary format) |\n| long byte(0) | Identical to long varchar | Identical to long varchar |\n| long nvarchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). The maximum segment size for the long nvarchar segment is 32727 bytes. The UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment. If a delimiter is specified, it is written immediately following the last segment. | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| long varchar(0) | Written in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767. The following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long: 5 abcde10 abcdefghij 0 (with a space after the terminating 0 character) (In this example, the data that is in the originating table column is abcdeabcdefghij) | Read under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read. |\n| money | Written as a scaled floating point value (a money value). (A binary format) | Read as a scaled floating-point values (a money value). (A binary format) |\n| nchar(0) | Written as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value. | Read as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered. |\n| nvarchar(0) | Same as nchar(0) | Same as nchar(0) |\n| nchar(n) | Written as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| nvarchar(n) | Written as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding. The byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier. | Read using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded. |\n| smallint | Written as an integer of 2\u2011byte length. (A binary format.) | Read as integer of 2\u2011byte length. (A binary format) |\n| text(0) | Written as a variable length string. If a delimiter is specified, it is written after the value. If the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding. Copy into using text(0) format is the way to get variable width output with no padding. | Read as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value |\n| text(n) | Written as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding. | Reads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded. |\n| varchar(0) | Same as varchar(n), where n is the display length of the corresponding table column. | Read as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found. |",
            "| varchar(n) where n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance). | Written as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length. | Read as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded. |",
            "Note: The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\n\nFor user-defined data types (UDTs), use char or varchar.\n\nCertainly. I'll create a single Markdown (.md) file based on the provided documentation, focusing on formatting the content without modifying it. Here's the Markdown version:\n\n### Delimiters in the Data File\n\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\n\n| Delimiter | Description |\n|-----------|-------------|\n| nl | Newline character |\n| tab | Tab character |\n| sp | Space |\n| csv | Comma separated values |\n| ssv | Semicolon separated values |\n| nul or null | Null/zero character |\n| comma | Comma |\n| colon | Colon |\n| dash | Dash |\n| lparen | Left parenthesis |\n| rparen | Right parenthesis |\n| X | Any non-numeric character |\n\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\n\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\n\n## CSV and SSV Delimiters\n\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\n\nThe rules for a CSV-delimited field are:\n\n- The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n- Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\n  ```\n  \"There is a double quote \"\" here\"\n  ```\n\n  is translated to the table value:\n\n  ```\n  There is a double quote \" here\n  ```\n\n  Whitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\n- Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\n\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\n\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \"counted\" formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)\n\nCopy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\n\n## With Null Clause for Copy\n\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\n\n### With Null (value) Clause\n\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\n\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.",
            "To prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\n\nFor example, this example of a value is incorrect:\n\n```\nc0comma with null(0)\n```\n\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\n\n```\nc0comma with null('0')\n```\n\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\n\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\n\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\n\n```sql\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\n```\n\nThe correct version specifies a 4-character format for the column.\n\n```sql\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\n```\n\n### With Null Clause Omitting Value\n\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\n\n## Filename Specification for Copy\n\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\n\nUNIX: For copy into, if the file already exists, copy overwrites it.\n\n## Windows File Types for Copy\n\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\n\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\n\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\n\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\n\nThe binary-copy forms (copy () from or copy () into) use binary mode.\n\nNote: Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.\n\nCopy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\n\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\n\n## With Clause for Copy\n\nValid with clause options for the copy statement are as follows:\n\n### On_error=TERMINATE|CONTINUE\n\nDirects copy to continue after encountering conversion errors.\n\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\n\nBy default, copy terminates when an error occurs while converting between table format and file format\n\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\n\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\n\n### Error_count=n\n\nSpecifies how many errors can occur before processing terminates.\n\nDefault: 1.\n\nIf on_error is set to continue, setting error_count has no effect.",
            "Default: 1.\n\nIf on_error is set to continue, setting error_count has no effect.\n\n### Log='filename'\n\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\n\nLogging works as follows:\n\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\n\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\n\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\n\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\n\n### Rollback=ENABLED|DISABLED\n\nEnables or disables rollback, as follows:\n\n- ENABLED: Directs the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\n- DISABLED: Retains the appended rows.\n\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\n\nDefault: ENABLED\n\nWhen copying to a file, the with rollback clause has no effect.\n\n### Row_estimate\n\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\n\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\n\n## Permissions\n\nTo use the copy statement, one of the following must apply:\n\n- You own the table.\n- The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n- You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\n\n## Locking\n\n- When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n- When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n- When performing a non-bulk copy into a table, the DBMS server takes an \"intent exclusive\" lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\n\n## Restrictions and Considerations\n\n- Copy cannot be used to add data to a view, index, or system catalog.\n- When copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\n- When copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\n- The copy statement does not fire any rules defined against the table.\n- Values cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\n- Copy treats a present-but-empty field in the data file as:\n  - A blank default for character-based columns\n  - A zero default for numeric columns\n  - December 31 00-1 for date and timestamp columns\n  - 00:00:00 for time columns (and the time component in a timestamp)",
            "For example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\n\n## Related Statements\n\n- Create Table Statement\n- Modify Statement\n\n## Examples--Copy Statement\n\nThe following examples illustrate the correct use of the copy statement:\n\n1. In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\n\n   ```\n   ename     char(15)\n   age       integer4\n   dept      char(10)\n   comment   varchar(20)\n   ```\n\n   The emp.txt file contains the following data:\n\n   ```\n   Jones,J. 32 Anytown,USA toy,00017A This is a comment\n   Smith,P. 41 New York,NY admin,00015 Another comment\n   ```\n\n   The following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\n   - A dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\n   - The department field is delimited by a comma.\n   - The comment field is a variable-length varchar field, preceded by a five-character length specifier.\n\n2. Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\n\n   ```sql\n   copy table employee (eno=integer2, ename=char(10),\n       age=integer2, job=integer2, sal=float4,\n       dept=integer2, xxx=d1)\n       from 'myfile.in';\n   ```\n\n3. Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\n\n   ```sql\n   copy table employee (ename=char(0)comma,\n       eno=char(0)comma, sal= char(0)nl)\n       into 'mfile.out';\n   ```\n\n   Joe Smith , 101, $25000.00\n   \n   Shirley Scott , 102, $30000.00\n\n4. The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\n\n   ```sql\n   copy table employee (ename = text(0)csv,\n       eno = text(0)csv, sal = text(0)csv)\n       into 'mfile.out';\n   ```\n    \n   Joe Smith,101,$25000.00\n   Shirley Scott,102,$30000.00\n\n5. Bulk copy the employee table into a file. The resulting data file contains binary data.\n\n   ```sql\n   copy table employee () into 'ourfile.dat';\n   ```\n\n6. Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\n\n   ```sql\n   copy table other_employee_table () from 'ourfile.dat';\n   ```\n\n7. Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\n\n   ```sql\n   copy table acct_recv\n       (acct_name=char(0)'%',\n       address='d0%',\n       credit=char(0)'%' with null('xx'),\n       debit=char(0)'%' with null('xx'),\n       acct_mngr=char(15),\n       xx=d0nl)\n       into 'qtr_result';\n   ```\n\n   Smith Corp%% $12345.00% $-67890.00%Jones\n   ABC Oil %% $54321.00% $-98765.00%Green\n   Spring Omc%%xx %xx %Namroc\n\n8. Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\n\n   ```sql\n   copy table gifts\n       (item_name=char(0)tab,\n       date_recd=char(0)tab,\n       sender=char(20)nl with null('anonymous'))\n       into 'giftdata';\n   ```\n\n   toaster 04-mar-1993 Nicholas\n   sled 10-oct-1993 anonymous\n   rocket 01-dec-1993 Francisco\n\n9. Create a table and load it using bulk copy, specifying structural options.\n\n   ```sql\n   create table mytable (name char 25, ...);\n   \n   modify mytable to hash;\n   \n   copy mytable() from 'myfile' with minpages = 16384,\n   maxpages = 16384, allocation = 16384;\n   ```"
        ]
    }
]