[
    {
        "instruction": "What happens if you specify the column names while fetching columns out of order? Provide an example.",
        "input": "",
        "output": "If you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nExample:\n```sql\n/* Select columns A, B, C, and D */\nselect a, b, c, d from table;\n\n/* Fetch columns B and D with specified column names */\nfetch cursor into :b = b_col, :d = d_col;\n```",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "What happens when the fetch statement finds no rows to fetch?",
        "input": "",
        "output": "If a `fetch` statement finds no rows, it sets the `State` attribute of the `CursorObject` class to `CS_NO_MORE_ROWS`, and does not change the variables. The value of the `iirowcount` system variable is set to zero.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "Can you give an example for specifying columns in a fetch statement?",
        "input": "",
        "output": "If you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names as follows:\n```sql\nfetch cursor_variable into :variable = B, :variable = D;\n```\nor if you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "What is the syntax of the Fetch Statement in Actian 4GL SQL?",
        "input": "",
        "output": "The `fetch` statement in Actian 4GL SQL has the following syntax:\n```\nfetch cursor_variable into variable_list;\n```",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "What is the difference between a simple list of variables and specifying column names when using the fetch statement in Actian 4GL SQL?",
        "input": "",
        "output": "A simple list of variables can be used whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\nOn the other hand, you must specify column names whenever you fetch column values out of order. You can specify the column names in any order when using them. If you have retrieved values into `resultnames` in your select statement, use these as the variables in the `fetch` statement's variable list.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "What happens to the `iirowcount` variable after a fetch operation in Actian 4GL SQL?",
        "input": "",
        "output": "If the fetch statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the fetch statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "What is the minimum number of variables that can be specified in the variable list for a successful fetch operation?",
        "input": "",
        "output": "You can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "What is the purpose of using column names in a fetch statement?",
        "input": "",
        "output": "You must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "What is the purpose of the `State` attribute in the `CursorObject` class and how can it be checked? Provide an example.",
        "input": "",
        "output": "The `State` attribute in the `CursorObject` class indicates the current status of a cursor. It can take different values such as `CS_CURRENT`, `CS_NO_MORE_ROWS`, and `CS_ERROR`. You can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nExample:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "What does OpenROAD set the value of `iirowcount` to after a successful fetch?",
        "input": "",
        "output": "If the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "How many variables can be specified in a fetch statement?",
        "input": "",
        "output": "The `fetch` statement can contain fewer variables than there are select expressions in the open statement, but it cannot contain more.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "What is the purpose of checking the state attribute after each fetch for a cursor in OpenROAD?",
        "input": "",
        "output": "You can check the State attribute after each fetch to determine if there are more rows to fetch. If the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the State attribute to CS\\_NO\\_MORE\\_ROWS.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "Explain the compatibility of variables and column names in a fetch statement.",
        "input": "",
        "output": "The data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "What happens if a fetch statement finds no rows to fetch?",
        "input": "",
        "output": "If a `fetch` statement finds no rows to fetch, it sets the `State` attribute of the `CursorObject` class to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch. Additionally, it does not change the variables and sets the value of the `RowCount` system variable to zero.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "What happens when a fetch statement finds no rows?",
        "input": "",
        "output": "If a fetch statement finds no rows, it sets the `iirowcount` system variable to zero and does not change the variables. Additionally, it sets the `State` attribute of the `CursorObject` class to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "Describe how to use the fetch statement when you want to retrieve values from specific columns in a specified order.",
        "input": "",
        "output": "To retrieve values from specific columns in a specified order using the fetch statement, specify the column names and the variables in this format:\n```sql\nfetch cursor_variable into :column1 = columnname, :column2 = columnname;\n```\nFor example:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\n```\nThis statement retrieves the 'name' and 'age' columns from the open cursor `emp_cursor`, and loads their values into the variables `:emp_name` and `:emp_age` respectively.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "Explain the role of the `State` attribute and the `RowCount` attribute when using cursors in Actian 4GL SQL.",
        "input": "",
        "output": "The `State` attribute is used to check whether there are remaining rows left to fetch in a cursor after a successful or unsuccessful fetch. After each fetch, if it is successful, the value of the `State` attribute is set to `CS_CURRENT`. If there are no more rows to fetch, the value is set to `CS_NO_MORE_ROWS`.\nThe `RowCount` attribute is used to check the number of rows that have been retrieved. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "Can we mix formats when specifying the variables in `variable_list`?",
        "input": "",
        "output": "No, you cannot mix the two formats (simple list of variables and explicitly listing column names) when specifying the variables in `variable_list`. You must use either format consistently.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "What should be specified when we fetch column values out of order using the fetch statement?",
        "input": "",
        "output": "You must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "What happens if the number of variables specified in the `fetch` statement does not match the number of columns selected by the select statement? What value will be assigned to the system variable `iirowcount`?",
        "input": "",
        "output": "If the number of variables specified in the `fetch` statement does not match the number of columns selected by the select statement, OpenROAD reports a mismatch in the `iierrornumber` system variable, although the row is still fetched and becomes the current row. The value of the `iirowcount` system variable remains unchanged (either one or zero).",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "Describe what happens when all rows have been fetched using the fetch statement?",
        "input": "",
        "output": "When there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a fetch statement finds no rows to fetch, it sets the State attribute of the CursorObject class to `CS_NO_MORE_ROWS`. Consequently, you can check the State attribute after each fetch to determine if there are more rows to fetch.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "Explain how to use the fetch statement when retrieving values in a non-specified order.",
        "input": "",
        "output": "To retrieve values from columns in a non-specified order, you must specify the column names for the variables. You can do this in the format:\n```sql\nfetch cursor_variable into :column1 = columnname, :column2 = columnname;\n```\nFor example:\n```sql\nfetch emp_cursor into :salary = salary, :emp_name = name;\n```\nThis statement retrieves the 'salary' and 'name' columns from the open cursor `emp_cursor`, but in a non-specified order because we specified the variables names instead of their positions.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "What does OpenROAD set the State attribute of CursorObject to when there are no more rows to fetch?",
        "input": "",
        "output": "Consequently, you can check the State attribute after each fetch to determine if there are more rows to fetch. If a `fetch` statement finds no rows to fetch, it sets the State attribute to CS_NO_MORE_ROWS.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "What is the purpose of using a fetch statement in Actian 4GL SQL?",
        "input": "",
        "output": "The primary purpose of using a `fetch` statement in Actian 4GL SQL is to retrieve a row from an open cursor and load it into specified variables. It moves the cursor forward one row in the result set, puts the values from specified columns into the specified variables, and sets the `State` and `RowCount` attributes of the `CursorObject` class.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "Explain how to retrieve a subset of values that begins with the first value retrieved by the select statement using the fetch statement in Actian 4GL SQL.",
        "input": "",
        "output": "To retrieve a subset of values that begins with the first value retrieved by the select statement using the `fetch` statement, specify a list of variables that contains fewer variables than there are select expressions in the `open` statement but enough to retrieve your desired subset. For example:\n```sql\nopen emp_cursor for select name, age from employees;\nfetch emp_cursor into :emp_name, :emp_age;\n```",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "When can you use a simple list of variables when retrieving values with the fetch statement?",
        "input": "",
        "output": "You can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "How can you check if there are more rows to fetch after a fetch operation?",
        "input": "",
        "output": "To find out if there are more rows to fetch, you can check the `State` attribute of the `CursorObject` class. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch. For example, if a fetch statement found no rows to fetch, it sets the State attribute to CS_NO_MORE_ROWS.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "What is the maximum number of variables that can be specified in the `variable_list` parameter?",
        "input": "",
        "output": "The `fetch` statement cannot contain more variables than there are select expressions in the open statement.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "Explain how can you use the fetch statement when there are no more rows left in the result set?",
        "input": "",
        "output": "If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute of the CursorObject class to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "Explain how the compatibility between variables and column names is handled in a fetch statement in Actian 4GL SQL?",
        "input": "",
        "output": "OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable. However, the row is still fetched and becomes the current row. It is recommended that you specify the data types of the variables compatible with the values that are assigned to them.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "Explain how can we fetch a subset of column values in a result row using the Fetch statement in Actian 4GL SQL?",
        "input": "",
        "output": "You can use a simple list of variables whenever you:\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved). For example, if you want to fetch only column A and C, you would use the following `fetch` statement:\n\n```sql\nfetch cursor_variable into :columnA, :columnC;\n```",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "How is the state attribute of CursorObject affected after a successful fetch?",
        "input": "",
        "output": "After a successful `fetch`, OpenROAD sets the value of the `State` attribute of the `CursorObject` to `CS_CURRENT`. This means that you have moved to a new row.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "Provide an example where you fetch values in an order different than the order specified by the SELECT statement using variable names.",
        "input": "",
        "output": "Here's an example of fetched values in a different order than the order specified by the select statement, using variable names:\n```sql\nopen emp_cursor for select name, age from employees;\nfetch emp_cursor into :age, :name;\n```",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "What is the purpose of specifying column names while fetching data?",
        "input": "",
        "output": "In Actian 4GL SQL, you must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the SELECT statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "How does OpenROAD handle compatibility checking between variables and column names?",
        "input": "",
        "output": "OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "Explain how to retrieve a subset of the values from a row fetched by the Fetch Statement in Actian 4GL SQL?",
        "input": "",
        "output": "To retrieve a subset of the values from a row fetched by the `fetch` statement, you can use a list of variables that is fewer than the number of columns selected in the `open` statement. The variables should be specified in the same order as they appear in the select statement (although not necessarily in the order the columns appear in the database table).\n\nFor example:\n```sql\nselect employee_id, name, salary from employees;\n\nopen cursor1 using select employee_id, name from employees;\n\nfetch cursor1 into :employee_id, :name;\n```\nIn this example, we are retrieving only the `employee_id` and `name` columns from the row fetched by the `fetch` statement. The variables `:employee_id` and `:name` are used to store the values of these columns.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "Explain how to fetch column values out of order in Actian 4GL SQL's Fetch Statement?",
        "input": "",
        "output": "To fetch column values out of order, you must specify the column names in the `variable_list` of the `fetch` statement. For example:\n```sql\nselect employee_id, name, salary from employees;\n\nopen cursor1 using select employee_id as id, name from employees;\n\nfetch cursor1 into :name = name, :employee_id = id;\n```\nIn this example, we are fetching the `name` column first and then the `employee_id` column. The variables `:name` and `:employee_id` are used to store the values of these columns. It is important to note that when you specify the column names in the `fetch` statement, you can fetch the columns in any order.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "Explain the format for the `variable_list` in a fetch statement in Actian 4GL SQL?",
        "input": "",
        "output": "You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n*",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "What is the use of the `State` attribute in a `CursorObject` in Actian 4GL SQL?",
        "input": "",
        "output": "You can check the `State` attribute after each fetch to determine if there are more rows to fetch. If it equals CS\\_CURRENT, a new row has been fetched. If it equals CS\\_NO\\_MORE\\_ROWS, all rows have been fetched. There is an error when it's different from those two values.\n\n*",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "What are some possible states a cursor object can have in Actian 4GL SQL?",
        "input": "",
        "output": "In Actian 4GL SQL, after each fetch, you can check the `State` attribute of the `CursorObject` class to determine if there are more rows to fetch. Some possible states for a cursor object include:\n- `CS_CURRENT` - A new row has been fetched.\n- `CS_NO_MORE_ROWS` - All rows have been fetched.\n- There is an error.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "What happens to the `iirowcount` system variable after a successful fetch in Actian 4GL SQL?",
        "input": "",
        "output": "If the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. This indicates that a row has been fetched successfully. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    }
]