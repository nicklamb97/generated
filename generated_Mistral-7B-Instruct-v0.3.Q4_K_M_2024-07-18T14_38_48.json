[
    {
        "instruction": "How can you pass multiple parameters to a 4GL procedure using callproc statement?",
        "input": "",
        "output": "To pass multiple parameters to a 4GL procedure, you use the `callproc` statement and specify each parameter name along with its expression separated by commas. The syntax is: `[return_variable =] callproc procedurename[(parameter1 = expression1), (parameter2 = expression2), ...]`.",
        "taxonomy_path": "knowledge->programming_languages->procedures->calling_procedures->call_4gl_procedures",
        "task_description": "Explain how you can call 4GL procedures in Actian 4GL.",
        "document": [
            "# How You Can Call 4GL Procedures\n\nThe callproc statement lets you call a global 4GL procedure from any OpenROAD script or another 4GL procedure. You also use the callproc statement to call a local procedure defined in the current frame or procedure.\n\n## Basic Syntax\n\nIn the simplest version of the statement, you can call a procedure with no return value or parameters. The basic syntax is:\n\n```sql\ncallproc procedurename\n```\n\n### *procedurename*\n\nSpecifies the name that you gave to the 4GL procedure when you created it. You can enter the procedure name directly or you can use a variable to specify the procedure name dynamically. Using a variable lets you specify the procedure name at runtime.\n\nExample:\n```sql\ncallproc error_handler;\n```\n\nWhen the procedure returns a value, you must specify a variable in the calling frame or procedure to receive the return value. The return variable must be the same data type as the return value. The basic syntax is:\n\n```sql\n[return_variable =] callproc procedurename\n```\n\n## How You Can Pass Parameters to 4GL Procedures\n\nTo pass a value to a 4GL procedure in the callproc statement, you specify the name of the parameter in the 4GL procedure that is to receive the value. The basic syntax is:\n\n```sql\n[return_variable =] callproc procedurename [(parameter = expression {, parameter = expression})]\n```\n\n### *parameter*\n\nAssigns the expression in the callproc statement to the parameter in the called procedure that you declared with the procedure statement. For more information about declaring procedure parameters, see the *Language Reference Guide* online help.\n\nBecause you specify the parameters by name rather than by position, you can pass them in any order, and you need not pass all the parameters.\n\n### *expression*\n\nSpecifies a constant or any legal OpenROAD expression, as long as the resulting data type is compatible with the data type of the local variable in the procedure. Variables in the expression can be any type, including reference variables and array variables.\n\nExample:\n```sql\ncallproc remove_new_detail(new_details_frames = new_details_frames, details_frame = video.details_frame);\n```\n\nAny variable in the procedure that you do not specify in the parameter list is set to its default value.\n\nParameters to 4GL procedures can be passed by value and by reference. For a discussion of passing parameters by value and by reference, see How You Can Pass Parameters Between an Active Child and Inactive Parent.\n\nThe value of the referenced variable is not updated until the called procedure returns. At this point, the variable in the calling frame is updated the same way it would be if you had used an assignment statement. If a field on the form is associated with the variable, the field does not display the new value until the current event block completes. To cause the value to update before the end of the event block, you can use the Flush method immediately after the callproc statement. For more information about the Flush method, see the *Language Reference Guide* online help."
        ]
    },
    {
        "instruction": "How do you pass parameters to 4GL procedures in the callproc statement?",
        "input": "",
        "output": "To pass a value to a 4GL procedure, you specify the name of the parameter in the called procedure that is to receive the value. The basic syntax is:\n```\n[return_variable =] callproc procedurename [(parameter = expression {, parameter = expression})]\n```",
        "taxonomy_path": "knowledge->programming_languages->procedures->calling_procedures->call_4gl_procedures",
        "task_description": "Explain how you can call 4GL procedures in Actian 4GL.",
        "document": [
            "# How You Can Call 4GL Procedures\n\nThe callproc statement lets you call a global 4GL procedure from any OpenROAD script or another 4GL procedure. You also use the callproc statement to call a local procedure defined in the current frame or procedure.\n\n## Basic Syntax\n\nIn the simplest version of the statement, you can call a procedure with no return value or parameters. The basic syntax is:\n\n```sql\ncallproc procedurename\n```\n\n### *procedurename*\n\nSpecifies the name that you gave to the 4GL procedure when you created it. You can enter the procedure name directly or you can use a variable to specify the procedure name dynamically. Using a variable lets you specify the procedure name at runtime.\n\nExample:\n```sql\ncallproc error_handler;\n```\n\nWhen the procedure returns a value, you must specify a variable in the calling frame or procedure to receive the return value. The return variable must be the same data type as the return value. The basic syntax is:\n\n```sql\n[return_variable =] callproc procedurename\n```\n\n## How You Can Pass Parameters to 4GL Procedures\n\nTo pass a value to a 4GL procedure in the callproc statement, you specify the name of the parameter in the 4GL procedure that is to receive the value. The basic syntax is:\n\n```sql\n[return_variable =] callproc procedurename [(parameter = expression {, parameter = expression})]\n```\n\n### *parameter*\n\nAssigns the expression in the callproc statement to the parameter in the called procedure that you declared with the procedure statement. For more information about declaring procedure parameters, see the *Language Reference Guide* online help.\n\nBecause you specify the parameters by name rather than by position, you can pass them in any order, and you need not pass all the parameters.\n\n### *expression*\n\nSpecifies a constant or any legal OpenROAD expression, as long as the resulting data type is compatible with the data type of the local variable in the procedure. Variables in the expression can be any type, including reference variables and array variables.\n\nExample:\n```sql\ncallproc remove_new_detail(new_details_frames = new_details_frames, details_frame = video.details_frame);\n```\n\nAny variable in the procedure that you do not specify in the parameter list is set to its default value.\n\nParameters to 4GL procedures can be passed by value and by reference. For a discussion of passing parameters by value and by reference, see How You Can Pass Parameters Between an Active Child and Inactive Parent.\n\nThe value of the referenced variable is not updated until the called procedure returns. At this point, the variable in the calling frame is updated the same way it would be if you had used an assignment statement. If a field on the form is associated with the variable, the field does not display the new value until the current event block completes. To cause the value to update before the end of the event block, you can use the Flush method immediately after the callproc statement. For more information about the Flush method, see the *Language Reference Guide* online help."
        ]
    },
    {
        "instruction": "What are examples of data types of local variables in a procedure?",
        "input": "",
        "output": "Variables in the expression can be any type, including reference variables and array variables. Any variable in the procedure that you do not specify in the parameter list is set to its default value.",
        "taxonomy_path": "knowledge->programming_languages->procedures->calling_procedures->call_4gl_procedures",
        "task_description": "Explain how you can call 4GL procedures in Actian 4GL.",
        "document": [
            "# How You Can Call 4GL Procedures\n\nThe callproc statement lets you call a global 4GL procedure from any OpenROAD script or another 4GL procedure. You also use the callproc statement to call a local procedure defined in the current frame or procedure.\n\n## Basic Syntax\n\nIn the simplest version of the statement, you can call a procedure with no return value or parameters. The basic syntax is:\n\n```sql\ncallproc procedurename\n```\n\n### *procedurename*\n\nSpecifies the name that you gave to the 4GL procedure when you created it. You can enter the procedure name directly or you can use a variable to specify the procedure name dynamically. Using a variable lets you specify the procedure name at runtime.\n\nExample:\n```sql\ncallproc error_handler;\n```\n\nWhen the procedure returns a value, you must specify a variable in the calling frame or procedure to receive the return value. The return variable must be the same data type as the return value. The basic syntax is:\n\n```sql\n[return_variable =] callproc procedurename\n```\n\n## How You Can Pass Parameters to 4GL Procedures\n\nTo pass a value to a 4GL procedure in the callproc statement, you specify the name of the parameter in the 4GL procedure that is to receive the value. The basic syntax is:\n\n```sql\n[return_variable =] callproc procedurename [(parameter = expression {, parameter = expression})]\n```\n\n### *parameter*\n\nAssigns the expression in the callproc statement to the parameter in the called procedure that you declared with the procedure statement. For more information about declaring procedure parameters, see the *Language Reference Guide* online help.\n\nBecause you specify the parameters by name rather than by position, you can pass them in any order, and you need not pass all the parameters.\n\n### *expression*\n\nSpecifies a constant or any legal OpenROAD expression, as long as the resulting data type is compatible with the data type of the local variable in the procedure. Variables in the expression can be any type, including reference variables and array variables.\n\nExample:\n```sql\ncallproc remove_new_detail(new_details_frames = new_details_frames, details_frame = video.details_frame);\n```\n\nAny variable in the procedure that you do not specify in the parameter list is set to its default value.\n\nParameters to 4GL procedures can be passed by value and by reference. For a discussion of passing parameters by value and by reference, see How You Can Pass Parameters Between an Active Child and Inactive Parent.\n\nThe value of the referenced variable is not updated until the called procedure returns. At this point, the variable in the calling frame is updated the same way it would be if you had used an assignment statement. If a field on the form is associated with the variable, the field does not display the new value until the current event block completes. To cause the value to update before the end of the event block, you can use the Flush method immediately after the callproc statement. For more information about the Flush method, see the *Language Reference Guide* online help."
        ]
    },
    {
        "instruction": "Can you explain how to pass parameters by reference to a 4GL procedure?",
        "input": "",
        "output": "To pass a parameter by reference, you do not specify its value in the callproc statement. Instead, you use the same variable that is used as a parameter in the called procedure. The value of the referenced variable is not updated until the called procedure returns. At this point, the variable in the calling frame is updated the same way it would be if you had used an assignment statement. If a field on the form is associated with the variable, the field does not display the new value until the current event block completes. To cause the value to update before the end of the event block, you can use the Flush method immediately after the callproc statement.",
        "taxonomy_path": "knowledge->programming_languages->procedures->calling_procedures->call_4gl_procedures",
        "task_description": "Explain how you can call 4GL procedures in Actian 4GL.",
        "document": [
            "# How You Can Call 4GL Procedures\n\nThe callproc statement lets you call a global 4GL procedure from any OpenROAD script or another 4GL procedure. You also use the callproc statement to call a local procedure defined in the current frame or procedure.\n\n## Basic Syntax\n\nIn the simplest version of the statement, you can call a procedure with no return value or parameters. The basic syntax is:\n\n```sql\ncallproc procedurename\n```\n\n### *procedurename*\n\nSpecifies the name that you gave to the 4GL procedure when you created it. You can enter the procedure name directly or you can use a variable to specify the procedure name dynamically. Using a variable lets you specify the procedure name at runtime.\n\nExample:\n```sql\ncallproc error_handler;\n```\n\nWhen the procedure returns a value, you must specify a variable in the calling frame or procedure to receive the return value. The return variable must be the same data type as the return value. The basic syntax is:\n\n```sql\n[return_variable =] callproc procedurename\n```\n\n## How You Can Pass Parameters to 4GL Procedures\n\nTo pass a value to a 4GL procedure in the callproc statement, you specify the name of the parameter in the 4GL procedure that is to receive the value. The basic syntax is:\n\n```sql\n[return_variable =] callproc procedurename [(parameter = expression {, parameter = expression})]\n```\n\n### *parameter*\n\nAssigns the expression in the callproc statement to the parameter in the called procedure that you declared with the procedure statement. For more information about declaring procedure parameters, see the *Language Reference Guide* online help.\n\nBecause you specify the parameters by name rather than by position, you can pass them in any order, and you need not pass all the parameters.\n\n### *expression*\n\nSpecifies a constant or any legal OpenROAD expression, as long as the resulting data type is compatible with the data type of the local variable in the procedure. Variables in the expression can be any type, including reference variables and array variables.\n\nExample:\n```sql\ncallproc remove_new_detail(new_details_frames = new_details_frames, details_frame = video.details_frame);\n```\n\nAny variable in the procedure that you do not specify in the parameter list is set to its default value.\n\nParameters to 4GL procedures can be passed by value and by reference. For a discussion of passing parameters by value and by reference, see How You Can Pass Parameters Between an Active Child and Inactive Parent.\n\nThe value of the referenced variable is not updated until the called procedure returns. At this point, the variable in the calling frame is updated the same way it would be if you had used an assignment statement. If a field on the form is associated with the variable, the field does not display the new value until the current event block completes. To cause the value to update before the end of the event block, you can use the Flush method immediately after the callproc statement. For more information about the Flush method, see the *Language Reference Guide* online help."
        ]
    },
    {
        "instruction": "What happens if a parameter is missing in a 4GL procedure?",
        "input": "",
        "output": "Any variable in the procedure that you do not specify in the parameter list is set to its default value.",
        "taxonomy_path": "knowledge->programming_languages->procedures->calling_procedures->call_4gl_procedures",
        "task_description": "Explain how you can call 4GL procedures in Actian 4GL.",
        "document": [
            "# How You Can Call 4GL Procedures\n\nThe callproc statement lets you call a global 4GL procedure from any OpenROAD script or another 4GL procedure. You also use the callproc statement to call a local procedure defined in the current frame or procedure.\n\n## Basic Syntax\n\nIn the simplest version of the statement, you can call a procedure with no return value or parameters. The basic syntax is:\n\n```sql\ncallproc procedurename\n```\n\n### *procedurename*\n\nSpecifies the name that you gave to the 4GL procedure when you created it. You can enter the procedure name directly or you can use a variable to specify the procedure name dynamically. Using a variable lets you specify the procedure name at runtime.\n\nExample:\n```sql\ncallproc error_handler;\n```\n\nWhen the procedure returns a value, you must specify a variable in the calling frame or procedure to receive the return value. The return variable must be the same data type as the return value. The basic syntax is:\n\n```sql\n[return_variable =] callproc procedurename\n```\n\n## How You Can Pass Parameters to 4GL Procedures\n\nTo pass a value to a 4GL procedure in the callproc statement, you specify the name of the parameter in the 4GL procedure that is to receive the value. The basic syntax is:\n\n```sql\n[return_variable =] callproc procedurename [(parameter = expression {, parameter = expression})]\n```\n\n### *parameter*\n\nAssigns the expression in the callproc statement to the parameter in the called procedure that you declared with the procedure statement. For more information about declaring procedure parameters, see the *Language Reference Guide* online help.\n\nBecause you specify the parameters by name rather than by position, you can pass them in any order, and you need not pass all the parameters.\n\n### *expression*\n\nSpecifies a constant or any legal OpenROAD expression, as long as the resulting data type is compatible with the data type of the local variable in the procedure. Variables in the expression can be any type, including reference variables and array variables.\n\nExample:\n```sql\ncallproc remove_new_detail(new_details_frames = new_details_frames, details_frame = video.details_frame);\n```\n\nAny variable in the procedure that you do not specify in the parameter list is set to its default value.\n\nParameters to 4GL procedures can be passed by value and by reference. For a discussion of passing parameters by value and by reference, see How You Can Pass Parameters Between an Active Child and Inactive Parent.\n\nThe value of the referenced variable is not updated until the called procedure returns. At this point, the variable in the calling frame is updated the same way it would be if you had used an assignment statement. If a field on the form is associated with the variable, the field does not display the new value until the current event block completes. To cause the value to update before the end of the event block, you can use the Flush method immediately after the callproc statement. For more information about the Flush method, see the *Language Reference Guide* online help."
        ]
    },
    {
        "instruction": "Answer the question above using information from the provided document.",
        "input": "",
        "output": "The basic syntax for calling a 4GL procedure with no parameters and no return value is:\n```sql\ncallproc procedurename\n```",
        "taxonomy_path": "knowledge->programming_languages->procedures->calling_procedures->call_4gl_procedures",
        "task_description": "Explain how you can call 4GL procedures in Actian 4GL.",
        "document": [
            "# How You Can Call 4GL Procedures\n\nThe callproc statement lets you call a global 4GL procedure from any OpenROAD script or another 4GL procedure. You also use the callproc statement to call a local procedure defined in the current frame or procedure.\n\n## Basic Syntax\n\nIn the simplest version of the statement, you can call a procedure with no return value or parameters. The basic syntax is:\n\n```sql\ncallproc procedurename\n```\n\n### *procedurename*\n\nSpecifies the name that you gave to the 4GL procedure when you created it. You can enter the procedure name directly or you can use a variable to specify the procedure name dynamically. Using a variable lets you specify the procedure name at runtime.\n\nExample:\n```sql\ncallproc error_handler;\n```\n\nWhen the procedure returns a value, you must specify a variable in the calling frame or procedure to receive the return value. The return variable must be the same data type as the return value. The basic syntax is:\n\n```sql\n[return_variable =] callproc procedurename\n```\n\n## How You Can Pass Parameters to 4GL Procedures\n\nTo pass a value to a 4GL procedure in the callproc statement, you specify the name of the parameter in the 4GL procedure that is to receive the value. The basic syntax is:\n\n```sql\n[return_variable =] callproc procedurename [(parameter = expression {, parameter = expression})]\n```\n\n### *parameter*\n\nAssigns the expression in the callproc statement to the parameter in the called procedure that you declared with the procedure statement. For more information about declaring procedure parameters, see the *Language Reference Guide* online help.\n\nBecause you specify the parameters by name rather than by position, you can pass them in any order, and you need not pass all the parameters.\n\n### *expression*\n\nSpecifies a constant or any legal OpenROAD expression, as long as the resulting data type is compatible with the data type of the local variable in the procedure. Variables in the expression can be any type, including reference variables and array variables.\n\nExample:\n```sql\ncallproc remove_new_detail(new_details_frames = new_details_frames, details_frame = video.details_frame);\n```\n\nAny variable in the procedure that you do not specify in the parameter list is set to its default value.\n\nParameters to 4GL procedures can be passed by value and by reference. For a discussion of passing parameters by value and by reference, see How You Can Pass Parameters Between an Active Child and Inactive Parent.\n\nThe value of the referenced variable is not updated until the called procedure returns. At this point, the variable in the calling frame is updated the same way it would be if you had used an assignment statement. If a field on the form is associated with the variable, the field does not display the new value until the current event block completes. To cause the value to update before the end of the event block, you can use the Flush method immediately after the callproc statement. For more information about the Flush method, see the *Language Reference Guide* online help."
        ]
    },
    {
        "instruction": "How do you call a local procedure defined in the current frame or procedure?",
        "input": "",
        "output": "You can call a local procedure by using the `callproc` statement. The basic syntax is:\n```\ncallproc procedurenamelocal\n```\nWhere `procedurenamelocal` is the name of the local procedure in the current frame or procedure.",
        "taxonomy_path": "knowledge->programming_languages->procedures->calling_procedures->call_4gl_procedures",
        "task_description": "Explain how you can call 4GL procedures in Actian 4GL.",
        "document": [
            "# How You Can Call 4GL Procedures\n\nThe callproc statement lets you call a global 4GL procedure from any OpenROAD script or another 4GL procedure. You also use the callproc statement to call a local procedure defined in the current frame or procedure.\n\n## Basic Syntax\n\nIn the simplest version of the statement, you can call a procedure with no return value or parameters. The basic syntax is:\n\n```sql\ncallproc procedurename\n```\n\n### *procedurename*\n\nSpecifies the name that you gave to the 4GL procedure when you created it. You can enter the procedure name directly or you can use a variable to specify the procedure name dynamically. Using a variable lets you specify the procedure name at runtime.\n\nExample:\n```sql\ncallproc error_handler;\n```\n\nWhen the procedure returns a value, you must specify a variable in the calling frame or procedure to receive the return value. The return variable must be the same data type as the return value. The basic syntax is:\n\n```sql\n[return_variable =] callproc procedurename\n```\n\n## How You Can Pass Parameters to 4GL Procedures\n\nTo pass a value to a 4GL procedure in the callproc statement, you specify the name of the parameter in the 4GL procedure that is to receive the value. The basic syntax is:\n\n```sql\n[return_variable =] callproc procedurename [(parameter = expression {, parameter = expression})]\n```\n\n### *parameter*\n\nAssigns the expression in the callproc statement to the parameter in the called procedure that you declared with the procedure statement. For more information about declaring procedure parameters, see the *Language Reference Guide* online help.\n\nBecause you specify the parameters by name rather than by position, you can pass them in any order, and you need not pass all the parameters.\n\n### *expression*\n\nSpecifies a constant or any legal OpenROAD expression, as long as the resulting data type is compatible with the data type of the local variable in the procedure. Variables in the expression can be any type, including reference variables and array variables.\n\nExample:\n```sql\ncallproc remove_new_detail(new_details_frames = new_details_frames, details_frame = video.details_frame);\n```\n\nAny variable in the procedure that you do not specify in the parameter list is set to its default value.\n\nParameters to 4GL procedures can be passed by value and by reference. For a discussion of passing parameters by value and by reference, see How You Can Pass Parameters Between an Active Child and Inactive Parent.\n\nThe value of the referenced variable is not updated until the called procedure returns. At this point, the variable in the calling frame is updated the same way it would be if you had used an assignment statement. If a field on the form is associated with the variable, the field does not display the new value until the current event block completes. To cause the value to update before the end of the event block, you can use the Flush method immediately after the callproc statement. For more information about the Flush method, see the *Language Reference Guide* online help."
        ]
    },
    {
        "instruction": "What is the use of `return_variable` in calling a 4GL procedure?",
        "input": "",
        "output": "`return_variable` is used when you want to receive the return value from the called 4GL procedure. You must specify this variable in the calling frame or procedure with the syntax:\n```\n[return_variable =] callproc procedurename\n```\nThe data type of `return_variable` should be compatible with the return value data type of the called 4GL procedure.",
        "taxonomy_path": "knowledge->programming_languages->procedures->calling_procedures->call_4gl_procedures",
        "task_description": "Explain how you can call 4GL procedures in Actian 4GL.",
        "document": [
            "# How You Can Call 4GL Procedures\n\nThe callproc statement lets you call a global 4GL procedure from any OpenROAD script or another 4GL procedure. You also use the callproc statement to call a local procedure defined in the current frame or procedure.\n\n## Basic Syntax\n\nIn the simplest version of the statement, you can call a procedure with no return value or parameters. The basic syntax is:\n\n```sql\ncallproc procedurename\n```\n\n### *procedurename*\n\nSpecifies the name that you gave to the 4GL procedure when you created it. You can enter the procedure name directly or you can use a variable to specify the procedure name dynamically. Using a variable lets you specify the procedure name at runtime.\n\nExample:\n```sql\ncallproc error_handler;\n```\n\nWhen the procedure returns a value, you must specify a variable in the calling frame or procedure to receive the return value. The return variable must be the same data type as the return value. The basic syntax is:\n\n```sql\n[return_variable =] callproc procedurename\n```\n\n## How You Can Pass Parameters to 4GL Procedures\n\nTo pass a value to a 4GL procedure in the callproc statement, you specify the name of the parameter in the 4GL procedure that is to receive the value. The basic syntax is:\n\n```sql\n[return_variable =] callproc procedurename [(parameter = expression {, parameter = expression})]\n```\n\n### *parameter*\n\nAssigns the expression in the callproc statement to the parameter in the called procedure that you declared with the procedure statement. For more information about declaring procedure parameters, see the *Language Reference Guide* online help.\n\nBecause you specify the parameters by name rather than by position, you can pass them in any order, and you need not pass all the parameters.\n\n### *expression*\n\nSpecifies a constant or any legal OpenROAD expression, as long as the resulting data type is compatible with the data type of the local variable in the procedure. Variables in the expression can be any type, including reference variables and array variables.\n\nExample:\n```sql\ncallproc remove_new_detail(new_details_frames = new_details_frames, details_frame = video.details_frame);\n```\n\nAny variable in the procedure that you do not specify in the parameter list is set to its default value.\n\nParameters to 4GL procedures can be passed by value and by reference. For a discussion of passing parameters by value and by reference, see How You Can Pass Parameters Between an Active Child and Inactive Parent.\n\nThe value of the referenced variable is not updated until the called procedure returns. At this point, the variable in the calling frame is updated the same way it would be if you had used an assignment statement. If a field on the form is associated with the variable, the field does not display the new value until the current event block completes. To cause the value to update before the end of the event block, you can use the Flush method immediately after the callproc statement. For more information about the Flush method, see the *Language Reference Guide* online help."
        ]
    },
    {
        "instruction": "What is passing parameters by reference, and how is it applicable when calling 4GL procedures in Actian 4GL?",
        "input": "",
        "output": "Passing parameters by reference means that the variable being passed will be directly modified inside the called procedure. This implies that changes made to the variable within the procedure are visible to the caller after the procedure returns. In other words, the original variable in the calling frame is updated with the new value. This can be useful when you want to make changes to the value of a variable from within another procedure and have those changes persist beyond the execution of that procedure.",
        "taxonomy_path": "knowledge->programming_languages->procedures->calling_procedures->call_4gl_procedures",
        "task_description": "Explain how you can call 4GL procedures in Actian 4GL.",
        "document": [
            "# How You Can Call 4GL Procedures\n\nThe callproc statement lets you call a global 4GL procedure from any OpenROAD script or another 4GL procedure. You also use the callproc statement to call a local procedure defined in the current frame or procedure.\n\n## Basic Syntax\n\nIn the simplest version of the statement, you can call a procedure with no return value or parameters. The basic syntax is:\n\n```sql\ncallproc procedurename\n```\n\n### *procedurename*\n\nSpecifies the name that you gave to the 4GL procedure when you created it. You can enter the procedure name directly or you can use a variable to specify the procedure name dynamically. Using a variable lets you specify the procedure name at runtime.\n\nExample:\n```sql\ncallproc error_handler;\n```\n\nWhen the procedure returns a value, you must specify a variable in the calling frame or procedure to receive the return value. The return variable must be the same data type as the return value. The basic syntax is:\n\n```sql\n[return_variable =] callproc procedurename\n```\n\n## How You Can Pass Parameters to 4GL Procedures\n\nTo pass a value to a 4GL procedure in the callproc statement, you specify the name of the parameter in the 4GL procedure that is to receive the value. The basic syntax is:\n\n```sql\n[return_variable =] callproc procedurename [(parameter = expression {, parameter = expression})]\n```\n\n### *parameter*\n\nAssigns the expression in the callproc statement to the parameter in the called procedure that you declared with the procedure statement. For more information about declaring procedure parameters, see the *Language Reference Guide* online help.\n\nBecause you specify the parameters by name rather than by position, you can pass them in any order, and you need not pass all the parameters.\n\n### *expression*\n\nSpecifies a constant or any legal OpenROAD expression, as long as the resulting data type is compatible with the data type of the local variable in the procedure. Variables in the expression can be any type, including reference variables and array variables.\n\nExample:\n```sql\ncallproc remove_new_detail(new_details_frames = new_details_frames, details_frame = video.details_frame);\n```\n\nAny variable in the procedure that you do not specify in the parameter list is set to its default value.\n\nParameters to 4GL procedures can be passed by value and by reference. For a discussion of passing parameters by value and by reference, see How You Can Pass Parameters Between an Active Child and Inactive Parent.\n\nThe value of the referenced variable is not updated until the called procedure returns. At this point, the variable in the calling frame is updated the same way it would be if you had used an assignment statement. If a field on the form is associated with the variable, the field does not display the new value until the current event block completes. To cause the value to update before the end of the event block, you can use the Flush method immediately after the callproc statement. For more information about the Flush method, see the *Language Reference Guide* online help."
        ]
    },
    {
        "instruction": "Provide an example scenario where the use of callproc statement with parameter passing could be beneficial in Actian 4GL.",
        "input": "",
        "output": "Suppose you are building a data validation routine for a form in Actian 4GL. You have a function `validate_input()` that checks for the presence and correctness of required fields, while another function `format_date()` formats dates entered by the user. To combine both functionalities into one operation, you can call the `validate_input()` function with the form's data frame as a parameter and the `format_date()` function to format specific date fields within that same function:\n```sql\nvalidate_input(form_data);\nfor each field in form_data.dates do\n    if form_data.dates[field].type = \"Date\" then\n        form_data.dates[field] = format_date(form_data.dates[field]);\n    end if;\nend for;\n```",
        "taxonomy_path": "knowledge->programming_languages->procedures->calling_procedures->call_4gl_procedures",
        "task_description": "Explain how you can call 4GL procedures in Actian 4GL.",
        "document": [
            "# How You Can Call 4GL Procedures\n\nThe callproc statement lets you call a global 4GL procedure from any OpenROAD script or another 4GL procedure. You also use the callproc statement to call a local procedure defined in the current frame or procedure.\n\n## Basic Syntax\n\nIn the simplest version of the statement, you can call a procedure with no return value or parameters. The basic syntax is:\n\n```sql\ncallproc procedurename\n```\n\n### *procedurename*\n\nSpecifies the name that you gave to the 4GL procedure when you created it. You can enter the procedure name directly or you can use a variable to specify the procedure name dynamically. Using a variable lets you specify the procedure name at runtime.\n\nExample:\n```sql\ncallproc error_handler;\n```\n\nWhen the procedure returns a value, you must specify a variable in the calling frame or procedure to receive the return value. The return variable must be the same data type as the return value. The basic syntax is:\n\n```sql\n[return_variable =] callproc procedurename\n```\n\n## How You Can Pass Parameters to 4GL Procedures\n\nTo pass a value to a 4GL procedure in the callproc statement, you specify the name of the parameter in the 4GL procedure that is to receive the value. The basic syntax is:\n\n```sql\n[return_variable =] callproc procedurename [(parameter = expression {, parameter = expression})]\n```\n\n### *parameter*\n\nAssigns the expression in the callproc statement to the parameter in the called procedure that you declared with the procedure statement. For more information about declaring procedure parameters, see the *Language Reference Guide* online help.\n\nBecause you specify the parameters by name rather than by position, you can pass them in any order, and you need not pass all the parameters.\n\n### *expression*\n\nSpecifies a constant or any legal OpenROAD expression, as long as the resulting data type is compatible with the data type of the local variable in the procedure. Variables in the expression can be any type, including reference variables and array variables.\n\nExample:\n```sql\ncallproc remove_new_detail(new_details_frames = new_details_frames, details_frame = video.details_frame);\n```\n\nAny variable in the procedure that you do not specify in the parameter list is set to its default value.\n\nParameters to 4GL procedures can be passed by value and by reference. For a discussion of passing parameters by value and by reference, see How You Can Pass Parameters Between an Active Child and Inactive Parent.\n\nThe value of the referenced variable is not updated until the called procedure returns. At this point, the variable in the calling frame is updated the same way it would be if you had used an assignment statement. If a field on the form is associated with the variable, the field does not display the new value until the current event block completes. To cause the value to update before the end of the event block, you can use the Flush method immediately after the callproc statement. For more information about the Flush method, see the *Language Reference Guide* online help."
        ]
    },
    {
        "instruction": "Explain how to modify the syntax of callproc statements to accept multiple parameters in Actian 4GL.",
        "input": "",
        "output": "In Actian 4GL, you can pass multiple parameters to a procedure by specifying each parameter name followed by its corresponding value inside the parentheses of the callproc statement. The names and order of the parameters must correspond to the declarations made in the called procedure using the `procedure` statement:\n```sql\n[return_variable =] callproc procedurename [(parameter1 = expression1, parameter2 = expression2 {, parameterN = expressionN})]\n```\nFor example:\n```sql\ncallproc update_record(my_id = 5, new_data = data);\n```",
        "taxonomy_path": "knowledge->programming_languages->procedures->calling_procedures->call_4gl_procedures",
        "task_description": "Explain how you can call 4GL procedures in Actian 4GL.",
        "document": [
            "# How You Can Call 4GL Procedures\n\nThe callproc statement lets you call a global 4GL procedure from any OpenROAD script or another 4GL procedure. You also use the callproc statement to call a local procedure defined in the current frame or procedure.\n\n## Basic Syntax\n\nIn the simplest version of the statement, you can call a procedure with no return value or parameters. The basic syntax is:\n\n```sql\ncallproc procedurename\n```\n\n### *procedurename*\n\nSpecifies the name that you gave to the 4GL procedure when you created it. You can enter the procedure name directly or you can use a variable to specify the procedure name dynamically. Using a variable lets you specify the procedure name at runtime.\n\nExample:\n```sql\ncallproc error_handler;\n```\n\nWhen the procedure returns a value, you must specify a variable in the calling frame or procedure to receive the return value. The return variable must be the same data type as the return value. The basic syntax is:\n\n```sql\n[return_variable =] callproc procedurename\n```\n\n## How You Can Pass Parameters to 4GL Procedures\n\nTo pass a value to a 4GL procedure in the callproc statement, you specify the name of the parameter in the 4GL procedure that is to receive the value. The basic syntax is:\n\n```sql\n[return_variable =] callproc procedurename [(parameter = expression {, parameter = expression})]\n```\n\n### *parameter*\n\nAssigns the expression in the callproc statement to the parameter in the called procedure that you declared with the procedure statement. For more information about declaring procedure parameters, see the *Language Reference Guide* online help.\n\nBecause you specify the parameters by name rather than by position, you can pass them in any order, and you need not pass all the parameters.\n\n### *expression*\n\nSpecifies a constant or any legal OpenROAD expression, as long as the resulting data type is compatible with the data type of the local variable in the procedure. Variables in the expression can be any type, including reference variables and array variables.\n\nExample:\n```sql\ncallproc remove_new_detail(new_details_frames = new_details_frames, details_frame = video.details_frame);\n```\n\nAny variable in the procedure that you do not specify in the parameter list is set to its default value.\n\nParameters to 4GL procedures can be passed by value and by reference. For a discussion of passing parameters by value and by reference, see How You Can Pass Parameters Between an Active Child and Inactive Parent.\n\nThe value of the referenced variable is not updated until the called procedure returns. At this point, the variable in the calling frame is updated the same way it would be if you had used an assignment statement. If a field on the form is associated with the variable, the field does not display the new value until the current event block completes. To cause the value to update before the end of the event block, you can use the Flush method immediately after the callproc statement. For more information about the Flush method, see the *Language Reference Guide* online help."
        ]
    },
    {
        "instruction": "What is the purpose and usage of the Flush method in Actian 4GL callproc statements?",
        "input": "",
        "output": "The Flush method in Actian 4GL is used to refresh the screen, allowing any changes made by a procedure, such as updating form fields or displaying messages, to be immediately visible during event processing. This can help improve user experience by making updates more responsive. In the context of callproc statements, the Flush method can be called directly after calling a procedure that modifies the screen:\n```sql\ncallproc some_procedure();\nflush;\n```",
        "taxonomy_path": "knowledge->programming_languages->procedures->calling_procedures->call_4gl_procedures",
        "task_description": "Explain how you can call 4GL procedures in Actian 4GL.",
        "document": [
            "# How You Can Call 4GL Procedures\n\nThe callproc statement lets you call a global 4GL procedure from any OpenROAD script or another 4GL procedure. You also use the callproc statement to call a local procedure defined in the current frame or procedure.\n\n## Basic Syntax\n\nIn the simplest version of the statement, you can call a procedure with no return value or parameters. The basic syntax is:\n\n```sql\ncallproc procedurename\n```\n\n### *procedurename*\n\nSpecifies the name that you gave to the 4GL procedure when you created it. You can enter the procedure name directly or you can use a variable to specify the procedure name dynamically. Using a variable lets you specify the procedure name at runtime.\n\nExample:\n```sql\ncallproc error_handler;\n```\n\nWhen the procedure returns a value, you must specify a variable in the calling frame or procedure to receive the return value. The return variable must be the same data type as the return value. The basic syntax is:\n\n```sql\n[return_variable =] callproc procedurename\n```\n\n## How You Can Pass Parameters to 4GL Procedures\n\nTo pass a value to a 4GL procedure in the callproc statement, you specify the name of the parameter in the 4GL procedure that is to receive the value. The basic syntax is:\n\n```sql\n[return_variable =] callproc procedurename [(parameter = expression {, parameter = expression})]\n```\n\n### *parameter*\n\nAssigns the expression in the callproc statement to the parameter in the called procedure that you declared with the procedure statement. For more information about declaring procedure parameters, see the *Language Reference Guide* online help.\n\nBecause you specify the parameters by name rather than by position, you can pass them in any order, and you need not pass all the parameters.\n\n### *expression*\n\nSpecifies a constant or any legal OpenROAD expression, as long as the resulting data type is compatible with the data type of the local variable in the procedure. Variables in the expression can be any type, including reference variables and array variables.\n\nExample:\n```sql\ncallproc remove_new_detail(new_details_frames = new_details_frames, details_frame = video.details_frame);\n```\n\nAny variable in the procedure that you do not specify in the parameter list is set to its default value.\n\nParameters to 4GL procedures can be passed by value and by reference. For a discussion of passing parameters by value and by reference, see How You Can Pass Parameters Between an Active Child and Inactive Parent.\n\nThe value of the referenced variable is not updated until the called procedure returns. At this point, the variable in the calling frame is updated the same way it would be if you had used an assignment statement. If a field on the form is associated with the variable, the field does not display the new value until the current event block completes. To cause the value to update before the end of the event block, you can use the Flush method immediately after the callproc statement. For more information about the Flush method, see the *Language Reference Guide* online help."
        ]
    },
    {
        "instruction": "Explain how you can pass multiple parameters when calling a 4GL procedure in Actian 4GL using an example.",
        "input": "",
        "output": "To pass multiple parameters to a 4GL procedure, separate each parameter with a comma and enclose them in parentheses. Within the procedure, you can then access these parameters by their respective names as defined when declaring the procedure. Here is an example: Suppose that you have a procedure called `calculate_total()` which takes two parameters: a list of numbers to be summed, and a target variable to store the resulting total. In Actian 4GL, you can call this procedure with multiple parameters as follows:\n```sql\nnumbers = [10, 20, 30, 40];\ntotal = 0;\ncallproc calculate_total(numbers = numbers, target = total);\n```\nIn the above example, `calculate_total()` will iterate over the `numbers` array and sum its values. The final result is stored in the `total` variable, which you pass as a parameter in the callproc statement.",
        "taxonomy_path": "knowledge->programming_languages->procedures->calling_procedures->call_4gl_procedures",
        "task_description": "Explain how you can call 4GL procedures in Actian 4GL.",
        "document": [
            "# How You Can Call 4GL Procedures\n\nThe callproc statement lets you call a global 4GL procedure from any OpenROAD script or another 4GL procedure. You also use the callproc statement to call a local procedure defined in the current frame or procedure.\n\n## Basic Syntax\n\nIn the simplest version of the statement, you can call a procedure with no return value or parameters. The basic syntax is:\n\n```sql\ncallproc procedurename\n```\n\n### *procedurename*\n\nSpecifies the name that you gave to the 4GL procedure when you created it. You can enter the procedure name directly or you can use a variable to specify the procedure name dynamically. Using a variable lets you specify the procedure name at runtime.\n\nExample:\n```sql\ncallproc error_handler;\n```\n\nWhen the procedure returns a value, you must specify a variable in the calling frame or procedure to receive the return value. The return variable must be the same data type as the return value. The basic syntax is:\n\n```sql\n[return_variable =] callproc procedurename\n```\n\n## How You Can Pass Parameters to 4GL Procedures\n\nTo pass a value to a 4GL procedure in the callproc statement, you specify the name of the parameter in the 4GL procedure that is to receive the value. The basic syntax is:\n\n```sql\n[return_variable =] callproc procedurename [(parameter = expression {, parameter = expression})]\n```\n\n### *parameter*\n\nAssigns the expression in the callproc statement to the parameter in the called procedure that you declared with the procedure statement. For more information about declaring procedure parameters, see the *Language Reference Guide* online help.\n\nBecause you specify the parameters by name rather than by position, you can pass them in any order, and you need not pass all the parameters.\n\n### *expression*\n\nSpecifies a constant or any legal OpenROAD expression, as long as the resulting data type is compatible with the data type of the local variable in the procedure. Variables in the expression can be any type, including reference variables and array variables.\n\nExample:\n```sql\ncallproc remove_new_detail(new_details_frames = new_details_frames, details_frame = video.details_frame);\n```\n\nAny variable in the procedure that you do not specify in the parameter list is set to its default value.\n\nParameters to 4GL procedures can be passed by value and by reference. For a discussion of passing parameters by value and by reference, see How You Can Pass Parameters Between an Active Child and Inactive Parent.\n\nThe value of the referenced variable is not updated until the called procedure returns. At this point, the variable in the calling frame is updated the same way it would be if you had used an assignment statement. If a field on the form is associated with the variable, the field does not display the new value until the current event block completes. To cause the value to update before the end of the event block, you can use the Flush method immediately after the callproc statement. For more information about the Flush method, see the *Language Reference Guide* online help."
        ]
    },
    {
        "instruction": "When using the callproc statement with parameters in Actian 4GL, how can you use local variables to reference the procedure's parameters?",
        "input": "",
        "output": "In Actian 4GL, you can declare and initialize a local variable to store the value of a parameter that is passed to a called procedure. To do so, use the same syntax as for passing parameters: specify the parameter name with an equals sign (`=`) followed by the expression representing the initial value of the local variable. For example, let's say you have a called procedure `increment_count()` which increments an input variable called `counter`. To use a local variable to reference the `counter` variable passed as a parameter in the callproc statement, create and initialize the local variable in your calling routine like this:\n```sql\nlocal counter_local = 0;\ncallproc increment_count(counter = counter_local);\n```\nIn this example, you declare the `counter_local` variable with an initial value of 0. The `increment_count()` procedure then increments its input variable `counter`, which refers to `counter_local`. After the callproc statement completes, the modified `counter_local` variable will contain the updated count.",
        "taxonomy_path": "knowledge->programming_languages->procedures->calling_procedures->call_4gl_procedures",
        "task_description": "Explain how you can call 4GL procedures in Actian 4GL.",
        "document": [
            "# How You Can Call 4GL Procedures\n\nThe callproc statement lets you call a global 4GL procedure from any OpenROAD script or another 4GL procedure. You also use the callproc statement to call a local procedure defined in the current frame or procedure.\n\n## Basic Syntax\n\nIn the simplest version of the statement, you can call a procedure with no return value or parameters. The basic syntax is:\n\n```sql\ncallproc procedurename\n```\n\n### *procedurename*\n\nSpecifies the name that you gave to the 4GL procedure when you created it. You can enter the procedure name directly or you can use a variable to specify the procedure name dynamically. Using a variable lets you specify the procedure name at runtime.\n\nExample:\n```sql\ncallproc error_handler;\n```\n\nWhen the procedure returns a value, you must specify a variable in the calling frame or procedure to receive the return value. The return variable must be the same data type as the return value. The basic syntax is:\n\n```sql\n[return_variable =] callproc procedurename\n```\n\n## How You Can Pass Parameters to 4GL Procedures\n\nTo pass a value to a 4GL procedure in the callproc statement, you specify the name of the parameter in the 4GL procedure that is to receive the value. The basic syntax is:\n\n```sql\n[return_variable =] callproc procedurename [(parameter = expression {, parameter = expression})]\n```\n\n### *parameter*\n\nAssigns the expression in the callproc statement to the parameter in the called procedure that you declared with the procedure statement. For more information about declaring procedure parameters, see the *Language Reference Guide* online help.\n\nBecause you specify the parameters by name rather than by position, you can pass them in any order, and you need not pass all the parameters.\n\n### *expression*\n\nSpecifies a constant or any legal OpenROAD expression, as long as the resulting data type is compatible with the data type of the local variable in the procedure. Variables in the expression can be any type, including reference variables and array variables.\n\nExample:\n```sql\ncallproc remove_new_detail(new_details_frames = new_details_frames, details_frame = video.details_frame);\n```\n\nAny variable in the procedure that you do not specify in the parameter list is set to its default value.\n\nParameters to 4GL procedures can be passed by value and by reference. For a discussion of passing parameters by value and by reference, see How You Can Pass Parameters Between an Active Child and Inactive Parent.\n\nThe value of the referenced variable is not updated until the called procedure returns. At this point, the variable in the calling frame is updated the same way it would be if you had used an assignment statement. If a field on the form is associated with the variable, the field does not display the new value until the current event block completes. To cause the value to update before the end of the event block, you can use the Flush method immediately after the callproc statement. For more information about the Flush method, see the *Language Reference Guide* online help."
        ]
    },
    {
        "instruction": "Can you provide an example of calling a 4GL procedure with parameters and return values?",
        "input": "",
        "output": "To pass values to a 4GL procedure and receive a return value, you can use the callproc statement as follows:\n```\nresult = callproc remove_new_detail(new_details_frames = new_details_frames, details_frame = video.details_frame)\n```\nIn this example, we are calling the \"remove\\_new\\_detail\" procedure and passing two parameters \"new\\_details\\_frames\" and \"details\\_frame\". The result of the operation is stored in a variable \"result\".",
        "taxonomy_path": "knowledge->programming_languages->procedures->calling_procedures->call_4gl_procedures",
        "task_description": "Explain how you can call 4GL procedures in Actian 4GL.",
        "document": [
            "# How You Can Call 4GL Procedures\n\nThe callproc statement lets you call a global 4GL procedure from any OpenROAD script or another 4GL procedure. You also use the callproc statement to call a local procedure defined in the current frame or procedure.\n\n## Basic Syntax\n\nIn the simplest version of the statement, you can call a procedure with no return value or parameters. The basic syntax is:\n\n```sql\ncallproc procedurename\n```\n\n### *procedurename*\n\nSpecifies the name that you gave to the 4GL procedure when you created it. You can enter the procedure name directly or you can use a variable to specify the procedure name dynamically. Using a variable lets you specify the procedure name at runtime.\n\nExample:\n```sql\ncallproc error_handler;\n```\n\nWhen the procedure returns a value, you must specify a variable in the calling frame or procedure to receive the return value. The return variable must be the same data type as the return value. The basic syntax is:\n\n```sql\n[return_variable =] callproc procedurename\n```\n\n## How You Can Pass Parameters to 4GL Procedures\n\nTo pass a value to a 4GL procedure in the callproc statement, you specify the name of the parameter in the 4GL procedure that is to receive the value. The basic syntax is:\n\n```sql\n[return_variable =] callproc procedurename [(parameter = expression {, parameter = expression})]\n```\n\n### *parameter*\n\nAssigns the expression in the callproc statement to the parameter in the called procedure that you declared with the procedure statement. For more information about declaring procedure parameters, see the *Language Reference Guide* online help.\n\nBecause you specify the parameters by name rather than by position, you can pass them in any order, and you need not pass all the parameters.\n\n### *expression*\n\nSpecifies a constant or any legal OpenROAD expression, as long as the resulting data type is compatible with the data type of the local variable in the procedure. Variables in the expression can be any type, including reference variables and array variables.\n\nExample:\n```sql\ncallproc remove_new_detail(new_details_frames = new_details_frames, details_frame = video.details_frame);\n```\n\nAny variable in the procedure that you do not specify in the parameter list is set to its default value.\n\nParameters to 4GL procedures can be passed by value and by reference. For a discussion of passing parameters by value and by reference, see How You Can Pass Parameters Between an Active Child and Inactive Parent.\n\nThe value of the referenced variable is not updated until the called procedure returns. At this point, the variable in the calling frame is updated the same way it would be if you had used an assignment statement. If a field on the form is associated with the variable, the field does not display the new value until the current event block completes. To cause the value to update before the end of the event block, you can use the Flush method immediately after the callproc statement. For more information about the Flush method, see the *Language Reference Guide* online help."
        ]
    },
    {
        "instruction": "Explain how to use variables dynamically in the callproc statement.",
        "input": "",
        "output": "Using variables to specify the procedure name dynamically lets you specify the procedure name at runtime. To do so, you can assign a variable to the procedure name in the callproc statement as follows:\n```\ncallproc %procedure_name;\n```\nIn this example, \"%procedure\\_name\" is a variable that contains the name of the procedure you want to call. This way, you can dynamically change the procedure name based on certain conditions or user input.",
        "taxonomy_path": "knowledge->programming_languages->procedures->calling_procedures->call_4gl_procedures",
        "task_description": "Explain how you can call 4GL procedures in Actian 4GL.",
        "document": [
            "# How You Can Call 4GL Procedures\n\nThe callproc statement lets you call a global 4GL procedure from any OpenROAD script or another 4GL procedure. You also use the callproc statement to call a local procedure defined in the current frame or procedure.\n\n## Basic Syntax\n\nIn the simplest version of the statement, you can call a procedure with no return value or parameters. The basic syntax is:\n\n```sql\ncallproc procedurename\n```\n\n### *procedurename*\n\nSpecifies the name that you gave to the 4GL procedure when you created it. You can enter the procedure name directly or you can use a variable to specify the procedure name dynamically. Using a variable lets you specify the procedure name at runtime.\n\nExample:\n```sql\ncallproc error_handler;\n```\n\nWhen the procedure returns a value, you must specify a variable in the calling frame or procedure to receive the return value. The return variable must be the same data type as the return value. The basic syntax is:\n\n```sql\n[return_variable =] callproc procedurename\n```\n\n## How You Can Pass Parameters to 4GL Procedures\n\nTo pass a value to a 4GL procedure in the callproc statement, you specify the name of the parameter in the 4GL procedure that is to receive the value. The basic syntax is:\n\n```sql\n[return_variable =] callproc procedurename [(parameter = expression {, parameter = expression})]\n```\n\n### *parameter*\n\nAssigns the expression in the callproc statement to the parameter in the called procedure that you declared with the procedure statement. For more information about declaring procedure parameters, see the *Language Reference Guide* online help.\n\nBecause you specify the parameters by name rather than by position, you can pass them in any order, and you need not pass all the parameters.\n\n### *expression*\n\nSpecifies a constant or any legal OpenROAD expression, as long as the resulting data type is compatible with the data type of the local variable in the procedure. Variables in the expression can be any type, including reference variables and array variables.\n\nExample:\n```sql\ncallproc remove_new_detail(new_details_frames = new_details_frames, details_frame = video.details_frame);\n```\n\nAny variable in the procedure that you do not specify in the parameter list is set to its default value.\n\nParameters to 4GL procedures can be passed by value and by reference. For a discussion of passing parameters by value and by reference, see How You Can Pass Parameters Between an Active Child and Inactive Parent.\n\nThe value of the referenced variable is not updated until the called procedure returns. At this point, the variable in the calling frame is updated the same way it would be if you had used an assignment statement. If a field on the form is associated with the variable, the field does not display the new value until the current event block completes. To cause the value to update before the end of the event block, you can use the Flush method immediately after the callproc statement. For more information about the Flush method, see the *Language Reference Guide* online help."
        ]
    },
    {
        "instruction": "What should be the data type of return variable when calling a 4GL procedure with return value?",
        "input": "",
        "output": "The return variable must be the same data type as the return value.",
        "taxonomy_path": "knowledge->programming_languages->procedures->calling_procedures->call_4gl_procedures",
        "task_description": "Explain how you can call 4GL procedures in Actian 4GL.",
        "document": [
            "# How You Can Call 4GL Procedures\n\nThe callproc statement lets you call a global 4GL procedure from any OpenROAD script or another 4GL procedure. You also use the callproc statement to call a local procedure defined in the current frame or procedure.\n\n## Basic Syntax\n\nIn the simplest version of the statement, you can call a procedure with no return value or parameters. The basic syntax is:\n\n```sql\ncallproc procedurename\n```\n\n### *procedurename*\n\nSpecifies the name that you gave to the 4GL procedure when you created it. You can enter the procedure name directly or you can use a variable to specify the procedure name dynamically. Using a variable lets you specify the procedure name at runtime.\n\nExample:\n```sql\ncallproc error_handler;\n```\n\nWhen the procedure returns a value, you must specify a variable in the calling frame or procedure to receive the return value. The return variable must be the same data type as the return value. The basic syntax is:\n\n```sql\n[return_variable =] callproc procedurename\n```\n\n## How You Can Pass Parameters to 4GL Procedures\n\nTo pass a value to a 4GL procedure in the callproc statement, you specify the name of the parameter in the 4GL procedure that is to receive the value. The basic syntax is:\n\n```sql\n[return_variable =] callproc procedurename [(parameter = expression {, parameter = expression})]\n```\n\n### *parameter*\n\nAssigns the expression in the callproc statement to the parameter in the called procedure that you declared with the procedure statement. For more information about declaring procedure parameters, see the *Language Reference Guide* online help.\n\nBecause you specify the parameters by name rather than by position, you can pass them in any order, and you need not pass all the parameters.\n\n### *expression*\n\nSpecifies a constant or any legal OpenROAD expression, as long as the resulting data type is compatible with the data type of the local variable in the procedure. Variables in the expression can be any type, including reference variables and array variables.\n\nExample:\n```sql\ncallproc remove_new_detail(new_details_frames = new_details_frames, details_frame = video.details_frame);\n```\n\nAny variable in the procedure that you do not specify in the parameter list is set to its default value.\n\nParameters to 4GL procedures can be passed by value and by reference. For a discussion of passing parameters by value and by reference, see How You Can Pass Parameters Between an Active Child and Inactive Parent.\n\nThe value of the referenced variable is not updated until the called procedure returns. At this point, the variable in the calling frame is updated the same way it would be if you had used an assignment statement. If a field on the form is associated with the variable, the field does not display the new value until the current event block completes. To cause the value to update before the end of the event block, you can use the Flush method immediately after the callproc statement. For more information about the Flush method, see the *Language Reference Guide* online help."
        ]
    },
    {
        "instruction": "What happens if you do not specify a variable to receive the return value when calling a 4GL procedure with a return value?",
        "input": "",
        "output": "When the procedure returns a value and no variable is specified in the call, there will be no mechanism to capture or use that returned value. It will be lost. To avoid this, it's best practice to always specify a variable for receiving the return value.",
        "taxonomy_path": "knowledge->programming_languages->procedures->calling_procedures->call_4gl_procedures",
        "task_description": "Explain how you can call 4GL procedures in Actian 4GL.",
        "document": [
            "# How You Can Call 4GL Procedures\n\nThe callproc statement lets you call a global 4GL procedure from any OpenROAD script or another 4GL procedure. You also use the callproc statement to call a local procedure defined in the current frame or procedure.\n\n## Basic Syntax\n\nIn the simplest version of the statement, you can call a procedure with no return value or parameters. The basic syntax is:\n\n```sql\ncallproc procedurename\n```\n\n### *procedurename*\n\nSpecifies the name that you gave to the 4GL procedure when you created it. You can enter the procedure name directly or you can use a variable to specify the procedure name dynamically. Using a variable lets you specify the procedure name at runtime.\n\nExample:\n```sql\ncallproc error_handler;\n```\n\nWhen the procedure returns a value, you must specify a variable in the calling frame or procedure to receive the return value. The return variable must be the same data type as the return value. The basic syntax is:\n\n```sql\n[return_variable =] callproc procedurename\n```\n\n## How You Can Pass Parameters to 4GL Procedures\n\nTo pass a value to a 4GL procedure in the callproc statement, you specify the name of the parameter in the 4GL procedure that is to receive the value. The basic syntax is:\n\n```sql\n[return_variable =] callproc procedurename [(parameter = expression {, parameter = expression})]\n```\n\n### *parameter*\n\nAssigns the expression in the callproc statement to the parameter in the called procedure that you declared with the procedure statement. For more information about declaring procedure parameters, see the *Language Reference Guide* online help.\n\nBecause you specify the parameters by name rather than by position, you can pass them in any order, and you need not pass all the parameters.\n\n### *expression*\n\nSpecifies a constant or any legal OpenROAD expression, as long as the resulting data type is compatible with the data type of the local variable in the procedure. Variables in the expression can be any type, including reference variables and array variables.\n\nExample:\n```sql\ncallproc remove_new_detail(new_details_frames = new_details_frames, details_frame = video.details_frame);\n```\n\nAny variable in the procedure that you do not specify in the parameter list is set to its default value.\n\nParameters to 4GL procedures can be passed by value and by reference. For a discussion of passing parameters by value and by reference, see How You Can Pass Parameters Between an Active Child and Inactive Parent.\n\nThe value of the referenced variable is not updated until the called procedure returns. At this point, the variable in the calling frame is updated the same way it would be if you had used an assignment statement. If a field on the form is associated with the variable, the field does not display the new value until the current event block completes. To cause the value to update before the end of the event block, you can use the Flush method immediately after the callproc statement. For more information about the Flush method, see the *Language Reference Guide* online help."
        ]
    },
    {
        "instruction": "What is meant by passing parameters \"by reference\" in the context of Actian 4GL procedures?",
        "input": "",
        "output": "In the context of Actian 4GL procedures, passing parameters \"by reference\" means that a pointer to the memory location of the variable in the calling routine is passed to the procedure. Any changes made to the value of the parameter within the procedure will reflect in the original variable when the procedure returns. This allows for more efficient usage and modification of variables in the calling routine from within the procedure.",
        "taxonomy_path": "knowledge->programming_languages->procedures->calling_procedures->call_4gl_procedures",
        "task_description": "Explain how you can call 4GL procedures in Actian 4GL.",
        "document": [
            "# How You Can Call 4GL Procedures\n\nThe callproc statement lets you call a global 4GL procedure from any OpenROAD script or another 4GL procedure. You also use the callproc statement to call a local procedure defined in the current frame or procedure.\n\n## Basic Syntax\n\nIn the simplest version of the statement, you can call a procedure with no return value or parameters. The basic syntax is:\n\n```sql\ncallproc procedurename\n```\n\n### *procedurename*\n\nSpecifies the name that you gave to the 4GL procedure when you created it. You can enter the procedure name directly or you can use a variable to specify the procedure name dynamically. Using a variable lets you specify the procedure name at runtime.\n\nExample:\n```sql\ncallproc error_handler;\n```\n\nWhen the procedure returns a value, you must specify a variable in the calling frame or procedure to receive the return value. The return variable must be the same data type as the return value. The basic syntax is:\n\n```sql\n[return_variable =] callproc procedurename\n```\n\n## How You Can Pass Parameters to 4GL Procedures\n\nTo pass a value to a 4GL procedure in the callproc statement, you specify the name of the parameter in the 4GL procedure that is to receive the value. The basic syntax is:\n\n```sql\n[return_variable =] callproc procedurename [(parameter = expression {, parameter = expression})]\n```\n\n### *parameter*\n\nAssigns the expression in the callproc statement to the parameter in the called procedure that you declared with the procedure statement. For more information about declaring procedure parameters, see the *Language Reference Guide* online help.\n\nBecause you specify the parameters by name rather than by position, you can pass them in any order, and you need not pass all the parameters.\n\n### *expression*\n\nSpecifies a constant or any legal OpenROAD expression, as long as the resulting data type is compatible with the data type of the local variable in the procedure. Variables in the expression can be any type, including reference variables and array variables.\n\nExample:\n```sql\ncallproc remove_new_detail(new_details_frames = new_details_frames, details_frame = video.details_frame);\n```\n\nAny variable in the procedure that you do not specify in the parameter list is set to its default value.\n\nParameters to 4GL procedures can be passed by value and by reference. For a discussion of passing parameters by value and by reference, see How You Can Pass Parameters Between an Active Child and Inactive Parent.\n\nThe value of the referenced variable is not updated until the called procedure returns. At this point, the variable in the calling frame is updated the same way it would be if you had used an assignment statement. If a field on the form is associated with the variable, the field does not display the new value until the current event block completes. To cause the value to update before the end of the event block, you can use the Flush method immediately after the callproc statement. For more information about the Flush method, see the *Language Reference Guide* online help."
        ]
    },
    {
        "instruction": "Explain how you can pass parameters to a 4GL procedure by reference.",
        "input": "",
        "output": "In Actian 4GL, you can pass parameters by reference by specifying the parameter's variable as `@` (pointer or reference) in the callproc statement. The basic syntax for this is:\n```sql\n[return_variable =] callproc procedurename[(parameter = @var)]\n```\nHere, `var` refers to the name of the local variable in the calling frame that stores the address (or pointer) to the memory location where the parameter exists. When using a pointer or reference variable as a parameter, any changes made within the called procedure are reflected back in the original variable without the need for a return value.",
        "taxonomy_path": "knowledge->programming_languages->procedures->calling_procedures->call_4gl_procedures",
        "task_description": "Explain how you can call 4GL procedures in Actian 4GL.",
        "document": [
            "# How You Can Call 4GL Procedures\n\nThe callproc statement lets you call a global 4GL procedure from any OpenROAD script or another 4GL procedure. You also use the callproc statement to call a local procedure defined in the current frame or procedure.\n\n## Basic Syntax\n\nIn the simplest version of the statement, you can call a procedure with no return value or parameters. The basic syntax is:\n\n```sql\ncallproc procedurename\n```\n\n### *procedurename*\n\nSpecifies the name that you gave to the 4GL procedure when you created it. You can enter the procedure name directly or you can use a variable to specify the procedure name dynamically. Using a variable lets you specify the procedure name at runtime.\n\nExample:\n```sql\ncallproc error_handler;\n```\n\nWhen the procedure returns a value, you must specify a variable in the calling frame or procedure to receive the return value. The return variable must be the same data type as the return value. The basic syntax is:\n\n```sql\n[return_variable =] callproc procedurename\n```\n\n## How You Can Pass Parameters to 4GL Procedures\n\nTo pass a value to a 4GL procedure in the callproc statement, you specify the name of the parameter in the 4GL procedure that is to receive the value. The basic syntax is:\n\n```sql\n[return_variable =] callproc procedurename [(parameter = expression {, parameter = expression})]\n```\n\n### *parameter*\n\nAssigns the expression in the callproc statement to the parameter in the called procedure that you declared with the procedure statement. For more information about declaring procedure parameters, see the *Language Reference Guide* online help.\n\nBecause you specify the parameters by name rather than by position, you can pass them in any order, and you need not pass all the parameters.\n\n### *expression*\n\nSpecifies a constant or any legal OpenROAD expression, as long as the resulting data type is compatible with the data type of the local variable in the procedure. Variables in the expression can be any type, including reference variables and array variables.\n\nExample:\n```sql\ncallproc remove_new_detail(new_details_frames = new_details_frames, details_frame = video.details_frame);\n```\n\nAny variable in the procedure that you do not specify in the parameter list is set to its default value.\n\nParameters to 4GL procedures can be passed by value and by reference. For a discussion of passing parameters by value and by reference, see How You Can Pass Parameters Between an Active Child and Inactive Parent.\n\nThe value of the referenced variable is not updated until the called procedure returns. At this point, the variable in the calling frame is updated the same way it would be if you had used an assignment statement. If a field on the form is associated with the variable, the field does not display the new value until the current event block completes. To cause the value to update before the end of the event block, you can use the Flush method immediately after the callproc statement. For more information about the Flush method, see the *Language Reference Guide* online help."
        ]
    },
    {
        "instruction": "What is the role of a return variable in callproc statements when returning a value from a 4GL procedure?",
        "input": "",
        "output": "A return variable is used to capture and store the result returned by a 4GL procedure that has an explicit `RETURN` statement in its code. You assign this variable on the calling side as part of the callproc statement, like so:\n```sql\n[return_variable =] callproc some_procedure([parameters]);\n```\nIn the example above, if `some_procedure` has a return value, it will be stored in the specified return variable, allowing you to use its contents later in your program.",
        "taxonomy_path": "knowledge->programming_languages->procedures->calling_procedures->call_4gl_procedures",
        "task_description": "Explain how you can call 4GL procedures in Actian 4GL.",
        "document": [
            "# How You Can Call 4GL Procedures\n\nThe callproc statement lets you call a global 4GL procedure from any OpenROAD script or another 4GL procedure. You also use the callproc statement to call a local procedure defined in the current frame or procedure.\n\n## Basic Syntax\n\nIn the simplest version of the statement, you can call a procedure with no return value or parameters. The basic syntax is:\n\n```sql\ncallproc procedurename\n```\n\n### *procedurename*\n\nSpecifies the name that you gave to the 4GL procedure when you created it. You can enter the procedure name directly or you can use a variable to specify the procedure name dynamically. Using a variable lets you specify the procedure name at runtime.\n\nExample:\n```sql\ncallproc error_handler;\n```\n\nWhen the procedure returns a value, you must specify a variable in the calling frame or procedure to receive the return value. The return variable must be the same data type as the return value. The basic syntax is:\n\n```sql\n[return_variable =] callproc procedurename\n```\n\n## How You Can Pass Parameters to 4GL Procedures\n\nTo pass a value to a 4GL procedure in the callproc statement, you specify the name of the parameter in the 4GL procedure that is to receive the value. The basic syntax is:\n\n```sql\n[return_variable =] callproc procedurename [(parameter = expression {, parameter = expression})]\n```\n\n### *parameter*\n\nAssigns the expression in the callproc statement to the parameter in the called procedure that you declared with the procedure statement. For more information about declaring procedure parameters, see the *Language Reference Guide* online help.\n\nBecause you specify the parameters by name rather than by position, you can pass them in any order, and you need not pass all the parameters.\n\n### *expression*\n\nSpecifies a constant or any legal OpenROAD expression, as long as the resulting data type is compatible with the data type of the local variable in the procedure. Variables in the expression can be any type, including reference variables and array variables.\n\nExample:\n```sql\ncallproc remove_new_detail(new_details_frames = new_details_frames, details_frame = video.details_frame);\n```\n\nAny variable in the procedure that you do not specify in the parameter list is set to its default value.\n\nParameters to 4GL procedures can be passed by value and by reference. For a discussion of passing parameters by value and by reference, see How You Can Pass Parameters Between an Active Child and Inactive Parent.\n\nThe value of the referenced variable is not updated until the called procedure returns. At this point, the variable in the calling frame is updated the same way it would be if you had used an assignment statement. If a field on the form is associated with the variable, the field does not display the new value until the current event block completes. To cause the value to update before the end of the event block, you can use the Flush method immediately after the callproc statement. For more information about the Flush method, see the *Language Reference Guide* online help."
        ]
    },
    {
        "instruction": "What should be considered when passing parameters to 4GL procedures in callproc statements?",
        "input": "",
        "output": "When passing parameters to 4GL procedures in Actian 4GL using the `callproc` statement, consider the following:\n1. The name of the parameter in the 4GL procedure being called should be specified in the `callproc` statement. This allows you to pass values dynamically and out of order.\n2. Expressions used to assign parameters must match the data type of the local variable defined in the procedure.\n3. Any variables not explicitly passed will retain their default values.\n4. Parameters can be passed by value or by reference, depending on the nature of the data being manipulated.\n5. To pass parameters by value, use the basic syntax:\n```sql\n[return_variable =] callproc procedurename [(parameter = expression {, parameter = expression})]\n```\n6. To pass parameters by reference, do not include the address operator (&) or reference sign (^) in the `callproc` statement. The referenced variable will be updated when the called procedure returns and the variable value can be retrieved in the calling frame as usual.\n7. Using the Flush method after a callproc statement with reference variables updates the screen without waiting for the current event block to complete, ensuring changes are visible immediately.",
        "taxonomy_path": "knowledge->programming_languages->procedures->calling_procedures->call_4gl_procedures",
        "task_description": "Explain how you can call 4GL procedures in Actian 4GL.",
        "document": [
            "# How You Can Call 4GL Procedures\n\nThe callproc statement lets you call a global 4GL procedure from any OpenROAD script or another 4GL procedure. You also use the callproc statement to call a local procedure defined in the current frame or procedure.\n\n## Basic Syntax\n\nIn the simplest version of the statement, you can call a procedure with no return value or parameters. The basic syntax is:\n\n```sql\ncallproc procedurename\n```\n\n### *procedurename*\n\nSpecifies the name that you gave to the 4GL procedure when you created it. You can enter the procedure name directly or you can use a variable to specify the procedure name dynamically. Using a variable lets you specify the procedure name at runtime.\n\nExample:\n```sql\ncallproc error_handler;\n```\n\nWhen the procedure returns a value, you must specify a variable in the calling frame or procedure to receive the return value. The return variable must be the same data type as the return value. The basic syntax is:\n\n```sql\n[return_variable =] callproc procedurename\n```\n\n## How You Can Pass Parameters to 4GL Procedures\n\nTo pass a value to a 4GL procedure in the callproc statement, you specify the name of the parameter in the 4GL procedure that is to receive the value. The basic syntax is:\n\n```sql\n[return_variable =] callproc procedurename [(parameter = expression {, parameter = expression})]\n```\n\n### *parameter*\n\nAssigns the expression in the callproc statement to the parameter in the called procedure that you declared with the procedure statement. For more information about declaring procedure parameters, see the *Language Reference Guide* online help.\n\nBecause you specify the parameters by name rather than by position, you can pass them in any order, and you need not pass all the parameters.\n\n### *expression*\n\nSpecifies a constant or any legal OpenROAD expression, as long as the resulting data type is compatible with the data type of the local variable in the procedure. Variables in the expression can be any type, including reference variables and array variables.\n\nExample:\n```sql\ncallproc remove_new_detail(new_details_frames = new_details_frames, details_frame = video.details_frame);\n```\n\nAny variable in the procedure that you do not specify in the parameter list is set to its default value.\n\nParameters to 4GL procedures can be passed by value and by reference. For a discussion of passing parameters by value and by reference, see How You Can Pass Parameters Between an Active Child and Inactive Parent.\n\nThe value of the referenced variable is not updated until the called procedure returns. At this point, the variable in the calling frame is updated the same way it would be if you had used an assignment statement. If a field on the form is associated with the variable, the field does not display the new value until the current event block completes. To cause the value to update before the end of the event block, you can use the Flush method immediately after the callproc statement. For more information about the Flush method, see the *Language Reference Guide* online help."
        ]
    },
    {
        "instruction": "Explain with an example how you can pass multiple parameters to a 4GL procedure in Actian 4GL using callproc statement.",
        "input": "",
        "output": "To pass multiple parameters to a 4GL procedure in Actian 4GL using the callproc statement, enclose them within parentheses and assign each parameter to its corresponding name as declared in the called procedure using an equal sign (=). Here's an example:\n\n```sql\ncallproc calculate_total(quantity = 5, price = 10.5)\n```\n\nIn this case, the callproc statement calls a procedure named \"calculate\\_total\" with two parameters - \"quantity\" and \"price\". The values 5 and 10.5 are passed respectively for these parameters from the calling routine. The actual implementation of the \"calculate\\_total\" procedure may involve arithmetic operations to compute a total based on the provided input values, as per its declared logic.",
        "taxonomy_path": "knowledge->programming_languages->procedures->calling_procedures->call_4gl_procedures",
        "task_description": "Explain how you can call 4GL procedures in Actian 4GL.",
        "document": [
            "# How You Can Call 4GL Procedures\n\nThe callproc statement lets you call a global 4GL procedure from any OpenROAD script or another 4GL procedure. You also use the callproc statement to call a local procedure defined in the current frame or procedure.\n\n## Basic Syntax\n\nIn the simplest version of the statement, you can call a procedure with no return value or parameters. The basic syntax is:\n\n```sql\ncallproc procedurename\n```\n\n### *procedurename*\n\nSpecifies the name that you gave to the 4GL procedure when you created it. You can enter the procedure name directly or you can use a variable to specify the procedure name dynamically. Using a variable lets you specify the procedure name at runtime.\n\nExample:\n```sql\ncallproc error_handler;\n```\n\nWhen the procedure returns a value, you must specify a variable in the calling frame or procedure to receive the return value. The return variable must be the same data type as the return value. The basic syntax is:\n\n```sql\n[return_variable =] callproc procedurename\n```\n\n## How You Can Pass Parameters to 4GL Procedures\n\nTo pass a value to a 4GL procedure in the callproc statement, you specify the name of the parameter in the 4GL procedure that is to receive the value. The basic syntax is:\n\n```sql\n[return_variable =] callproc procedurename [(parameter = expression {, parameter = expression})]\n```\n\n### *parameter*\n\nAssigns the expression in the callproc statement to the parameter in the called procedure that you declared with the procedure statement. For more information about declaring procedure parameters, see the *Language Reference Guide* online help.\n\nBecause you specify the parameters by name rather than by position, you can pass them in any order, and you need not pass all the parameters.\n\n### *expression*\n\nSpecifies a constant or any legal OpenROAD expression, as long as the resulting data type is compatible with the data type of the local variable in the procedure. Variables in the expression can be any type, including reference variables and array variables.\n\nExample:\n```sql\ncallproc remove_new_detail(new_details_frames = new_details_frames, details_frame = video.details_frame);\n```\n\nAny variable in the procedure that you do not specify in the parameter list is set to its default value.\n\nParameters to 4GL procedures can be passed by value and by reference. For a discussion of passing parameters by value and by reference, see How You Can Pass Parameters Between an Active Child and Inactive Parent.\n\nThe value of the referenced variable is not updated until the called procedure returns. At this point, the variable in the calling frame is updated the same way it would be if you had used an assignment statement. If a field on the form is associated with the variable, the field does not display the new value until the current event block completes. To cause the value to update before the end of the event block, you can use the Flush method immediately after the callproc statement. For more information about the Flush method, see the *Language Reference Guide* online help."
        ]
    },
    {
        "instruction": "What is the purpose of using the Flush method when passing parameters by reference in Actian 4GL procedures?",
        "input": "",
        "output": "The purpose of using the Flush method when passing parameters by reference in Actian 4GL procedures is to force an immediate update of the variable in the calling routine. Since any changes made to a variable passed by reference within a procedure are not immediately visible, using the Flush method ensures that these changes will reflect in the calling routine before the current event block ends. This can help avoid situations where values might be lost or not displayed correctly due to being updated at an inappropriate time.",
        "taxonomy_path": "knowledge->programming_languages->procedures->calling_procedures->call_4gl_procedures",
        "task_description": "Explain how you can call 4GL procedures in Actian 4GL.",
        "document": [
            "# How You Can Call 4GL Procedures\n\nThe callproc statement lets you call a global 4GL procedure from any OpenROAD script or another 4GL procedure. You also use the callproc statement to call a local procedure defined in the current frame or procedure.\n\n## Basic Syntax\n\nIn the simplest version of the statement, you can call a procedure with no return value or parameters. The basic syntax is:\n\n```sql\ncallproc procedurename\n```\n\n### *procedurename*\n\nSpecifies the name that you gave to the 4GL procedure when you created it. You can enter the procedure name directly or you can use a variable to specify the procedure name dynamically. Using a variable lets you specify the procedure name at runtime.\n\nExample:\n```sql\ncallproc error_handler;\n```\n\nWhen the procedure returns a value, you must specify a variable in the calling frame or procedure to receive the return value. The return variable must be the same data type as the return value. The basic syntax is:\n\n```sql\n[return_variable =] callproc procedurename\n```\n\n## How You Can Pass Parameters to 4GL Procedures\n\nTo pass a value to a 4GL procedure in the callproc statement, you specify the name of the parameter in the 4GL procedure that is to receive the value. The basic syntax is:\n\n```sql\n[return_variable =] callproc procedurename [(parameter = expression {, parameter = expression})]\n```\n\n### *parameter*\n\nAssigns the expression in the callproc statement to the parameter in the called procedure that you declared with the procedure statement. For more information about declaring procedure parameters, see the *Language Reference Guide* online help.\n\nBecause you specify the parameters by name rather than by position, you can pass them in any order, and you need not pass all the parameters.\n\n### *expression*\n\nSpecifies a constant or any legal OpenROAD expression, as long as the resulting data type is compatible with the data type of the local variable in the procedure. Variables in the expression can be any type, including reference variables and array variables.\n\nExample:\n```sql\ncallproc remove_new_detail(new_details_frames = new_details_frames, details_frame = video.details_frame);\n```\n\nAny variable in the procedure that you do not specify in the parameter list is set to its default value.\n\nParameters to 4GL procedures can be passed by value and by reference. For a discussion of passing parameters by value and by reference, see How You Can Pass Parameters Between an Active Child and Inactive Parent.\n\nThe value of the referenced variable is not updated until the called procedure returns. At this point, the variable in the calling frame is updated the same way it would be if you had used an assignment statement. If a field on the form is associated with the variable, the field does not display the new value until the current event block completes. To cause the value to update before the end of the event block, you can use the Flush method immediately after the callproc statement. For more information about the Flush method, see the *Language Reference Guide* online help."
        ]
    },
    {
        "instruction": "How can you pass parameters to a 4GL procedure using callproc statements?",
        "input": "",
        "output": "To pass a value to a 4GL procedure in the callproc statement, you specify the name of the parameter in the 4GL procedure that is to receive the value. The basic syntax is:\n```sql\n[return_variable =] callproc procedurename [(parameter = expression {, parameter = expression})]\n```\nIn this example, `parameter` assigns the expression in the callproc statement to the corresponding parameter in the called procedure, allowing you to pass values into your 4GL procedures dynamically. The syntax allows for flexibility in terms of parameter order and the omission of parameters if not necessary.",
        "taxonomy_path": "knowledge->programming_languages->procedures->calling_procedures->call_4gl_procedures",
        "task_description": "Explain how you can call 4GL procedures in Actian 4GL.",
        "document": [
            "# How You Can Call 4GL Procedures\n\nThe callproc statement lets you call a global 4GL procedure from any OpenROAD script or another 4GL procedure. You also use the callproc statement to call a local procedure defined in the current frame or procedure.\n\n## Basic Syntax\n\nIn the simplest version of the statement, you can call a procedure with no return value or parameters. The basic syntax is:\n\n```sql\ncallproc procedurename\n```\n\n### *procedurename*\n\nSpecifies the name that you gave to the 4GL procedure when you created it. You can enter the procedure name directly or you can use a variable to specify the procedure name dynamically. Using a variable lets you specify the procedure name at runtime.\n\nExample:\n```sql\ncallproc error_handler;\n```\n\nWhen the procedure returns a value, you must specify a variable in the calling frame or procedure to receive the return value. The return variable must be the same data type as the return value. The basic syntax is:\n\n```sql\n[return_variable =] callproc procedurename\n```\n\n## How You Can Pass Parameters to 4GL Procedures\n\nTo pass a value to a 4GL procedure in the callproc statement, you specify the name of the parameter in the 4GL procedure that is to receive the value. The basic syntax is:\n\n```sql\n[return_variable =] callproc procedurename [(parameter = expression {, parameter = expression})]\n```\n\n### *parameter*\n\nAssigns the expression in the callproc statement to the parameter in the called procedure that you declared with the procedure statement. For more information about declaring procedure parameters, see the *Language Reference Guide* online help.\n\nBecause you specify the parameters by name rather than by position, you can pass them in any order, and you need not pass all the parameters.\n\n### *expression*\n\nSpecifies a constant or any legal OpenROAD expression, as long as the resulting data type is compatible with the data type of the local variable in the procedure. Variables in the expression can be any type, including reference variables and array variables.\n\nExample:\n```sql\ncallproc remove_new_detail(new_details_frames = new_details_frames, details_frame = video.details_frame);\n```\n\nAny variable in the procedure that you do not specify in the parameter list is set to its default value.\n\nParameters to 4GL procedures can be passed by value and by reference. For a discussion of passing parameters by value and by reference, see How You Can Pass Parameters Between an Active Child and Inactive Parent.\n\nThe value of the referenced variable is not updated until the called procedure returns. At this point, the variable in the calling frame is updated the same way it would be if you had used an assignment statement. If a field on the form is associated with the variable, the field does not display the new value until the current event block completes. To cause the value to update before the end of the event block, you can use the Flush method immediately after the callproc statement. For more information about the Flush method, see the *Language Reference Guide* online help."
        ]
    },
    {
        "instruction": "What is the impact of passing a variable by reference in callproc statements compared to passing it by value?",
        "input": "",
        "output": "Passing a variable by reference in callproc statements allows the called procedure to directly manipulate the original variable in the calling function. This means that any changes made to the variable within the procedure will be reflected in the calling function after the procedure returns. On the other hand, passing a variable by value creates a copy of the variable and any changes made to this copy only affect the local version of the variable within the called procedure. The original variable remains unchanged when the call to the procedure completes.",
        "taxonomy_path": "knowledge->programming_languages->procedures->calling_procedures->call_4gl_procedures",
        "task_description": "Explain how you can call 4GL procedures in Actian 4GL.",
        "document": [
            "# How You Can Call 4GL Procedures\n\nThe callproc statement lets you call a global 4GL procedure from any OpenROAD script or another 4GL procedure. You also use the callproc statement to call a local procedure defined in the current frame or procedure.\n\n## Basic Syntax\n\nIn the simplest version of the statement, you can call a procedure with no return value or parameters. The basic syntax is:\n\n```sql\ncallproc procedurename\n```\n\n### *procedurename*\n\nSpecifies the name that you gave to the 4GL procedure when you created it. You can enter the procedure name directly or you can use a variable to specify the procedure name dynamically. Using a variable lets you specify the procedure name at runtime.\n\nExample:\n```sql\ncallproc error_handler;\n```\n\nWhen the procedure returns a value, you must specify a variable in the calling frame or procedure to receive the return value. The return variable must be the same data type as the return value. The basic syntax is:\n\n```sql\n[return_variable =] callproc procedurename\n```\n\n## How You Can Pass Parameters to 4GL Procedures\n\nTo pass a value to a 4GL procedure in the callproc statement, you specify the name of the parameter in the 4GL procedure that is to receive the value. The basic syntax is:\n\n```sql\n[return_variable =] callproc procedurename [(parameter = expression {, parameter = expression})]\n```\n\n### *parameter*\n\nAssigns the expression in the callproc statement to the parameter in the called procedure that you declared with the procedure statement. For more information about declaring procedure parameters, see the *Language Reference Guide* online help.\n\nBecause you specify the parameters by name rather than by position, you can pass them in any order, and you need not pass all the parameters.\n\n### *expression*\n\nSpecifies a constant or any legal OpenROAD expression, as long as the resulting data type is compatible with the data type of the local variable in the procedure. Variables in the expression can be any type, including reference variables and array variables.\n\nExample:\n```sql\ncallproc remove_new_detail(new_details_frames = new_details_frames, details_frame = video.details_frame);\n```\n\nAny variable in the procedure that you do not specify in the parameter list is set to its default value.\n\nParameters to 4GL procedures can be passed by value and by reference. For a discussion of passing parameters by value and by reference, see How You Can Pass Parameters Between an Active Child and Inactive Parent.\n\nThe value of the referenced variable is not updated until the called procedure returns. At this point, the variable in the calling frame is updated the same way it would be if you had used an assignment statement. If a field on the form is associated with the variable, the field does not display the new value until the current event block completes. To cause the value to update before the end of the event block, you can use the Flush method immediately after the callproc statement. For more information about the Flush method, see the *Language Reference Guide* online help."
        ]
    }
]