[
    {
        "instruction": "Can you explain how to declare parameters for a procedure in OpenROAD?",
        "input": "",
        "output": "In OpenROAD, when declaring parameters for a 4GL procedure, you specify them within the brackets after the procname. A parameter can be any simple data type acceptable to OpenROAD or any named user class or system class. If a procedure has no parameters, the parentheses are optional.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->global_procedures",
        "task_description": "Explain the features and creation process of global procedures in Actian 4GL SQL.",
        "document": [
            "# Global Procedures\n\nA *global 4GL procedure* is a routine written in 4GL that you can call by name from a script or another procedure. The procedure is a component of an application and is stored in the application's database.\n\nTo create a global 4GL procedure, use the OpenROAD Workbench to name the procedure and declare its return value. You then write the actual procedure statement in 4GL. The following section describes this statement. For more information about creating 4GL procedures, see the *Workbench User Guide*.\n\n## Procedure Statement\n\nThe *procedure statement* defines a 4GL procedure. This statement declares the parameters for the procedure and provides the actual processing statements. The syntax for a global 4GL procedure is:\n\n```\nprocedure procname [([parameterlist])] = \n[declare \n    [localvariablelist]\n    [localprocedureforwardreferences]\nenddeclare]\nbegin \n    statementlist\nend\n[;] {localprocedure[;]}\n```\n\n### procname\nSpecifies the procedure name. You use this name when you call the procedure in the application.\n\n### parameterlist\nSpecifies parameters that are passed to the procedure. You can also use a parameter as a local variable within the procedure. A 4GL procedure can have any number of parameters.\n\nA parameter can be any simple data type acceptable to OpenROAD or any named user class or system class. If a procedure has no parameters, the parentheses are optional.\n\nFor more information about the declare block, see Initialize Statement.\n\n### statementlist\nIncludes any OpenROAD statement\n\nFor a complete description of the procedure statement, see the *Language Reference Guide* online help.\n\nFor more information about local procedures, see Local Procedures.\n\n## Returning from a Procedure\n\nUse the return statement in your procedure to return control to the script or procedure that called it. In returning control, you can also pass a value back to the calling script or procedure. The single value that you pass back must match the return value data type that you specified when you created the procedure. The value is passed back to the caller and assigned as the value of the return variable in the calling script or procedure.\n\nYou can use a procedure that returns a value as an expression by itself or as part of a larger expression, as described in Procedures in Expressions. The data type of the returned value must be compatible with the requirements of the expression. In the following example, square_root is a procedure that returns a value.\n\n```\nreturnfield = square_root(number = 36) * 5;\n```\n\nA procedure that returns a value can be used as a parameter value in another procedure. The following is an example of nested OpenROAD procedures:\n\n```\nreturnfield = p (arg1 = square_root(number = 17));\n```\n\nThe following example calls the procedure with the name specified in the procfield field of the current frame and returns a value to the result variable:\n\n```\nresult = :procfield (x = 5, y = price);\n```\n\nIf you use the value found in a variable for the procedure name, you must use the colon. At runtime, the user enters the correct procedure name into procfield on the current form, and OpenROAD then calls that procedure.\n\nFor more information about callproc, see the *Language Reference Guide* online help."
        ]
    },
    {
        "instruction": "What is the purpose of the declare block in a global 4GL procedure?",
        "input": "",
        "output": "The declare block in a global 4GL procedure serves to initialize local variables and forward references within the procedure. The syntax for this block is:\n```\ndeclare\n    [localvariablelist]\n    [localprocedureforwardreferences]\nenddeclare]\n```",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->global_procedures",
        "task_description": "Explain the features and creation process of global procedures in Actian 4GL SQL.",
        "document": [
            "# Global Procedures\n\nA *global 4GL procedure* is a routine written in 4GL that you can call by name from a script or another procedure. The procedure is a component of an application and is stored in the application's database.\n\nTo create a global 4GL procedure, use the OpenROAD Workbench to name the procedure and declare its return value. You then write the actual procedure statement in 4GL. The following section describes this statement. For more information about creating 4GL procedures, see the *Workbench User Guide*.\n\n## Procedure Statement\n\nThe *procedure statement* defines a 4GL procedure. This statement declares the parameters for the procedure and provides the actual processing statements. The syntax for a global 4GL procedure is:\n\n```\nprocedure procname [([parameterlist])] = \n[declare \n    [localvariablelist]\n    [localprocedureforwardreferences]\nenddeclare]\nbegin \n    statementlist\nend\n[;] {localprocedure[;]}\n```\n\n### procname\nSpecifies the procedure name. You use this name when you call the procedure in the application.\n\n### parameterlist\nSpecifies parameters that are passed to the procedure. You can also use a parameter as a local variable within the procedure. A 4GL procedure can have any number of parameters.\n\nA parameter can be any simple data type acceptable to OpenROAD or any named user class or system class. If a procedure has no parameters, the parentheses are optional.\n\nFor more information about the declare block, see Initialize Statement.\n\n### statementlist\nIncludes any OpenROAD statement\n\nFor a complete description of the procedure statement, see the *Language Reference Guide* online help.\n\nFor more information about local procedures, see Local Procedures.\n\n## Returning from a Procedure\n\nUse the return statement in your procedure to return control to the script or procedure that called it. In returning control, you can also pass a value back to the calling script or procedure. The single value that you pass back must match the return value data type that you specified when you created the procedure. The value is passed back to the caller and assigned as the value of the return variable in the calling script or procedure.\n\nYou can use a procedure that returns a value as an expression by itself or as part of a larger expression, as described in Procedures in Expressions. The data type of the returned value must be compatible with the requirements of the expression. In the following example, square_root is a procedure that returns a value.\n\n```\nreturnfield = square_root(number = 36) * 5;\n```\n\nA procedure that returns a value can be used as a parameter value in another procedure. The following is an example of nested OpenROAD procedures:\n\n```\nreturnfield = p (arg1 = square_root(number = 17));\n```\n\nThe following example calls the procedure with the name specified in the procfield field of the current frame and returns a value to the result variable:\n\n```\nresult = :procfield (x = 5, y = price);\n```\n\nIf you use the value found in a variable for the procedure name, you must use the colon. At runtime, the user enters the correct procedure name into procfield on the current form, and OpenROAD then calls that procedure.\n\nFor more information about callproc, see the *Language Reference Guide* online help."
        ]
    },
    {
        "instruction": "Explain how to return control and pass value back in a procedure using the `return` statement.",
        "input": "",
        "output": "You can use the `return` statement in your procedure to return control to the script or procedure that called it. In returning control, you can also pass a value back to the calling script or procedure. The single value that you pass back must match the return value data type that you specified when you created the procedure.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->global_procedures",
        "task_description": "Explain the features and creation process of global procedures in Actian 4GL SQL.",
        "document": [
            "# Global Procedures\n\nA *global 4GL procedure* is a routine written in 4GL that you can call by name from a script or another procedure. The procedure is a component of an application and is stored in the application's database.\n\nTo create a global 4GL procedure, use the OpenROAD Workbench to name the procedure and declare its return value. You then write the actual procedure statement in 4GL. The following section describes this statement. For more information about creating 4GL procedures, see the *Workbench User Guide*.\n\n## Procedure Statement\n\nThe *procedure statement* defines a 4GL procedure. This statement declares the parameters for the procedure and provides the actual processing statements. The syntax for a global 4GL procedure is:\n\n```\nprocedure procname [([parameterlist])] = \n[declare \n    [localvariablelist]\n    [localprocedureforwardreferences]\nenddeclare]\nbegin \n    statementlist\nend\n[;] {localprocedure[;]}\n```\n\n### procname\nSpecifies the procedure name. You use this name when you call the procedure in the application.\n\n### parameterlist\nSpecifies parameters that are passed to the procedure. You can also use a parameter as a local variable within the procedure. A 4GL procedure can have any number of parameters.\n\nA parameter can be any simple data type acceptable to OpenROAD or any named user class or system class. If a procedure has no parameters, the parentheses are optional.\n\nFor more information about the declare block, see Initialize Statement.\n\n### statementlist\nIncludes any OpenROAD statement\n\nFor a complete description of the procedure statement, see the *Language Reference Guide* online help.\n\nFor more information about local procedures, see Local Procedures.\n\n## Returning from a Procedure\n\nUse the return statement in your procedure to return control to the script or procedure that called it. In returning control, you can also pass a value back to the calling script or procedure. The single value that you pass back must match the return value data type that you specified when you created the procedure. The value is passed back to the caller and assigned as the value of the return variable in the calling script or procedure.\n\nYou can use a procedure that returns a value as an expression by itself or as part of a larger expression, as described in Procedures in Expressions. The data type of the returned value must be compatible with the requirements of the expression. In the following example, square_root is a procedure that returns a value.\n\n```\nreturnfield = square_root(number = 36) * 5;\n```\n\nA procedure that returns a value can be used as a parameter value in another procedure. The following is an example of nested OpenROAD procedures:\n\n```\nreturnfield = p (arg1 = square_root(number = 17));\n```\n\nThe following example calls the procedure with the name specified in the procfield field of the current frame and returns a value to the result variable:\n\n```\nresult = :procfield (x = 5, y = price);\n```\n\nIf you use the value found in a variable for the procedure name, you must use the colon. At runtime, the user enters the correct procedure name into procfield on the current form, and OpenROAD then calls that procedure.\n\nFor more information about callproc, see the *Language Reference Guide* online help."
        ]
    },
    {
        "instruction": "What is `localprocedureforwardreferences` and where can it be used in the procedure statement?",
        "input": "",
        "output": "The `localproceduresforwardreferences` declares forward references for local procedures defined inside a procedure. This block can be included within the `declare` block of a global or a local procedure.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->global_procedures",
        "task_description": "Explain the features and creation process of global procedures in Actian 4GL SQL.",
        "document": [
            "# Global Procedures\n\nA *global 4GL procedure* is a routine written in 4GL that you can call by name from a script or another procedure. The procedure is a component of an application and is stored in the application's database.\n\nTo create a global 4GL procedure, use the OpenROAD Workbench to name the procedure and declare its return value. You then write the actual procedure statement in 4GL. The following section describes this statement. For more information about creating 4GL procedures, see the *Workbench User Guide*.\n\n## Procedure Statement\n\nThe *procedure statement* defines a 4GL procedure. This statement declares the parameters for the procedure and provides the actual processing statements. The syntax for a global 4GL procedure is:\n\n```\nprocedure procname [([parameterlist])] = \n[declare \n    [localvariablelist]\n    [localprocedureforwardreferences]\nenddeclare]\nbegin \n    statementlist\nend\n[;] {localprocedure[;]}\n```\n\n### procname\nSpecifies the procedure name. You use this name when you call the procedure in the application.\n\n### parameterlist\nSpecifies parameters that are passed to the procedure. You can also use a parameter as a local variable within the procedure. A 4GL procedure can have any number of parameters.\n\nA parameter can be any simple data type acceptable to OpenROAD or any named user class or system class. If a procedure has no parameters, the parentheses are optional.\n\nFor more information about the declare block, see Initialize Statement.\n\n### statementlist\nIncludes any OpenROAD statement\n\nFor a complete description of the procedure statement, see the *Language Reference Guide* online help.\n\nFor more information about local procedures, see Local Procedures.\n\n## Returning from a Procedure\n\nUse the return statement in your procedure to return control to the script or procedure that called it. In returning control, you can also pass a value back to the calling script or procedure. The single value that you pass back must match the return value data type that you specified when you created the procedure. The value is passed back to the caller and assigned as the value of the return variable in the calling script or procedure.\n\nYou can use a procedure that returns a value as an expression by itself or as part of a larger expression, as described in Procedures in Expressions. The data type of the returned value must be compatible with the requirements of the expression. In the following example, square_root is a procedure that returns a value.\n\n```\nreturnfield = square_root(number = 36) * 5;\n```\n\nA procedure that returns a value can be used as a parameter value in another procedure. The following is an example of nested OpenROAD procedures:\n\n```\nreturnfield = p (arg1 = square_root(number = 17));\n```\n\nThe following example calls the procedure with the name specified in the procfield field of the current frame and returns a value to the result variable:\n\n```\nresult = :procfield (x = 5, y = price);\n```\n\nIf you use the value found in a variable for the procedure name, you must use the colon. At runtime, the user enters the correct procedure name into procfield on the current form, and OpenROAD then calls that procedure.\n\nFor more information about callproc, see the *Language Reference Guide* online help."
        ]
    },
    {
        "instruction": "What is the process of creating a global 4GL procedure in Actian 4GL SQL using OpenROAD Workbench?",
        "input": "To create a global 4GL procedure, use the OpenROAD Workbench to name the procedure and declare its return value. You then write the actual procedure statement in 4GL. The following section describes this statement:\n```\nprocedure procname [([parameterlist])] =\n[declare\n    [localvariablelist]\n    [localprocedureforwardreferences]\nenddeclare]\nbegin\n    statementlist\nend\n[;] {localprocedure[;]}\n```",
        "output": "<noinput>",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->global_procedures",
        "task_description": "Explain the features and creation process of global procedures in Actian 4GL SQL.",
        "document": [
            "# Global Procedures\n\nA *global 4GL procedure* is a routine written in 4GL that you can call by name from a script or another procedure. The procedure is a component of an application and is stored in the application's database.\n\nTo create a global 4GL procedure, use the OpenROAD Workbench to name the procedure and declare its return value. You then write the actual procedure statement in 4GL. The following section describes this statement. For more information about creating 4GL procedures, see the *Workbench User Guide*.\n\n## Procedure Statement\n\nThe *procedure statement* defines a 4GL procedure. This statement declares the parameters for the procedure and provides the actual processing statements. The syntax for a global 4GL procedure is:\n\n```\nprocedure procname [([parameterlist])] = \n[declare \n    [localvariablelist]\n    [localprocedureforwardreferences]\nenddeclare]\nbegin \n    statementlist\nend\n[;] {localprocedure[;]}\n```\n\n### procname\nSpecifies the procedure name. You use this name when you call the procedure in the application.\n\n### parameterlist\nSpecifies parameters that are passed to the procedure. You can also use a parameter as a local variable within the procedure. A 4GL procedure can have any number of parameters.\n\nA parameter can be any simple data type acceptable to OpenROAD or any named user class or system class. If a procedure has no parameters, the parentheses are optional.\n\nFor more information about the declare block, see Initialize Statement.\n\n### statementlist\nIncludes any OpenROAD statement\n\nFor a complete description of the procedure statement, see the *Language Reference Guide* online help.\n\nFor more information about local procedures, see Local Procedures.\n\n## Returning from a Procedure\n\nUse the return statement in your procedure to return control to the script or procedure that called it. In returning control, you can also pass a value back to the calling script or procedure. The single value that you pass back must match the return value data type that you specified when you created the procedure. The value is passed back to the caller and assigned as the value of the return variable in the calling script or procedure.\n\nYou can use a procedure that returns a value as an expression by itself or as part of a larger expression, as described in Procedures in Expressions. The data type of the returned value must be compatible with the requirements of the expression. In the following example, square_root is a procedure that returns a value.\n\n```\nreturnfield = square_root(number = 36) * 5;\n```\n\nA procedure that returns a value can be used as a parameter value in another procedure. The following is an example of nested OpenROAD procedures:\n\n```\nreturnfield = p (arg1 = square_root(number = 17));\n```\n\nThe following example calls the procedure with the name specified in the procfield field of the current frame and returns a value to the result variable:\n\n```\nresult = :procfield (x = 5, y = price);\n```\n\nIf you use the value found in a variable for the procedure name, you must use the colon. At runtime, the user enters the correct procedure name into procfield on the current form, and OpenROAD then calls that procedure.\n\nFor more information about callproc, see the *Language Reference Guide* online help."
        ]
    },
    {
        "instruction": "What is a global 4GL procedure?",
        "input": "",
        "output": "A global 4GL procedure is a routine written in 4GL that you can call by name from a script or another procedure. The procedure is a component of an application and is stored in the application's database.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->global_procedures",
        "task_description": "Explain the features and creation process of global procedures in Actian 4GL SQL.",
        "document": [
            "# Global Procedures\n\nA *global 4GL procedure* is a routine written in 4GL that you can call by name from a script or another procedure. The procedure is a component of an application and is stored in the application's database.\n\nTo create a global 4GL procedure, use the OpenROAD Workbench to name the procedure and declare its return value. You then write the actual procedure statement in 4GL. The following section describes this statement. For more information about creating 4GL procedures, see the *Workbench User Guide*.\n\n## Procedure Statement\n\nThe *procedure statement* defines a 4GL procedure. This statement declares the parameters for the procedure and provides the actual processing statements. The syntax for a global 4GL procedure is:\n\n```\nprocedure procname [([parameterlist])] = \n[declare \n    [localvariablelist]\n    [localprocedureforwardreferences]\nenddeclare]\nbegin \n    statementlist\nend\n[;] {localprocedure[;]}\n```\n\n### procname\nSpecifies the procedure name. You use this name when you call the procedure in the application.\n\n### parameterlist\nSpecifies parameters that are passed to the procedure. You can also use a parameter as a local variable within the procedure. A 4GL procedure can have any number of parameters.\n\nA parameter can be any simple data type acceptable to OpenROAD or any named user class or system class. If a procedure has no parameters, the parentheses are optional.\n\nFor more information about the declare block, see Initialize Statement.\n\n### statementlist\nIncludes any OpenROAD statement\n\nFor a complete description of the procedure statement, see the *Language Reference Guide* online help.\n\nFor more information about local procedures, see Local Procedures.\n\n## Returning from a Procedure\n\nUse the return statement in your procedure to return control to the script or procedure that called it. In returning control, you can also pass a value back to the calling script or procedure. The single value that you pass back must match the return value data type that you specified when you created the procedure. The value is passed back to the caller and assigned as the value of the return variable in the calling script or procedure.\n\nYou can use a procedure that returns a value as an expression by itself or as part of a larger expression, as described in Procedures in Expressions. The data type of the returned value must be compatible with the requirements of the expression. In the following example, square_root is a procedure that returns a value.\n\n```\nreturnfield = square_root(number = 36) * 5;\n```\n\nA procedure that returns a value can be used as a parameter value in another procedure. The following is an example of nested OpenROAD procedures:\n\n```\nreturnfield = p (arg1 = square_root(number = 17));\n```\n\nThe following example calls the procedure with the name specified in the procfield field of the current frame and returns a value to the result variable:\n\n```\nresult = :procfield (x = 5, y = price);\n```\n\nIf you use the value found in a variable for the procedure name, you must use the colon. At runtime, the user enters the correct procedure name into procfield on the current form, and OpenROAD then calls that procedure.\n\nFor more information about callproc, see the *Language Reference Guide* online help."
        ]
    },
    {
        "instruction": "What are the steps to create a global 4GL procedure?",
        "input": "",
        "output": "To create a global 4GL procedure, use the OpenROAD Workbench to name the procedure and declare its return value. You then write the actual procedure statement in 4GL using the procedure statement syntax provided. For more information about creating 4GL procedures, refer to the Workbench User Guide.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->global_procedures",
        "task_description": "Explain the features and creation process of global procedures in Actian 4GL SQL.",
        "document": [
            "# Global Procedures\n\nA *global 4GL procedure* is a routine written in 4GL that you can call by name from a script or another procedure. The procedure is a component of an application and is stored in the application's database.\n\nTo create a global 4GL procedure, use the OpenROAD Workbench to name the procedure and declare its return value. You then write the actual procedure statement in 4GL. The following section describes this statement. For more information about creating 4GL procedures, see the *Workbench User Guide*.\n\n## Procedure Statement\n\nThe *procedure statement* defines a 4GL procedure. This statement declares the parameters for the procedure and provides the actual processing statements. The syntax for a global 4GL procedure is:\n\n```\nprocedure procname [([parameterlist])] = \n[declare \n    [localvariablelist]\n    [localprocedureforwardreferences]\nenddeclare]\nbegin \n    statementlist\nend\n[;] {localprocedure[;]}\n```\n\n### procname\nSpecifies the procedure name. You use this name when you call the procedure in the application.\n\n### parameterlist\nSpecifies parameters that are passed to the procedure. You can also use a parameter as a local variable within the procedure. A 4GL procedure can have any number of parameters.\n\nA parameter can be any simple data type acceptable to OpenROAD or any named user class or system class. If a procedure has no parameters, the parentheses are optional.\n\nFor more information about the declare block, see Initialize Statement.\n\n### statementlist\nIncludes any OpenROAD statement\n\nFor a complete description of the procedure statement, see the *Language Reference Guide* online help.\n\nFor more information about local procedures, see Local Procedures.\n\n## Returning from a Procedure\n\nUse the return statement in your procedure to return control to the script or procedure that called it. In returning control, you can also pass a value back to the calling script or procedure. The single value that you pass back must match the return value data type that you specified when you created the procedure. The value is passed back to the caller and assigned as the value of the return variable in the calling script or procedure.\n\nYou can use a procedure that returns a value as an expression by itself or as part of a larger expression, as described in Procedures in Expressions. The data type of the returned value must be compatible with the requirements of the expression. In the following example, square_root is a procedure that returns a value.\n\n```\nreturnfield = square_root(number = 36) * 5;\n```\n\nA procedure that returns a value can be used as a parameter value in another procedure. The following is an example of nested OpenROAD procedures:\n\n```\nreturnfield = p (arg1 = square_root(number = 17));\n```\n\nThe following example calls the procedure with the name specified in the procfield field of the current frame and returns a value to the result variable:\n\n```\nresult = :procfield (x = 5, y = price);\n```\n\nIf you use the value found in a variable for the procedure name, you must use the colon. At runtime, the user enters the correct procedure name into procfield on the current form, and OpenROAD then calls that procedure.\n\nFor more information about callproc, see the *Language Reference Guide* online help."
        ]
    },
    {
        "instruction": "Can you give an example of how to create a global procedure in Actian 4GL SQL using the OpenROAD Workbench?",
        "input": "",
        "output": "Using the OpenROAD Workbench to create a global procedure, name it and declare its return value. Here is an example:\n```\nprocedure my_proc =\nbegin\n    // Your 4GL statement logic here\nend\n```",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->global_procedures",
        "task_description": "Explain the features and creation process of global procedures in Actian 4GL SQL.",
        "document": [
            "# Global Procedures\n\nA *global 4GL procedure* is a routine written in 4GL that you can call by name from a script or another procedure. The procedure is a component of an application and is stored in the application's database.\n\nTo create a global 4GL procedure, use the OpenROAD Workbench to name the procedure and declare its return value. You then write the actual procedure statement in 4GL. The following section describes this statement. For more information about creating 4GL procedures, see the *Workbench User Guide*.\n\n## Procedure Statement\n\nThe *procedure statement* defines a 4GL procedure. This statement declares the parameters for the procedure and provides the actual processing statements. The syntax for a global 4GL procedure is:\n\n```\nprocedure procname [([parameterlist])] = \n[declare \n    [localvariablelist]\n    [localprocedureforwardreferences]\nenddeclare]\nbegin \n    statementlist\nend\n[;] {localprocedure[;]}\n```\n\n### procname\nSpecifies the procedure name. You use this name when you call the procedure in the application.\n\n### parameterlist\nSpecifies parameters that are passed to the procedure. You can also use a parameter as a local variable within the procedure. A 4GL procedure can have any number of parameters.\n\nA parameter can be any simple data type acceptable to OpenROAD or any named user class or system class. If a procedure has no parameters, the parentheses are optional.\n\nFor more information about the declare block, see Initialize Statement.\n\n### statementlist\nIncludes any OpenROAD statement\n\nFor a complete description of the procedure statement, see the *Language Reference Guide* online help.\n\nFor more information about local procedures, see Local Procedures.\n\n## Returning from a Procedure\n\nUse the return statement in your procedure to return control to the script or procedure that called it. In returning control, you can also pass a value back to the calling script or procedure. The single value that you pass back must match the return value data type that you specified when you created the procedure. The value is passed back to the caller and assigned as the value of the return variable in the calling script or procedure.\n\nYou can use a procedure that returns a value as an expression by itself or as part of a larger expression, as described in Procedures in Expressions. The data type of the returned value must be compatible with the requirements of the expression. In the following example, square_root is a procedure that returns a value.\n\n```\nreturnfield = square_root(number = 36) * 5;\n```\n\nA procedure that returns a value can be used as a parameter value in another procedure. The following is an example of nested OpenROAD procedures:\n\n```\nreturnfield = p (arg1 = square_root(number = 17));\n```\n\nThe following example calls the procedure with the name specified in the procfield field of the current frame and returns a value to the result variable:\n\n```\nresult = :procfield (x = 5, y = price);\n```\n\nIf you use the value found in a variable for the procedure name, you must use the colon. At runtime, the user enters the correct procedure name into procfield on the current form, and OpenROAD then calls that procedure.\n\nFor more information about callproc, see the *Language Reference Guide* online help."
        ]
    },
    {
        "instruction": "What happens when you use the `return` statement in a procedure?",
        "input": "",
        "output": "The return statement is used to return control back to the script or procedure that called it. In addition, it allows passing a value back to the calling script or procedure if needed. The data type of the returned value must match the one specified when creating the procedure.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->global_procedures",
        "task_description": "Explain the features and creation process of global procedures in Actian 4GL SQL.",
        "document": [
            "# Global Procedures\n\nA *global 4GL procedure* is a routine written in 4GL that you can call by name from a script or another procedure. The procedure is a component of an application and is stored in the application's database.\n\nTo create a global 4GL procedure, use the OpenROAD Workbench to name the procedure and declare its return value. You then write the actual procedure statement in 4GL. The following section describes this statement. For more information about creating 4GL procedures, see the *Workbench User Guide*.\n\n## Procedure Statement\n\nThe *procedure statement* defines a 4GL procedure. This statement declares the parameters for the procedure and provides the actual processing statements. The syntax for a global 4GL procedure is:\n\n```\nprocedure procname [([parameterlist])] = \n[declare \n    [localvariablelist]\n    [localprocedureforwardreferences]\nenddeclare]\nbegin \n    statementlist\nend\n[;] {localprocedure[;]}\n```\n\n### procname\nSpecifies the procedure name. You use this name when you call the procedure in the application.\n\n### parameterlist\nSpecifies parameters that are passed to the procedure. You can also use a parameter as a local variable within the procedure. A 4GL procedure can have any number of parameters.\n\nA parameter can be any simple data type acceptable to OpenROAD or any named user class or system class. If a procedure has no parameters, the parentheses are optional.\n\nFor more information about the declare block, see Initialize Statement.\n\n### statementlist\nIncludes any OpenROAD statement\n\nFor a complete description of the procedure statement, see the *Language Reference Guide* online help.\n\nFor more information about local procedures, see Local Procedures.\n\n## Returning from a Procedure\n\nUse the return statement in your procedure to return control to the script or procedure that called it. In returning control, you can also pass a value back to the calling script or procedure. The single value that you pass back must match the return value data type that you specified when you created the procedure. The value is passed back to the caller and assigned as the value of the return variable in the calling script or procedure.\n\nYou can use a procedure that returns a value as an expression by itself or as part of a larger expression, as described in Procedures in Expressions. The data type of the returned value must be compatible with the requirements of the expression. In the following example, square_root is a procedure that returns a value.\n\n```\nreturnfield = square_root(number = 36) * 5;\n```\n\nA procedure that returns a value can be used as a parameter value in another procedure. The following is an example of nested OpenROAD procedures:\n\n```\nreturnfield = p (arg1 = square_root(number = 17));\n```\n\nThe following example calls the procedure with the name specified in the procfield field of the current frame and returns a value to the result variable:\n\n```\nresult = :procfield (x = 5, y = price);\n```\n\nIf you use the value found in a variable for the procedure name, you must use the colon. At runtime, the user enters the correct procedure name into procfield on the current form, and OpenROAD then calls that procedure.\n\nFor more information about callproc, see the *Language Reference Guide* online help."
        ]
    },
    {
        "instruction": "Can you provide an example of a procedure statement in Actian 4GL SQL?",
        "input": "",
        "output": "The syntax for a global 4GL procedure is:\n```\nprocedure procname [([parameterlist])] =\n[declare\n    [localvariablelist]\n    [localprocedureforwardreferences]\nenddeclare]\nbegin\n    statementlist\nend\n[;] {localprocedure[;]}\n```\nFor example:\n```\nprocedure greet (message as string) =\n    begin\n        write message;\n    end\n    ;\n```",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->global_procedures",
        "task_description": "Explain the features and creation process of global procedures in Actian 4GL SQL.",
        "document": [
            "# Global Procedures\n\nA *global 4GL procedure* is a routine written in 4GL that you can call by name from a script or another procedure. The procedure is a component of an application and is stored in the application's database.\n\nTo create a global 4GL procedure, use the OpenROAD Workbench to name the procedure and declare its return value. You then write the actual procedure statement in 4GL. The following section describes this statement. For more information about creating 4GL procedures, see the *Workbench User Guide*.\n\n## Procedure Statement\n\nThe *procedure statement* defines a 4GL procedure. This statement declares the parameters for the procedure and provides the actual processing statements. The syntax for a global 4GL procedure is:\n\n```\nprocedure procname [([parameterlist])] = \n[declare \n    [localvariablelist]\n    [localprocedureforwardreferences]\nenddeclare]\nbegin \n    statementlist\nend\n[;] {localprocedure[;]}\n```\n\n### procname\nSpecifies the procedure name. You use this name when you call the procedure in the application.\n\n### parameterlist\nSpecifies parameters that are passed to the procedure. You can also use a parameter as a local variable within the procedure. A 4GL procedure can have any number of parameters.\n\nA parameter can be any simple data type acceptable to OpenROAD or any named user class or system class. If a procedure has no parameters, the parentheses are optional.\n\nFor more information about the declare block, see Initialize Statement.\n\n### statementlist\nIncludes any OpenROAD statement\n\nFor a complete description of the procedure statement, see the *Language Reference Guide* online help.\n\nFor more information about local procedures, see Local Procedures.\n\n## Returning from a Procedure\n\nUse the return statement in your procedure to return control to the script or procedure that called it. In returning control, you can also pass a value back to the calling script or procedure. The single value that you pass back must match the return value data type that you specified when you created the procedure. The value is passed back to the caller and assigned as the value of the return variable in the calling script or procedure.\n\nYou can use a procedure that returns a value as an expression by itself or as part of a larger expression, as described in Procedures in Expressions. The data type of the returned value must be compatible with the requirements of the expression. In the following example, square_root is a procedure that returns a value.\n\n```\nreturnfield = square_root(number = 36) * 5;\n```\n\nA procedure that returns a value can be used as a parameter value in another procedure. The following is an example of nested OpenROAD procedures:\n\n```\nreturnfield = p (arg1 = square_root(number = 17));\n```\n\nThe following example calls the procedure with the name specified in the procfield field of the current frame and returns a value to the result variable:\n\n```\nresult = :procfield (x = 5, y = price);\n```\n\nIf you use the value found in a variable for the procedure name, you must use the colon. At runtime, the user enters the correct procedure name into procfield on the current form, and OpenROAD then calls that procedure.\n\nFor more information about callproc, see the *Language Reference Guide* online help."
        ]
    },
    {
        "instruction": "Explain the purpose of local variables in Actian 4GL SQL global procedures.",
        "input": "",
        "output": "Local variables are declared within the declare block of a 4GL procedure statement and only exist within the scope of that procedure. They can be used to store data temporarily or to pass values as parameters when calling other procedures.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->global_procedures",
        "task_description": "Explain the features and creation process of global procedures in Actian 4GL SQL.",
        "document": [
            "# Global Procedures\n\nA *global 4GL procedure* is a routine written in 4GL that you can call by name from a script or another procedure. The procedure is a component of an application and is stored in the application's database.\n\nTo create a global 4GL procedure, use the OpenROAD Workbench to name the procedure and declare its return value. You then write the actual procedure statement in 4GL. The following section describes this statement. For more information about creating 4GL procedures, see the *Workbench User Guide*.\n\n## Procedure Statement\n\nThe *procedure statement* defines a 4GL procedure. This statement declares the parameters for the procedure and provides the actual processing statements. The syntax for a global 4GL procedure is:\n\n```\nprocedure procname [([parameterlist])] = \n[declare \n    [localvariablelist]\n    [localprocedureforwardreferences]\nenddeclare]\nbegin \n    statementlist\nend\n[;] {localprocedure[;]}\n```\n\n### procname\nSpecifies the procedure name. You use this name when you call the procedure in the application.\n\n### parameterlist\nSpecifies parameters that are passed to the procedure. You can also use a parameter as a local variable within the procedure. A 4GL procedure can have any number of parameters.\n\nA parameter can be any simple data type acceptable to OpenROAD or any named user class or system class. If a procedure has no parameters, the parentheses are optional.\n\nFor more information about the declare block, see Initialize Statement.\n\n### statementlist\nIncludes any OpenROAD statement\n\nFor a complete description of the procedure statement, see the *Language Reference Guide* online help.\n\nFor more information about local procedures, see Local Procedures.\n\n## Returning from a Procedure\n\nUse the return statement in your procedure to return control to the script or procedure that called it. In returning control, you can also pass a value back to the calling script or procedure. The single value that you pass back must match the return value data type that you specified when you created the procedure. The value is passed back to the caller and assigned as the value of the return variable in the calling script or procedure.\n\nYou can use a procedure that returns a value as an expression by itself or as part of a larger expression, as described in Procedures in Expressions. The data type of the returned value must be compatible with the requirements of the expression. In the following example, square_root is a procedure that returns a value.\n\n```\nreturnfield = square_root(number = 36) * 5;\n```\n\nA procedure that returns a value can be used as a parameter value in another procedure. The following is an example of nested OpenROAD procedures:\n\n```\nreturnfield = p (arg1 = square_root(number = 17));\n```\n\nThe following example calls the procedure with the name specified in the procfield field of the current frame and returns a value to the result variable:\n\n```\nresult = :procfield (x = 5, y = price);\n```\n\nIf you use the value found in a variable for the procedure name, you must use the colon. At runtime, the user enters the correct procedure name into procfield on the current form, and OpenROAD then calls that procedure.\n\nFor more information about callproc, see the *Language Reference Guide* online help."
        ]
    },
    {
        "instruction": "Explain the syntax for a global procedure statement in Actian 4GL.",
        "input": "",
        "output": "The syntax for a global 4GL procedure statement is as follows:\n\n```\nprocedure procname [([parameterlist])] =\n[declare\n    [localvariablelist]\n    [localprocedureforwardreferences]\nenddeclare]\nbegin\n    statementlist\nend\n[;] {localprocedure[;]}\n```",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->global_procedures",
        "task_description": "Explain the features and creation process of global procedures in Actian 4GL SQL.",
        "document": [
            "# Global Procedures\n\nA *global 4GL procedure* is a routine written in 4GL that you can call by name from a script or another procedure. The procedure is a component of an application and is stored in the application's database.\n\nTo create a global 4GL procedure, use the OpenROAD Workbench to name the procedure and declare its return value. You then write the actual procedure statement in 4GL. The following section describes this statement. For more information about creating 4GL procedures, see the *Workbench User Guide*.\n\n## Procedure Statement\n\nThe *procedure statement* defines a 4GL procedure. This statement declares the parameters for the procedure and provides the actual processing statements. The syntax for a global 4GL procedure is:\n\n```\nprocedure procname [([parameterlist])] = \n[declare \n    [localvariablelist]\n    [localprocedureforwardreferences]\nenddeclare]\nbegin \n    statementlist\nend\n[;] {localprocedure[;]}\n```\n\n### procname\nSpecifies the procedure name. You use this name when you call the procedure in the application.\n\n### parameterlist\nSpecifies parameters that are passed to the procedure. You can also use a parameter as a local variable within the procedure. A 4GL procedure can have any number of parameters.\n\nA parameter can be any simple data type acceptable to OpenROAD or any named user class or system class. If a procedure has no parameters, the parentheses are optional.\n\nFor more information about the declare block, see Initialize Statement.\n\n### statementlist\nIncludes any OpenROAD statement\n\nFor a complete description of the procedure statement, see the *Language Reference Guide* online help.\n\nFor more information about local procedures, see Local Procedures.\n\n## Returning from a Procedure\n\nUse the return statement in your procedure to return control to the script or procedure that called it. In returning control, you can also pass a value back to the calling script or procedure. The single value that you pass back must match the return value data type that you specified when you created the procedure. The value is passed back to the caller and assigned as the value of the return variable in the calling script or procedure.\n\nYou can use a procedure that returns a value as an expression by itself or as part of a larger expression, as described in Procedures in Expressions. The data type of the returned value must be compatible with the requirements of the expression. In the following example, square_root is a procedure that returns a value.\n\n```\nreturnfield = square_root(number = 36) * 5;\n```\n\nA procedure that returns a value can be used as a parameter value in another procedure. The following is an example of nested OpenROAD procedures:\n\n```\nreturnfield = p (arg1 = square_root(number = 17));\n```\n\nThe following example calls the procedure with the name specified in the procfield field of the current frame and returns a value to the result variable:\n\n```\nresult = :procfield (x = 5, y = price);\n```\n\nIf you use the value found in a variable for the procedure name, you must use the colon. At runtime, the user enters the correct procedure name into procfield on the current form, and OpenROAD then calls that procedure.\n\nFor more information about callproc, see the *Language Reference Guide* online help."
        ]
    },
    {
        "instruction": "What is the role of `procname` in a global procedure?",
        "input": "",
        "output": "`procname` specifies the name of the procedure. It is the name that you use when calling the procedure from the application.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->global_procedures",
        "task_description": "Explain the features and creation process of global procedures in Actian 4GL SQL.",
        "document": [
            "# Global Procedures\n\nA *global 4GL procedure* is a routine written in 4GL that you can call by name from a script or another procedure. The procedure is a component of an application and is stored in the application's database.\n\nTo create a global 4GL procedure, use the OpenROAD Workbench to name the procedure and declare its return value. You then write the actual procedure statement in 4GL. The following section describes this statement. For more information about creating 4GL procedures, see the *Workbench User Guide*.\n\n## Procedure Statement\n\nThe *procedure statement* defines a 4GL procedure. This statement declares the parameters for the procedure and provides the actual processing statements. The syntax for a global 4GL procedure is:\n\n```\nprocedure procname [([parameterlist])] = \n[declare \n    [localvariablelist]\n    [localprocedureforwardreferences]\nenddeclare]\nbegin \n    statementlist\nend\n[;] {localprocedure[;]}\n```\n\n### procname\nSpecifies the procedure name. You use this name when you call the procedure in the application.\n\n### parameterlist\nSpecifies parameters that are passed to the procedure. You can also use a parameter as a local variable within the procedure. A 4GL procedure can have any number of parameters.\n\nA parameter can be any simple data type acceptable to OpenROAD or any named user class or system class. If a procedure has no parameters, the parentheses are optional.\n\nFor more information about the declare block, see Initialize Statement.\n\n### statementlist\nIncludes any OpenROAD statement\n\nFor a complete description of the procedure statement, see the *Language Reference Guide* online help.\n\nFor more information about local procedures, see Local Procedures.\n\n## Returning from a Procedure\n\nUse the return statement in your procedure to return control to the script or procedure that called it. In returning control, you can also pass a value back to the calling script or procedure. The single value that you pass back must match the return value data type that you specified when you created the procedure. The value is passed back to the caller and assigned as the value of the return variable in the calling script or procedure.\n\nYou can use a procedure that returns a value as an expression by itself or as part of a larger expression, as described in Procedures in Expressions. The data type of the returned value must be compatible with the requirements of the expression. In the following example, square_root is a procedure that returns a value.\n\n```\nreturnfield = square_root(number = 36) * 5;\n```\n\nA procedure that returns a value can be used as a parameter value in another procedure. The following is an example of nested OpenROAD procedures:\n\n```\nreturnfield = p (arg1 = square_root(number = 17));\n```\n\nThe following example calls the procedure with the name specified in the procfield field of the current frame and returns a value to the result variable:\n\n```\nresult = :procfield (x = 5, y = price);\n```\n\nIf you use the value found in a variable for the procedure name, you must use the colon. At runtime, the user enters the correct procedure name into procfield on the current form, and OpenROAD then calls that procedure.\n\nFor more information about callproc, see the *Language Reference Guide* online help."
        ]
    },
    {
        "instruction": "What are the advantages of using global procedures in Actian 4GL SQL?",
        "input": "",
        "output": "Global procedures offer several advantages. They allow reuse and modularization of code, making it easier to maintain and update applications. Global procedures also provide better organization by grouping related logic together. This leads to improved efficiency and readability as well as a reduction in errors due to duplicated or inconsistent code. Furthermore, global procedures enable sharing of logic across multiple scripts, simplifying application development.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->global_procedures",
        "task_description": "Explain the features and creation process of global procedures in Actian 4GL SQL.",
        "document": [
            "# Global Procedures\n\nA *global 4GL procedure* is a routine written in 4GL that you can call by name from a script or another procedure. The procedure is a component of an application and is stored in the application's database.\n\nTo create a global 4GL procedure, use the OpenROAD Workbench to name the procedure and declare its return value. You then write the actual procedure statement in 4GL. The following section describes this statement. For more information about creating 4GL procedures, see the *Workbench User Guide*.\n\n## Procedure Statement\n\nThe *procedure statement* defines a 4GL procedure. This statement declares the parameters for the procedure and provides the actual processing statements. The syntax for a global 4GL procedure is:\n\n```\nprocedure procname [([parameterlist])] = \n[declare \n    [localvariablelist]\n    [localprocedureforwardreferences]\nenddeclare]\nbegin \n    statementlist\nend\n[;] {localprocedure[;]}\n```\n\n### procname\nSpecifies the procedure name. You use this name when you call the procedure in the application.\n\n### parameterlist\nSpecifies parameters that are passed to the procedure. You can also use a parameter as a local variable within the procedure. A 4GL procedure can have any number of parameters.\n\nA parameter can be any simple data type acceptable to OpenROAD or any named user class or system class. If a procedure has no parameters, the parentheses are optional.\n\nFor more information about the declare block, see Initialize Statement.\n\n### statementlist\nIncludes any OpenROAD statement\n\nFor a complete description of the procedure statement, see the *Language Reference Guide* online help.\n\nFor more information about local procedures, see Local Procedures.\n\n## Returning from a Procedure\n\nUse the return statement in your procedure to return control to the script or procedure that called it. In returning control, you can also pass a value back to the calling script or procedure. The single value that you pass back must match the return value data type that you specified when you created the procedure. The value is passed back to the caller and assigned as the value of the return variable in the calling script or procedure.\n\nYou can use a procedure that returns a value as an expression by itself or as part of a larger expression, as described in Procedures in Expressions. The data type of the returned value must be compatible with the requirements of the expression. In the following example, square_root is a procedure that returns a value.\n\n```\nreturnfield = square_root(number = 36) * 5;\n```\n\nA procedure that returns a value can be used as a parameter value in another procedure. The following is an example of nested OpenROAD procedures:\n\n```\nreturnfield = p (arg1 = square_root(number = 17));\n```\n\nThe following example calls the procedure with the name specified in the procfield field of the current frame and returns a value to the result variable:\n\n```\nresult = :procfield (x = 5, y = price);\n```\n\nIf you use the value found in a variable for the procedure name, you must use the colon. At runtime, the user enters the correct procedure name into procfield on the current form, and OpenROAD then calls that procedure.\n\nFor more information about callproc, see the *Language Reference Guide* online help."
        ]
    },
    {
        "instruction": "How do you return a value from a global 4GL procedure in OpenROAD?",
        "input": "",
        "output": "In your procedure, use the `return` statement to return control to the script or procedure that called it. In returning control, you can also pass a value back to the calling script or procedure. The single value that is passed back must match the return value data type that was specified when creating the procedure.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->global_procedures",
        "task_description": "Explain the features and creation process of global procedures in Actian 4GL SQL.",
        "document": [
            "# Global Procedures\n\nA *global 4GL procedure* is a routine written in 4GL that you can call by name from a script or another procedure. The procedure is a component of an application and is stored in the application's database.\n\nTo create a global 4GL procedure, use the OpenROAD Workbench to name the procedure and declare its return value. You then write the actual procedure statement in 4GL. The following section describes this statement. For more information about creating 4GL procedures, see the *Workbench User Guide*.\n\n## Procedure Statement\n\nThe *procedure statement* defines a 4GL procedure. This statement declares the parameters for the procedure and provides the actual processing statements. The syntax for a global 4GL procedure is:\n\n```\nprocedure procname [([parameterlist])] = \n[declare \n    [localvariablelist]\n    [localprocedureforwardreferences]\nenddeclare]\nbegin \n    statementlist\nend\n[;] {localprocedure[;]}\n```\n\n### procname\nSpecifies the procedure name. You use this name when you call the procedure in the application.\n\n### parameterlist\nSpecifies parameters that are passed to the procedure. You can also use a parameter as a local variable within the procedure. A 4GL procedure can have any number of parameters.\n\nA parameter can be any simple data type acceptable to OpenROAD or any named user class or system class. If a procedure has no parameters, the parentheses are optional.\n\nFor more information about the declare block, see Initialize Statement.\n\n### statementlist\nIncludes any OpenROAD statement\n\nFor a complete description of the procedure statement, see the *Language Reference Guide* online help.\n\nFor more information about local procedures, see Local Procedures.\n\n## Returning from a Procedure\n\nUse the return statement in your procedure to return control to the script or procedure that called it. In returning control, you can also pass a value back to the calling script or procedure. The single value that you pass back must match the return value data type that you specified when you created the procedure. The value is passed back to the caller and assigned as the value of the return variable in the calling script or procedure.\n\nYou can use a procedure that returns a value as an expression by itself or as part of a larger expression, as described in Procedures in Expressions. The data type of the returned value must be compatible with the requirements of the expression. In the following example, square_root is a procedure that returns a value.\n\n```\nreturnfield = square_root(number = 36) * 5;\n```\n\nA procedure that returns a value can be used as a parameter value in another procedure. The following is an example of nested OpenROAD procedures:\n\n```\nreturnfield = p (arg1 = square_root(number = 17));\n```\n\nThe following example calls the procedure with the name specified in the procfield field of the current frame and returns a value to the result variable:\n\n```\nresult = :procfield (x = 5, y = price);\n```\n\nIf you use the value found in a variable for the procedure name, you must use the colon. At runtime, the user enters the correct procedure name into procfield on the current form, and OpenROAD then calls that procedure.\n\nFor more information about callproc, see the *Language Reference Guide* online help."
        ]
    },
    {
        "instruction": "How can a value be returned from a global procedure in Actian 4GL?",
        "input": "",
        "output": "In Actian 4GL, you use the return statement to return control to the script or procedure that called it and also pass back a single value. The returned value must match the return type specified when creating the procedure.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->global_procedures",
        "task_description": "Explain the features and creation process of global procedures in Actian 4GL SQL.",
        "document": [
            "# Global Procedures\n\nA *global 4GL procedure* is a routine written in 4GL that you can call by name from a script or another procedure. The procedure is a component of an application and is stored in the application's database.\n\nTo create a global 4GL procedure, use the OpenROAD Workbench to name the procedure and declare its return value. You then write the actual procedure statement in 4GL. The following section describes this statement. For more information about creating 4GL procedures, see the *Workbench User Guide*.\n\n## Procedure Statement\n\nThe *procedure statement* defines a 4GL procedure. This statement declares the parameters for the procedure and provides the actual processing statements. The syntax for a global 4GL procedure is:\n\n```\nprocedure procname [([parameterlist])] = \n[declare \n    [localvariablelist]\n    [localprocedureforwardreferences]\nenddeclare]\nbegin \n    statementlist\nend\n[;] {localprocedure[;]}\n```\n\n### procname\nSpecifies the procedure name. You use this name when you call the procedure in the application.\n\n### parameterlist\nSpecifies parameters that are passed to the procedure. You can also use a parameter as a local variable within the procedure. A 4GL procedure can have any number of parameters.\n\nA parameter can be any simple data type acceptable to OpenROAD or any named user class or system class. If a procedure has no parameters, the parentheses are optional.\n\nFor more information about the declare block, see Initialize Statement.\n\n### statementlist\nIncludes any OpenROAD statement\n\nFor a complete description of the procedure statement, see the *Language Reference Guide* online help.\n\nFor more information about local procedures, see Local Procedures.\n\n## Returning from a Procedure\n\nUse the return statement in your procedure to return control to the script or procedure that called it. In returning control, you can also pass a value back to the calling script or procedure. The single value that you pass back must match the return value data type that you specified when you created the procedure. The value is passed back to the caller and assigned as the value of the return variable in the calling script or procedure.\n\nYou can use a procedure that returns a value as an expression by itself or as part of a larger expression, as described in Procedures in Expressions. The data type of the returned value must be compatible with the requirements of the expression. In the following example, square_root is a procedure that returns a value.\n\n```\nreturnfield = square_root(number = 36) * 5;\n```\n\nA procedure that returns a value can be used as a parameter value in another procedure. The following is an example of nested OpenROAD procedures:\n\n```\nreturnfield = p (arg1 = square_root(number = 17));\n```\n\nThe following example calls the procedure with the name specified in the procfield field of the current frame and returns a value to the result variable:\n\n```\nresult = :procfield (x = 5, y = price);\n```\n\nIf you use the value found in a variable for the procedure name, you must use the colon. At runtime, the user enters the correct procedure name into procfield on the current form, and OpenROAD then calls that procedure.\n\nFor more information about callproc, see the *Language Reference Guide* online help."
        ]
    },
    {
        "instruction": "How can a global procedure be used within an expression?",
        "input": "",
        "output": "A global procedure that returns a value can be used as an expression by itself or as part of a larger expression, as described in Procedures in Expressions. The data type of the returned value must be compatible with the requirements of the expression. In the following example, square_root is a procedure that returns a value:\n\n```\nreturnfield = square_root(number = 36) * 5;\n```",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->global_procedures",
        "task_description": "Explain the features and creation process of global procedures in Actian 4GL SQL.",
        "document": [
            "# Global Procedures\n\nA *global 4GL procedure* is a routine written in 4GL that you can call by name from a script or another procedure. The procedure is a component of an application and is stored in the application's database.\n\nTo create a global 4GL procedure, use the OpenROAD Workbench to name the procedure and declare its return value. You then write the actual procedure statement in 4GL. The following section describes this statement. For more information about creating 4GL procedures, see the *Workbench User Guide*.\n\n## Procedure Statement\n\nThe *procedure statement* defines a 4GL procedure. This statement declares the parameters for the procedure and provides the actual processing statements. The syntax for a global 4GL procedure is:\n\n```\nprocedure procname [([parameterlist])] = \n[declare \n    [localvariablelist]\n    [localprocedureforwardreferences]\nenddeclare]\nbegin \n    statementlist\nend\n[;] {localprocedure[;]}\n```\n\n### procname\nSpecifies the procedure name. You use this name when you call the procedure in the application.\n\n### parameterlist\nSpecifies parameters that are passed to the procedure. You can also use a parameter as a local variable within the procedure. A 4GL procedure can have any number of parameters.\n\nA parameter can be any simple data type acceptable to OpenROAD or any named user class or system class. If a procedure has no parameters, the parentheses are optional.\n\nFor more information about the declare block, see Initialize Statement.\n\n### statementlist\nIncludes any OpenROAD statement\n\nFor a complete description of the procedure statement, see the *Language Reference Guide* online help.\n\nFor more information about local procedures, see Local Procedures.\n\n## Returning from a Procedure\n\nUse the return statement in your procedure to return control to the script or procedure that called it. In returning control, you can also pass a value back to the calling script or procedure. The single value that you pass back must match the return value data type that you specified when you created the procedure. The value is passed back to the caller and assigned as the value of the return variable in the calling script or procedure.\n\nYou can use a procedure that returns a value as an expression by itself or as part of a larger expression, as described in Procedures in Expressions. The data type of the returned value must be compatible with the requirements of the expression. In the following example, square_root is a procedure that returns a value.\n\n```\nreturnfield = square_root(number = 36) * 5;\n```\n\nA procedure that returns a value can be used as a parameter value in another procedure. The following is an example of nested OpenROAD procedures:\n\n```\nreturnfield = p (arg1 = square_root(number = 17));\n```\n\nThe following example calls the procedure with the name specified in the procfield field of the current frame and returns a value to the result variable:\n\n```\nresult = :procfield (x = 5, y = price);\n```\n\nIf you use the value found in a variable for the procedure name, you must use the colon. At runtime, the user enters the correct procedure name into procfield on the current form, and OpenROAD then calls that procedure.\n\nFor more information about callproc, see the *Language Reference Guide* online help."
        ]
    },
    {
        "instruction": "Write an example for using a global 4GL procedure that returns a value as an expression by itself in Actian 4GL SQL.",
        "input": "",
        "output": "Here is an example of using a global 4GL procedure that returns a value as an expression by itself:\n```\nresult = square_root(number = 36);\n```\nIn this example, `square_root` is the name of the global procedure that returns the square root of a number. The result variable stores the returned value (in this case, 6).",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->global_procedures",
        "task_description": "Explain the features and creation process of global procedures in Actian 4GL SQL.",
        "document": [
            "# Global Procedures\n\nA *global 4GL procedure* is a routine written in 4GL that you can call by name from a script or another procedure. The procedure is a component of an application and is stored in the application's database.\n\nTo create a global 4GL procedure, use the OpenROAD Workbench to name the procedure and declare its return value. You then write the actual procedure statement in 4GL. The following section describes this statement. For more information about creating 4GL procedures, see the *Workbench User Guide*.\n\n## Procedure Statement\n\nThe *procedure statement* defines a 4GL procedure. This statement declares the parameters for the procedure and provides the actual processing statements. The syntax for a global 4GL procedure is:\n\n```\nprocedure procname [([parameterlist])] = \n[declare \n    [localvariablelist]\n    [localprocedureforwardreferences]\nenddeclare]\nbegin \n    statementlist\nend\n[;] {localprocedure[;]}\n```\n\n### procname\nSpecifies the procedure name. You use this name when you call the procedure in the application.\n\n### parameterlist\nSpecifies parameters that are passed to the procedure. You can also use a parameter as a local variable within the procedure. A 4GL procedure can have any number of parameters.\n\nA parameter can be any simple data type acceptable to OpenROAD or any named user class or system class. If a procedure has no parameters, the parentheses are optional.\n\nFor more information about the declare block, see Initialize Statement.\n\n### statementlist\nIncludes any OpenROAD statement\n\nFor a complete description of the procedure statement, see the *Language Reference Guide* online help.\n\nFor more information about local procedures, see Local Procedures.\n\n## Returning from a Procedure\n\nUse the return statement in your procedure to return control to the script or procedure that called it. In returning control, you can also pass a value back to the calling script or procedure. The single value that you pass back must match the return value data type that you specified when you created the procedure. The value is passed back to the caller and assigned as the value of the return variable in the calling script or procedure.\n\nYou can use a procedure that returns a value as an expression by itself or as part of a larger expression, as described in Procedures in Expressions. The data type of the returned value must be compatible with the requirements of the expression. In the following example, square_root is a procedure that returns a value.\n\n```\nreturnfield = square_root(number = 36) * 5;\n```\n\nA procedure that returns a value can be used as a parameter value in another procedure. The following is an example of nested OpenROAD procedures:\n\n```\nreturnfield = p (arg1 = square_root(number = 17));\n```\n\nThe following example calls the procedure with the name specified in the procfield field of the current frame and returns a value to the result variable:\n\n```\nresult = :procfield (x = 5, y = price);\n```\n\nIf you use the value found in a variable for the procedure name, you must use the colon. At runtime, the user enters the correct procedure name into procfield on the current form, and OpenROAD then calls that procedure.\n\nFor more information about callproc, see the *Language Reference Guide* online help."
        ]
    },
    {
        "instruction": "What happens when you use a procedure without any parameters?",
        "input": "",
        "output": "If a procedure has no parameters, the parentheses are optional. When the procedure is called in the application, it executes as if it were called with no arguments passed to it.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->global_procedures",
        "task_description": "Explain the features and creation process of global procedures in Actian 4GL SQL.",
        "document": [
            "# Global Procedures\n\nA *global 4GL procedure* is a routine written in 4GL that you can call by name from a script or another procedure. The procedure is a component of an application and is stored in the application's database.\n\nTo create a global 4GL procedure, use the OpenROAD Workbench to name the procedure and declare its return value. You then write the actual procedure statement in 4GL. The following section describes this statement. For more information about creating 4GL procedures, see the *Workbench User Guide*.\n\n## Procedure Statement\n\nThe *procedure statement* defines a 4GL procedure. This statement declares the parameters for the procedure and provides the actual processing statements. The syntax for a global 4GL procedure is:\n\n```\nprocedure procname [([parameterlist])] = \n[declare \n    [localvariablelist]\n    [localprocedureforwardreferences]\nenddeclare]\nbegin \n    statementlist\nend\n[;] {localprocedure[;]}\n```\n\n### procname\nSpecifies the procedure name. You use this name when you call the procedure in the application.\n\n### parameterlist\nSpecifies parameters that are passed to the procedure. You can also use a parameter as a local variable within the procedure. A 4GL procedure can have any number of parameters.\n\nA parameter can be any simple data type acceptable to OpenROAD or any named user class or system class. If a procedure has no parameters, the parentheses are optional.\n\nFor more information about the declare block, see Initialize Statement.\n\n### statementlist\nIncludes any OpenROAD statement\n\nFor a complete description of the procedure statement, see the *Language Reference Guide* online help.\n\nFor more information about local procedures, see Local Procedures.\n\n## Returning from a Procedure\n\nUse the return statement in your procedure to return control to the script or procedure that called it. In returning control, you can also pass a value back to the calling script or procedure. The single value that you pass back must match the return value data type that you specified when you created the procedure. The value is passed back to the caller and assigned as the value of the return variable in the calling script or procedure.\n\nYou can use a procedure that returns a value as an expression by itself or as part of a larger expression, as described in Procedures in Expressions. The data type of the returned value must be compatible with the requirements of the expression. In the following example, square_root is a procedure that returns a value.\n\n```\nreturnfield = square_root(number = 36) * 5;\n```\n\nA procedure that returns a value can be used as a parameter value in another procedure. The following is an example of nested OpenROAD procedures:\n\n```\nreturnfield = p (arg1 = square_root(number = 17));\n```\n\nThe following example calls the procedure with the name specified in the procfield field of the current frame and returns a value to the result variable:\n\n```\nresult = :procfield (x = 5, y = price);\n```\n\nIf you use the value found in a variable for the procedure name, you must use the colon. At runtime, the user enters the correct procedure name into procfield on the current form, and OpenROAD then calls that procedure.\n\nFor more information about callproc, see the *Language Reference Guide* online help."
        ]
    },
    {
        "instruction": "Explain how to create a global 4GL procedure in Actian 4GL SQL using OpenROAD Workbench.",
        "input": "",
        "output": "To create a global 4GL procedure in Actian 4GL SQL using OpenROAD Workbench, follow these steps:\n\n1. Name the procedure and declare its return value using the OpenROAD Workbench.\n2. Write the actual procedure statement in 4GL. The syntax for a global 4GL procedure is:\n```\nprocedure procname [([parameterlist])] =\n[declare\n    [localvariablelist]\n    [localprocedureforwardreferences]\nenddeclare]\nbegin\n    statementlist\nend\n[;] {localprocedure[;]}\n```\n3. For more information about creating 4GL procedures, refer to the *Workbench User Guide*.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->global_procedures",
        "task_description": "Explain the features and creation process of global procedures in Actian 4GL SQL.",
        "document": [
            "# Global Procedures\n\nA *global 4GL procedure* is a routine written in 4GL that you can call by name from a script or another procedure. The procedure is a component of an application and is stored in the application's database.\n\nTo create a global 4GL procedure, use the OpenROAD Workbench to name the procedure and declare its return value. You then write the actual procedure statement in 4GL. The following section describes this statement. For more information about creating 4GL procedures, see the *Workbench User Guide*.\n\n## Procedure Statement\n\nThe *procedure statement* defines a 4GL procedure. This statement declares the parameters for the procedure and provides the actual processing statements. The syntax for a global 4GL procedure is:\n\n```\nprocedure procname [([parameterlist])] = \n[declare \n    [localvariablelist]\n    [localprocedureforwardreferences]\nenddeclare]\nbegin \n    statementlist\nend\n[;] {localprocedure[;]}\n```\n\n### procname\nSpecifies the procedure name. You use this name when you call the procedure in the application.\n\n### parameterlist\nSpecifies parameters that are passed to the procedure. You can also use a parameter as a local variable within the procedure. A 4GL procedure can have any number of parameters.\n\nA parameter can be any simple data type acceptable to OpenROAD or any named user class or system class. If a procedure has no parameters, the parentheses are optional.\n\nFor more information about the declare block, see Initialize Statement.\n\n### statementlist\nIncludes any OpenROAD statement\n\nFor a complete description of the procedure statement, see the *Language Reference Guide* online help.\n\nFor more information about local procedures, see Local Procedures.\n\n## Returning from a Procedure\n\nUse the return statement in your procedure to return control to the script or procedure that called it. In returning control, you can also pass a value back to the calling script or procedure. The single value that you pass back must match the return value data type that you specified when you created the procedure. The value is passed back to the caller and assigned as the value of the return variable in the calling script or procedure.\n\nYou can use a procedure that returns a value as an expression by itself or as part of a larger expression, as described in Procedures in Expressions. The data type of the returned value must be compatible with the requirements of the expression. In the following example, square_root is a procedure that returns a value.\n\n```\nreturnfield = square_root(number = 36) * 5;\n```\n\nA procedure that returns a value can be used as a parameter value in another procedure. The following is an example of nested OpenROAD procedures:\n\n```\nreturnfield = p (arg1 = square_root(number = 17));\n```\n\nThe following example calls the procedure with the name specified in the procfield field of the current frame and returns a value to the result variable:\n\n```\nresult = :procfield (x = 5, y = price);\n```\n\nIf you use the value found in a variable for the procedure name, you must use the colon. At runtime, the user enters the correct procedure name into procfield on the current form, and OpenROAD then calls that procedure.\n\nFor more information about callproc, see the *Language Reference Guide* online help."
        ]
    },
    {
        "instruction": "Explain how to use return statement in a procedure and pass values back to the calling script or procedure in Actian 4GL SQL.",
        "input": "",
        "output": "In Actian 4GL SQL, you can use the return statement in your procedure to return control to the script or procedure that called it. When returning control, you can also pass a value back to the calling script or procedure. The single value that is passed back must match the return value data type that you specified when creating the procedure. To assign the returned value to a variable, use the following syntax:\n```\nresult = return_procedure();\n```\nIn this example, `return_procedure()` is the name of the called procedure that returns a value. The result variable stores the returned value.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->global_procedures",
        "task_description": "Explain the features and creation process of global procedures in Actian 4GL SQL.",
        "document": [
            "# Global Procedures\n\nA *global 4GL procedure* is a routine written in 4GL that you can call by name from a script or another procedure. The procedure is a component of an application and is stored in the application's database.\n\nTo create a global 4GL procedure, use the OpenROAD Workbench to name the procedure and declare its return value. You then write the actual procedure statement in 4GL. The following section describes this statement. For more information about creating 4GL procedures, see the *Workbench User Guide*.\n\n## Procedure Statement\n\nThe *procedure statement* defines a 4GL procedure. This statement declares the parameters for the procedure and provides the actual processing statements. The syntax for a global 4GL procedure is:\n\n```\nprocedure procname [([parameterlist])] = \n[declare \n    [localvariablelist]\n    [localprocedureforwardreferences]\nenddeclare]\nbegin \n    statementlist\nend\n[;] {localprocedure[;]}\n```\n\n### procname\nSpecifies the procedure name. You use this name when you call the procedure in the application.\n\n### parameterlist\nSpecifies parameters that are passed to the procedure. You can also use a parameter as a local variable within the procedure. A 4GL procedure can have any number of parameters.\n\nA parameter can be any simple data type acceptable to OpenROAD or any named user class or system class. If a procedure has no parameters, the parentheses are optional.\n\nFor more information about the declare block, see Initialize Statement.\n\n### statementlist\nIncludes any OpenROAD statement\n\nFor a complete description of the procedure statement, see the *Language Reference Guide* online help.\n\nFor more information about local procedures, see Local Procedures.\n\n## Returning from a Procedure\n\nUse the return statement in your procedure to return control to the script or procedure that called it. In returning control, you can also pass a value back to the calling script or procedure. The single value that you pass back must match the return value data type that you specified when you created the procedure. The value is passed back to the caller and assigned as the value of the return variable in the calling script or procedure.\n\nYou can use a procedure that returns a value as an expression by itself or as part of a larger expression, as described in Procedures in Expressions. The data type of the returned value must be compatible with the requirements of the expression. In the following example, square_root is a procedure that returns a value.\n\n```\nreturnfield = square_root(number = 36) * 5;\n```\n\nA procedure that returns a value can be used as a parameter value in another procedure. The following is an example of nested OpenROAD procedures:\n\n```\nreturnfield = p (arg1 = square_root(number = 17));\n```\n\nThe following example calls the procedure with the name specified in the procfield field of the current frame and returns a value to the result variable:\n\n```\nresult = :procfield (x = 5, y = price);\n```\n\nIf you use the value found in a variable for the procedure name, you must use the colon. At runtime, the user enters the correct procedure name into procfield on the current form, and OpenROAD then calls that procedure.\n\nFor more information about callproc, see the *Language Reference Guide* online help."
        ]
    },
    {
        "instruction": "Describe the return statement in global procedures and how it helps when returning control to a script or procedure.",
        "input": "",
        "output": "Use the return statement in your procedure to return control to the script or procedure that called it. In returning control, you can also pass a value back to the calling script or procedure. The single value that you pass back must match the return value data type that you specified when you created the procedure. The value is passed back to the caller and assigned as the value of the return variable in the calling script or procedure.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->global_procedures",
        "task_description": "Explain the features and creation process of global procedures in Actian 4GL SQL.",
        "document": [
            "# Global Procedures\n\nA *global 4GL procedure* is a routine written in 4GL that you can call by name from a script or another procedure. The procedure is a component of an application and is stored in the application's database.\n\nTo create a global 4GL procedure, use the OpenROAD Workbench to name the procedure and declare its return value. You then write the actual procedure statement in 4GL. The following section describes this statement. For more information about creating 4GL procedures, see the *Workbench User Guide*.\n\n## Procedure Statement\n\nThe *procedure statement* defines a 4GL procedure. This statement declares the parameters for the procedure and provides the actual processing statements. The syntax for a global 4GL procedure is:\n\n```\nprocedure procname [([parameterlist])] = \n[declare \n    [localvariablelist]\n    [localprocedureforwardreferences]\nenddeclare]\nbegin \n    statementlist\nend\n[;] {localprocedure[;]}\n```\n\n### procname\nSpecifies the procedure name. You use this name when you call the procedure in the application.\n\n### parameterlist\nSpecifies parameters that are passed to the procedure. You can also use a parameter as a local variable within the procedure. A 4GL procedure can have any number of parameters.\n\nA parameter can be any simple data type acceptable to OpenROAD or any named user class or system class. If a procedure has no parameters, the parentheses are optional.\n\nFor more information about the declare block, see Initialize Statement.\n\n### statementlist\nIncludes any OpenROAD statement\n\nFor a complete description of the procedure statement, see the *Language Reference Guide* online help.\n\nFor more information about local procedures, see Local Procedures.\n\n## Returning from a Procedure\n\nUse the return statement in your procedure to return control to the script or procedure that called it. In returning control, you can also pass a value back to the calling script or procedure. The single value that you pass back must match the return value data type that you specified when you created the procedure. The value is passed back to the caller and assigned as the value of the return variable in the calling script or procedure.\n\nYou can use a procedure that returns a value as an expression by itself or as part of a larger expression, as described in Procedures in Expressions. The data type of the returned value must be compatible with the requirements of the expression. In the following example, square_root is a procedure that returns a value.\n\n```\nreturnfield = square_root(number = 36) * 5;\n```\n\nA procedure that returns a value can be used as a parameter value in another procedure. The following is an example of nested OpenROAD procedures:\n\n```\nreturnfield = p (arg1 = square_root(number = 17));\n```\n\nThe following example calls the procedure with the name specified in the procfield field of the current frame and returns a value to the result variable:\n\n```\nresult = :procfield (x = 5, y = price);\n```\n\nIf you use the value found in a variable for the procedure name, you must use the colon. At runtime, the user enters the correct procedure name into procfield on the current form, and OpenROAD then calls that procedure.\n\nFor more information about callproc, see the *Language Reference Guide* online help."
        ]
    },
    {
        "instruction": "What does the `procname` in a global 4GL procedure represent?",
        "input": "",
        "output": "The `procname` specifies the name of the procedure. You use this name when calling the procedure within an application.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->global_procedures",
        "task_description": "Explain the features and creation process of global procedures in Actian 4GL SQL.",
        "document": [
            "# Global Procedures\n\nA *global 4GL procedure* is a routine written in 4GL that you can call by name from a script or another procedure. The procedure is a component of an application and is stored in the application's database.\n\nTo create a global 4GL procedure, use the OpenROAD Workbench to name the procedure and declare its return value. You then write the actual procedure statement in 4GL. The following section describes this statement. For more information about creating 4GL procedures, see the *Workbench User Guide*.\n\n## Procedure Statement\n\nThe *procedure statement* defines a 4GL procedure. This statement declares the parameters for the procedure and provides the actual processing statements. The syntax for a global 4GL procedure is:\n\n```\nprocedure procname [([parameterlist])] = \n[declare \n    [localvariablelist]\n    [localprocedureforwardreferences]\nenddeclare]\nbegin \n    statementlist\nend\n[;] {localprocedure[;]}\n```\n\n### procname\nSpecifies the procedure name. You use this name when you call the procedure in the application.\n\n### parameterlist\nSpecifies parameters that are passed to the procedure. You can also use a parameter as a local variable within the procedure. A 4GL procedure can have any number of parameters.\n\nA parameter can be any simple data type acceptable to OpenROAD or any named user class or system class. If a procedure has no parameters, the parentheses are optional.\n\nFor more information about the declare block, see Initialize Statement.\n\n### statementlist\nIncludes any OpenROAD statement\n\nFor a complete description of the procedure statement, see the *Language Reference Guide* online help.\n\nFor more information about local procedures, see Local Procedures.\n\n## Returning from a Procedure\n\nUse the return statement in your procedure to return control to the script or procedure that called it. In returning control, you can also pass a value back to the calling script or procedure. The single value that you pass back must match the return value data type that you specified when you created the procedure. The value is passed back to the caller and assigned as the value of the return variable in the calling script or procedure.\n\nYou can use a procedure that returns a value as an expression by itself or as part of a larger expression, as described in Procedures in Expressions. The data type of the returned value must be compatible with the requirements of the expression. In the following example, square_root is a procedure that returns a value.\n\n```\nreturnfield = square_root(number = 36) * 5;\n```\n\nA procedure that returns a value can be used as a parameter value in another procedure. The following is an example of nested OpenROAD procedures:\n\n```\nreturnfield = p (arg1 = square_root(number = 17));\n```\n\nThe following example calls the procedure with the name specified in the procfield field of the current frame and returns a value to the result variable:\n\n```\nresult = :procfield (x = 5, y = price);\n```\n\nIf you use the value found in a variable for the procedure name, you must use the colon. At runtime, the user enters the correct procedure name into procfield on the current form, and OpenROAD then calls that procedure.\n\nFor more information about callproc, see the *Language Reference Guide* online help."
        ]
    },
    {
        "instruction": "Explain the structure of a procedure statement in Actian 4GL SQL for global procedures and its components.",
        "input": "",
        "output": "The procedure statement defines a 4GL procedure in Actian 4GL SQL. It declares the parameters for the procedure, local variables, and provides the actual processing statements within the `statementlist`. The syntax for a global 4GL procedure is as follows:\n```\nprocedure procname [([parameterlist])] =\n[declare\n    [localvariablelist]\n    [localprocedureforwardreferences]\nenddeclare]\nbegin\n    statementlist\nend\n[;] {localprocedure[;]}\n```\n- `procname`: Specifies the procedure name. You use this name when you call the procedure in the application.\n- `parameterlist`: Specifies parameters that are passed to the procedure. These parameters can be any simple data type acceptable to OpenROAD or any named user class or system class. A 4GL procedure can have any number of parameters.\n- `declare block`: Initializes local variables and forward references within the procedure. It has the following structure:\n```\ndeclare\n    [localvariablelist]\n    [localprocedureforwardreferences]\nenddeclare]\n```\n- `statementlist`: Contains any OpenROAD statement that defines the logic of the procedure.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->global_procedures",
        "task_description": "Explain the features and creation process of global procedures in Actian 4GL SQL.",
        "document": [
            "# Global Procedures\n\nA *global 4GL procedure* is a routine written in 4GL that you can call by name from a script or another procedure. The procedure is a component of an application and is stored in the application's database.\n\nTo create a global 4GL procedure, use the OpenROAD Workbench to name the procedure and declare its return value. You then write the actual procedure statement in 4GL. The following section describes this statement. For more information about creating 4GL procedures, see the *Workbench User Guide*.\n\n## Procedure Statement\n\nThe *procedure statement* defines a 4GL procedure. This statement declares the parameters for the procedure and provides the actual processing statements. The syntax for a global 4GL procedure is:\n\n```\nprocedure procname [([parameterlist])] = \n[declare \n    [localvariablelist]\n    [localprocedureforwardreferences]\nenddeclare]\nbegin \n    statementlist\nend\n[;] {localprocedure[;]}\n```\n\n### procname\nSpecifies the procedure name. You use this name when you call the procedure in the application.\n\n### parameterlist\nSpecifies parameters that are passed to the procedure. You can also use a parameter as a local variable within the procedure. A 4GL procedure can have any number of parameters.\n\nA parameter can be any simple data type acceptable to OpenROAD or any named user class or system class. If a procedure has no parameters, the parentheses are optional.\n\nFor more information about the declare block, see Initialize Statement.\n\n### statementlist\nIncludes any OpenROAD statement\n\nFor a complete description of the procedure statement, see the *Language Reference Guide* online help.\n\nFor more information about local procedures, see Local Procedures.\n\n## Returning from a Procedure\n\nUse the return statement in your procedure to return control to the script or procedure that called it. In returning control, you can also pass a value back to the calling script or procedure. The single value that you pass back must match the return value data type that you specified when you created the procedure. The value is passed back to the caller and assigned as the value of the return variable in the calling script or procedure.\n\nYou can use a procedure that returns a value as an expression by itself or as part of a larger expression, as described in Procedures in Expressions. The data type of the returned value must be compatible with the requirements of the expression. In the following example, square_root is a procedure that returns a value.\n\n```\nreturnfield = square_root(number = 36) * 5;\n```\n\nA procedure that returns a value can be used as a parameter value in another procedure. The following is an example of nested OpenROAD procedures:\n\n```\nreturnfield = p (arg1 = square_root(number = 17));\n```\n\nThe following example calls the procedure with the name specified in the procfield field of the current frame and returns a value to the result variable:\n\n```\nresult = :procfield (x = 5, y = price);\n```\n\nIf you use the value found in a variable for the procedure name, you must use the colon. At runtime, the user enters the correct procedure name into procfield on the current form, and OpenROAD then calls that procedure.\n\nFor more information about callproc, see the *Language Reference Guide* online help."
        ]
    },
    {
        "instruction": "Write the syntax for creating a global 4GL procedure with one parameter using the document provided.",
        "input": "",
        "output": "```\nprocedure procname ([parameter]) =\nbegin\n    statementlist\nend\n[;]\n```",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->global_procedures",
        "task_description": "Explain the features and creation process of global procedures in Actian 4GL SQL.",
        "document": [
            "# Global Procedures\n\nA *global 4GL procedure* is a routine written in 4GL that you can call by name from a script or another procedure. The procedure is a component of an application and is stored in the application's database.\n\nTo create a global 4GL procedure, use the OpenROAD Workbench to name the procedure and declare its return value. You then write the actual procedure statement in 4GL. The following section describes this statement. For more information about creating 4GL procedures, see the *Workbench User Guide*.\n\n## Procedure Statement\n\nThe *procedure statement* defines a 4GL procedure. This statement declares the parameters for the procedure and provides the actual processing statements. The syntax for a global 4GL procedure is:\n\n```\nprocedure procname [([parameterlist])] = \n[declare \n    [localvariablelist]\n    [localprocedureforwardreferences]\nenddeclare]\nbegin \n    statementlist\nend\n[;] {localprocedure[;]}\n```\n\n### procname\nSpecifies the procedure name. You use this name when you call the procedure in the application.\n\n### parameterlist\nSpecifies parameters that are passed to the procedure. You can also use a parameter as a local variable within the procedure. A 4GL procedure can have any number of parameters.\n\nA parameter can be any simple data type acceptable to OpenROAD or any named user class or system class. If a procedure has no parameters, the parentheses are optional.\n\nFor more information about the declare block, see Initialize Statement.\n\n### statementlist\nIncludes any OpenROAD statement\n\nFor a complete description of the procedure statement, see the *Language Reference Guide* online help.\n\nFor more information about local procedures, see Local Procedures.\n\n## Returning from a Procedure\n\nUse the return statement in your procedure to return control to the script or procedure that called it. In returning control, you can also pass a value back to the calling script or procedure. The single value that you pass back must match the return value data type that you specified when you created the procedure. The value is passed back to the caller and assigned as the value of the return variable in the calling script or procedure.\n\nYou can use a procedure that returns a value as an expression by itself or as part of a larger expression, as described in Procedures in Expressions. The data type of the returned value must be compatible with the requirements of the expression. In the following example, square_root is a procedure that returns a value.\n\n```\nreturnfield = square_root(number = 36) * 5;\n```\n\nA procedure that returns a value can be used as a parameter value in another procedure. The following is an example of nested OpenROAD procedures:\n\n```\nreturnfield = p (arg1 = square_root(number = 17));\n```\n\nThe following example calls the procedure with the name specified in the procfield field of the current frame and returns a value to the result variable:\n\n```\nresult = :procfield (x = 5, y = price);\n```\n\nIf you use the value found in a variable for the procedure name, you must use the colon. At runtime, the user enters the correct procedure name into procfield on the current form, and OpenROAD then calls that procedure.\n\nFor more information about callproc, see the *Language Reference Guide* online help."
        ]
    },
    {
        "instruction": "Explain the purpose of the local variables and local procedure forward references in a global procedure.",
        "input": "",
        "output": "The `declare` block in a global 4GL procedure is used to initialize local variables and declare local procedures. Local variables are created within the scope of the procedure. They exist only during the execution of the procedure. Local procedure forward references allow you to use a procedure before it has been declared within the same procedure. This can help optimize the execution time of complex applications by deferring the processing required for certain routines until they are actually needed.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->global_procedures",
        "task_description": "Explain the features and creation process of global procedures in Actian 4GL SQL.",
        "document": [
            "# Global Procedures\n\nA *global 4GL procedure* is a routine written in 4GL that you can call by name from a script or another procedure. The procedure is a component of an application and is stored in the application's database.\n\nTo create a global 4GL procedure, use the OpenROAD Workbench to name the procedure and declare its return value. You then write the actual procedure statement in 4GL. The following section describes this statement. For more information about creating 4GL procedures, see the *Workbench User Guide*.\n\n## Procedure Statement\n\nThe *procedure statement* defines a 4GL procedure. This statement declares the parameters for the procedure and provides the actual processing statements. The syntax for a global 4GL procedure is:\n\n```\nprocedure procname [([parameterlist])] = \n[declare \n    [localvariablelist]\n    [localprocedureforwardreferences]\nenddeclare]\nbegin \n    statementlist\nend\n[;] {localprocedure[;]}\n```\n\n### procname\nSpecifies the procedure name. You use this name when you call the procedure in the application.\n\n### parameterlist\nSpecifies parameters that are passed to the procedure. You can also use a parameter as a local variable within the procedure. A 4GL procedure can have any number of parameters.\n\nA parameter can be any simple data type acceptable to OpenROAD or any named user class or system class. If a procedure has no parameters, the parentheses are optional.\n\nFor more information about the declare block, see Initialize Statement.\n\n### statementlist\nIncludes any OpenROAD statement\n\nFor a complete description of the procedure statement, see the *Language Reference Guide* online help.\n\nFor more information about local procedures, see Local Procedures.\n\n## Returning from a Procedure\n\nUse the return statement in your procedure to return control to the script or procedure that called it. In returning control, you can also pass a value back to the calling script or procedure. The single value that you pass back must match the return value data type that you specified when you created the procedure. The value is passed back to the caller and assigned as the value of the return variable in the calling script or procedure.\n\nYou can use a procedure that returns a value as an expression by itself or as part of a larger expression, as described in Procedures in Expressions. The data type of the returned value must be compatible with the requirements of the expression. In the following example, square_root is a procedure that returns a value.\n\n```\nreturnfield = square_root(number = 36) * 5;\n```\n\nA procedure that returns a value can be used as a parameter value in another procedure. The following is an example of nested OpenROAD procedures:\n\n```\nreturnfield = p (arg1 = square_root(number = 17));\n```\n\nThe following example calls the procedure with the name specified in the procfield field of the current frame and returns a value to the result variable:\n\n```\nresult = :procfield (x = 5, y = price);\n```\n\nIf you use the value found in a variable for the procedure name, you must use the colon. At runtime, the user enters the correct procedure name into procfield on the current form, and OpenROAD then calls that procedure.\n\nFor more information about callproc, see the *Language Reference Guide* online help."
        ]
    }
]