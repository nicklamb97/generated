[
    {
        "instruction": "Provide guidelines for writing C procedures in OpenROAD.",
        "input": "",
        "output": "Use the following syntax when writing a C procedure:\n```c\nprocname([parameters])\n{\n           processing statements\n}\n```\nYou cannot name your C procedure \"main,\" and the procedure must not be static. You can call any C procedure from 4GL except the \"main\" function.\nFollow these guidelines for passing parameters to C procedures:\n- Pass an integer as four bytes by value (or by reference if byref is specified).\n- Pass a smallint as four bytes by value (or by reference if byref is specified).\n- Pass a float as a double-format float by value (or by reference, if byref is specified).\nTo ensure full portability, pass all floating point parameters to C procedures using the byref qualifier. For example, the following code fragment declares some variables and calls a C procedure, passing the procedure a floating-point parameter:\n```c\n/* variable declarations */\ntest_float = float;\ntest_integer = integer;\ntest_return = integer\n...\ntest_return = callproc myCproc (test_integer, byref(test_float));\n```\nThe corresponding C procedure is declared as follows:\n```c\nLong\nmyCproc (ivalue, fvalue)\nlong ivalue; double *fvalue;\n{\n     processing statements\n}\n```\n- Pass a string as a pointer to a null-terminated string as follows:\n  - Pass fixed-length string types (c, char) with trailing blanks up to their full length.\n  - Pass variable-length string types (text, varchar) without trailing blanks.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->3GL_procedures",
        "task_description": "Explain the features and creation process of 3GL procedures in Actian 4GL SQL.",
        "document": [
            "# 3GL Procedures\n\nA 3GL procedure is a procedure written in a third-generation language, such as C, that you can call by name from a script or 4GL procedure. 3GL procedures are used to perform operations that are outside the scope of OpenROAD but are available from a 3GL.\n\nYou maintain and compile 3GL procedures outside of OpenROAD. For more information about how to register 3GL procedures in an application, see the Workbench User Guide.\n\nThe following subsections describe how to declare parameters for 3GL procedures. They also provide language-specific information about coding the procedures. For more information about calling 3GL procedures, see Using 3GL in Your Application.\n\n## 3GL Parameters\n\nOpenROAD lets you pass simple variables to a 3GL procedure. You can also pass objects and arrays as described in the Language Reference Guide online help and in Using 3GL in Your Application. When you pass values to a 3GL procedure, the data type of the values must match the data types of the parameters receiving them in the procedure.\n\nThe following table lists the 4GL simple data types and describes their corresponding 3GL data type declarations:\n\n| 4GL Data Type | Host Variable Declaration |\n|---------------|---------------------------|\n| Char | Fixed-length, null-terminated character string. The size is determined by field size or declared variable length. Data entered into the field is padded with blank characters up to its full declared length before being passed to the 3GL procedure. |\n| Varchar | Variable-length, null-terminated character string. Unlike char type, varchar variables are not extended with blank characters before being passed to the 3GL procedure. |\n| date | Fixed-length, 25-byte, null-terminated character string |\n| money | Double |\n| float, f | Double |\n| integer | Long, 4-byte integer |\n| smallint | Integer, 4-byte integer |\n\nYou can use the byref option with any variable that you pass to a 3GL procedure, regardless of the variable's data type.\n\nYou cannot pass a char or varchar variable that contains an embedded zero byte (hexadecimal'00') to a 3GL procedure. No runtime error occurs, but a truncated version of the 4GL variable may be passed.\n\nWhen a 4GL date variable passes to a 3GL procedure by name, or when the return type of a 3GL procedure is date, 4GL receives it back from the 3GL procedure as a 25-byte string and must then convert it to the internal date format. The date must be valid before the conversion can succeed.\n\nPassing a 4GL variable containing a null value to a 3GL procedure causes a runtime error. Use the ifnull function and is null comparison operator to pass nullable types between 3GL and 4GL, for example:\n\n```\nifnull (v1, v2)\n```\n\nThis reference returns the value of v1 if v1 is not null; otherwise, if v1 is null, it returns the value of v2. The variables v1 and v2 must be the same data type.\n\nIf an impossible value exists for the argument, use the impossible value to indicate a null:\n\n```\ncallproc empcalc (ifnull (age, -1));\n```\n\nIf no impossible value exists for the argument, pass a separate indicator variable to indicate a null argument:\n\n```\nnull_indicator = 0;\nif (age is null) then\n     null_indicator = -1;\nendif;\ncallproc empcalc (age, null_indicator);\n```\n\n## Guidelines for Writing C Procedures\n\nUse the following syntax when writing a C procedure:\n\n```c\nprocname([parameters])\n{\n           processing statements\n}\n```\n\n> Note: You cannot name your C procedure \"main,\" and the procedure must not be static. You can call any C procedure from 4GL except the \"main\" function.\n\nFollow these guidelines for passing parameters to C procedures:\n\n- Pass an integer as four bytes by value (or by reference if byref is specified).\n- Pass a smallint as four bytes by value (or by reference if byref is specified).\n- Pass a float as a double-format float by value (or by reference, if byref is specified).\n\nTo ensure full portability, pass all floating point parameters to C procedures using the byref qualifier. For example, the following code fragment declares some variables and calls a C procedure, passing the procedure a floating-point parameter:\n\n```c\n/* variable declarations */\ntest_float = float;\ntest_integer = integer;\ntest_return = integer\n...\ntest_return = callproc myCproc (test_integer,\n                             byref(test_float));\n```\n\nThe corresponding C procedure is declared as follows:\n\n```c\nLong\nmyCproc (ivalue, fvalue)\nlong ivalue;\ndouble *fvalue;\n{\n     processing statements\n}\n```\n\n- Pass a string as a pointer to a null-terminated string as follows:\n  - Pass fixed-length string types (c, char) with trailing blanks up to their full length.\n  - Pass variable-length string types (text, varchar) without trailing blanks.\n\n- In this call to a procedure \"q\":\n\n```c\ncallproc q (1 + 2, 2.3, 'This is a string');\n```\n\nthe following declarations are required:\n\n```c\nq(x, y, z)\nlong x;\ndouble y; char *z;\n{...\n```\n\nTo receive x and y that are passed by reference, make the following changes to their formal argument declarations:\n\n```c\nlong *x;\ndouble *y;\n```\n\nNo changes are necessary to receive z that is passed by reference.",
            "```c\nlong *x;\ndouble *y;\n```\n\nNo changes are necessary to receive z that is passed by reference.\n\nA C procedure must return an int, a long, a double, or a char * value, as shown in the following examples.\n\n- To return an integer:\n\n```c\nint\nreti()\n{\nreturn 10;\n}\n```\n\n- To return a floating-point value:\n\n```c\ndouble\nretf()\n{\nreturn 10.5;\n}\n```\n\n- To return a character string:\n\n```c\nchar *\nrets()\n{\nreturn \"Returned from rets\";\n}\n```\n\nAny C procedure that returns a char * value to 4GL must return a pointer to a valid address (a string constant or static or global character buffer). The procedure cannot return a pointer to a local character buffer."
        ]
    },
    {
        "instruction": "Explain the importance of matching data types when passing values to a 3GL procedure in OpenROAD.",
        "input": "",
        "output": "When you pass values to a 3GL procedure in OpenROAD, the data type of the values must match the data types of the parameters receiving them in the procedure. Failure to do so can result in unexpected behavior or errors during the execution of the 3GL procedure.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->3GL_procedures",
        "task_description": "Explain the features and creation process of 3GL procedures in Actian 4GL SQL.",
        "document": [
            "# 3GL Procedures\n\nA 3GL procedure is a procedure written in a third-generation language, such as C, that you can call by name from a script or 4GL procedure. 3GL procedures are used to perform operations that are outside the scope of OpenROAD but are available from a 3GL.\n\nYou maintain and compile 3GL procedures outside of OpenROAD. For more information about how to register 3GL procedures in an application, see the Workbench User Guide.\n\nThe following subsections describe how to declare parameters for 3GL procedures. They also provide language-specific information about coding the procedures. For more information about calling 3GL procedures, see Using 3GL in Your Application.\n\n## 3GL Parameters\n\nOpenROAD lets you pass simple variables to a 3GL procedure. You can also pass objects and arrays as described in the Language Reference Guide online help and in Using 3GL in Your Application. When you pass values to a 3GL procedure, the data type of the values must match the data types of the parameters receiving them in the procedure.\n\nThe following table lists the 4GL simple data types and describes their corresponding 3GL data type declarations:\n\n| 4GL Data Type | Host Variable Declaration |\n|---------------|---------------------------|\n| Char | Fixed-length, null-terminated character string. The size is determined by field size or declared variable length. Data entered into the field is padded with blank characters up to its full declared length before being passed to the 3GL procedure. |\n| Varchar | Variable-length, null-terminated character string. Unlike char type, varchar variables are not extended with blank characters before being passed to the 3GL procedure. |\n| date | Fixed-length, 25-byte, null-terminated character string |\n| money | Double |\n| float, f | Double |\n| integer | Long, 4-byte integer |\n| smallint | Integer, 4-byte integer |\n\nYou can use the byref option with any variable that you pass to a 3GL procedure, regardless of the variable's data type.\n\nYou cannot pass a char or varchar variable that contains an embedded zero byte (hexadecimal'00') to a 3GL procedure. No runtime error occurs, but a truncated version of the 4GL variable may be passed.\n\nWhen a 4GL date variable passes to a 3GL procedure by name, or when the return type of a 3GL procedure is date, 4GL receives it back from the 3GL procedure as a 25-byte string and must then convert it to the internal date format. The date must be valid before the conversion can succeed.\n\nPassing a 4GL variable containing a null value to a 3GL procedure causes a runtime error. Use the ifnull function and is null comparison operator to pass nullable types between 3GL and 4GL, for example:\n\n```\nifnull (v1, v2)\n```\n\nThis reference returns the value of v1 if v1 is not null; otherwise, if v1 is null, it returns the value of v2. The variables v1 and v2 must be the same data type.\n\nIf an impossible value exists for the argument, use the impossible value to indicate a null:\n\n```\ncallproc empcalc (ifnull (age, -1));\n```\n\nIf no impossible value exists for the argument, pass a separate indicator variable to indicate a null argument:\n\n```\nnull_indicator = 0;\nif (age is null) then\n     null_indicator = -1;\nendif;\ncallproc empcalc (age, null_indicator);\n```\n\n## Guidelines for Writing C Procedures\n\nUse the following syntax when writing a C procedure:\n\n```c\nprocname([parameters])\n{\n           processing statements\n}\n```\n\n> Note: You cannot name your C procedure \"main,\" and the procedure must not be static. You can call any C procedure from 4GL except the \"main\" function.\n\nFollow these guidelines for passing parameters to C procedures:\n\n- Pass an integer as four bytes by value (or by reference if byref is specified).\n- Pass a smallint as four bytes by value (or by reference if byref is specified).\n- Pass a float as a double-format float by value (or by reference, if byref is specified).\n\nTo ensure full portability, pass all floating point parameters to C procedures using the byref qualifier. For example, the following code fragment declares some variables and calls a C procedure, passing the procedure a floating-point parameter:\n\n```c\n/* variable declarations */\ntest_float = float;\ntest_integer = integer;\ntest_return = integer\n...\ntest_return = callproc myCproc (test_integer,\n                             byref(test_float));\n```\n\nThe corresponding C procedure is declared as follows:\n\n```c\nLong\nmyCproc (ivalue, fvalue)\nlong ivalue;\ndouble *fvalue;\n{\n     processing statements\n}\n```\n\n- Pass a string as a pointer to a null-terminated string as follows:\n  - Pass fixed-length string types (c, char) with trailing blanks up to their full length.\n  - Pass variable-length string types (text, varchar) without trailing blanks.\n\n- In this call to a procedure \"q\":\n\n```c\ncallproc q (1 + 2, 2.3, 'This is a string');\n```\n\nthe following declarations are required:\n\n```c\nq(x, y, z)\nlong x;\ndouble y; char *z;\n{...\n```\n\nTo receive x and y that are passed by reference, make the following changes to their formal argument declarations:\n\n```c\nlong *x;\ndouble *y;\n```\n\nNo changes are necessary to receive z that is passed by reference.",
            "```c\nlong *x;\ndouble *y;\n```\n\nNo changes are necessary to receive z that is passed by reference.\n\nA C procedure must return an int, a long, a double, or a char * value, as shown in the following examples.\n\n- To return an integer:\n\n```c\nint\nreti()\n{\nreturn 10;\n}\n```\n\n- To return a floating-point value:\n\n```c\ndouble\nretf()\n{\nreturn 10.5;\n}\n```\n\n- To return a character string:\n\n```c\nchar *\nrets()\n{\nreturn \"Returned from rets\";\n}\n```\n\nAny C procedure that returns a char * value to 4GL must return a pointer to a valid address (a string constant or static or global character buffer). The procedure cannot return a pointer to a local character buffer."
        ]
    },
    {
        "instruction": "How can a C procedure in Actian 4GL pass values to a variable without needing any changes?",
        "input": "",
        "output": "No changes are necessary to receive z that is passed by reference in Actian 4GL. This means if you have a long type variable 'z' in 4GL and you pass it as a parameter to a C procedure, it will automatically return its value without the need for any special treatment within the C procedure.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->3GL_procedures",
        "task_description": "Explain the features and creation process of 3GL procedures in Actian 4GL SQL.",
        "document": [
            "# 3GL Procedures\n\nA 3GL procedure is a procedure written in a third-generation language, such as C, that you can call by name from a script or 4GL procedure. 3GL procedures are used to perform operations that are outside the scope of OpenROAD but are available from a 3GL.\n\nYou maintain and compile 3GL procedures outside of OpenROAD. For more information about how to register 3GL procedures in an application, see the Workbench User Guide.\n\nThe following subsections describe how to declare parameters for 3GL procedures. They also provide language-specific information about coding the procedures. For more information about calling 3GL procedures, see Using 3GL in Your Application.\n\n## 3GL Parameters\n\nOpenROAD lets you pass simple variables to a 3GL procedure. You can also pass objects and arrays as described in the Language Reference Guide online help and in Using 3GL in Your Application. When you pass values to a 3GL procedure, the data type of the values must match the data types of the parameters receiving them in the procedure.\n\nThe following table lists the 4GL simple data types and describes their corresponding 3GL data type declarations:\n\n| 4GL Data Type | Host Variable Declaration |\n|---------------|---------------------------|\n| Char | Fixed-length, null-terminated character string. The size is determined by field size or declared variable length. Data entered into the field is padded with blank characters up to its full declared length before being passed to the 3GL procedure. |\n| Varchar | Variable-length, null-terminated character string. Unlike char type, varchar variables are not extended with blank characters before being passed to the 3GL procedure. |\n| date | Fixed-length, 25-byte, null-terminated character string |\n| money | Double |\n| float, f | Double |\n| integer | Long, 4-byte integer |\n| smallint | Integer, 4-byte integer |\n\nYou can use the byref option with any variable that you pass to a 3GL procedure, regardless of the variable's data type.\n\nYou cannot pass a char or varchar variable that contains an embedded zero byte (hexadecimal'00') to a 3GL procedure. No runtime error occurs, but a truncated version of the 4GL variable may be passed.\n\nWhen a 4GL date variable passes to a 3GL procedure by name, or when the return type of a 3GL procedure is date, 4GL receives it back from the 3GL procedure as a 25-byte string and must then convert it to the internal date format. The date must be valid before the conversion can succeed.\n\nPassing a 4GL variable containing a null value to a 3GL procedure causes a runtime error. Use the ifnull function and is null comparison operator to pass nullable types between 3GL and 4GL, for example:\n\n```\nifnull (v1, v2)\n```\n\nThis reference returns the value of v1 if v1 is not null; otherwise, if v1 is null, it returns the value of v2. The variables v1 and v2 must be the same data type.\n\nIf an impossible value exists for the argument, use the impossible value to indicate a null:\n\n```\ncallproc empcalc (ifnull (age, -1));\n```\n\nIf no impossible value exists for the argument, pass a separate indicator variable to indicate a null argument:\n\n```\nnull_indicator = 0;\nif (age is null) then\n     null_indicator = -1;\nendif;\ncallproc empcalc (age, null_indicator);\n```\n\n## Guidelines for Writing C Procedures\n\nUse the following syntax when writing a C procedure:\n\n```c\nprocname([parameters])\n{\n           processing statements\n}\n```\n\n> Note: You cannot name your C procedure \"main,\" and the procedure must not be static. You can call any C procedure from 4GL except the \"main\" function.\n\nFollow these guidelines for passing parameters to C procedures:\n\n- Pass an integer as four bytes by value (or by reference if byref is specified).\n- Pass a smallint as four bytes by value (or by reference if byref is specified).\n- Pass a float as a double-format float by value (or by reference, if byref is specified).\n\nTo ensure full portability, pass all floating point parameters to C procedures using the byref qualifier. For example, the following code fragment declares some variables and calls a C procedure, passing the procedure a floating-point parameter:\n\n```c\n/* variable declarations */\ntest_float = float;\ntest_integer = integer;\ntest_return = integer\n...\ntest_return = callproc myCproc (test_integer,\n                             byref(test_float));\n```\n\nThe corresponding C procedure is declared as follows:\n\n```c\nLong\nmyCproc (ivalue, fvalue)\nlong ivalue;\ndouble *fvalue;\n{\n     processing statements\n}\n```\n\n- Pass a string as a pointer to a null-terminated string as follows:\n  - Pass fixed-length string types (c, char) with trailing blanks up to their full length.\n  - Pass variable-length string types (text, varchar) without trailing blanks.\n\n- In this call to a procedure \"q\":\n\n```c\ncallproc q (1 + 2, 2.3, 'This is a string');\n```\n\nthe following declarations are required:\n\n```c\nq(x, y, z)\nlong x;\ndouble y; char *z;\n{...\n```\n\nTo receive x and y that are passed by reference, make the following changes to their formal argument declarations:\n\n```c\nlong *x;\ndouble *y;\n```\n\nNo changes are necessary to receive z that is passed by reference.",
            "```c\nlong *x;\ndouble *y;\n```\n\nNo changes are necessary to receive z that is passed by reference.\n\nA C procedure must return an int, a long, a double, or a char * value, as shown in the following examples.\n\n- To return an integer:\n\n```c\nint\nreti()\n{\nreturn 10;\n}\n```\n\n- To return a floating-point value:\n\n```c\ndouble\nretf()\n{\nreturn 10.5;\n}\n```\n\n- To return a character string:\n\n```c\nchar *\nrets()\n{\nreturn \"Returned from rets\";\n}\n```\n\nAny C procedure that returns a char * value to 4GL must return a pointer to a valid address (a string constant or static or global character buffer). The procedure cannot return a pointer to a local character buffer."
        ]
    },
    {
        "instruction": "Can you provide an example of a simple C procedure that returns an integer?",
        "input": "",
        "output": "Sure! Here is an example of a simple C procedure that returns an integer:\n\n```c\nint\nreti()\n{\n    return 10;\n}\n```\nThis function declares its return type as int, and inside the function it returns the value 10. When this procedure is called in OpenROAD, it will return the integer value 10.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->3GL_procedures",
        "task_description": "Explain the features and creation process of 3GL procedures in Actian 4GL SQL.",
        "document": [
            "# 3GL Procedures\n\nA 3GL procedure is a procedure written in a third-generation language, such as C, that you can call by name from a script or 4GL procedure. 3GL procedures are used to perform operations that are outside the scope of OpenROAD but are available from a 3GL.\n\nYou maintain and compile 3GL procedures outside of OpenROAD. For more information about how to register 3GL procedures in an application, see the Workbench User Guide.\n\nThe following subsections describe how to declare parameters for 3GL procedures. They also provide language-specific information about coding the procedures. For more information about calling 3GL procedures, see Using 3GL in Your Application.\n\n## 3GL Parameters\n\nOpenROAD lets you pass simple variables to a 3GL procedure. You can also pass objects and arrays as described in the Language Reference Guide online help and in Using 3GL in Your Application. When you pass values to a 3GL procedure, the data type of the values must match the data types of the parameters receiving them in the procedure.\n\nThe following table lists the 4GL simple data types and describes their corresponding 3GL data type declarations:\n\n| 4GL Data Type | Host Variable Declaration |\n|---------------|---------------------------|\n| Char | Fixed-length, null-terminated character string. The size is determined by field size or declared variable length. Data entered into the field is padded with blank characters up to its full declared length before being passed to the 3GL procedure. |\n| Varchar | Variable-length, null-terminated character string. Unlike char type, varchar variables are not extended with blank characters before being passed to the 3GL procedure. |\n| date | Fixed-length, 25-byte, null-terminated character string |\n| money | Double |\n| float, f | Double |\n| integer | Long, 4-byte integer |\n| smallint | Integer, 4-byte integer |\n\nYou can use the byref option with any variable that you pass to a 3GL procedure, regardless of the variable's data type.\n\nYou cannot pass a char or varchar variable that contains an embedded zero byte (hexadecimal'00') to a 3GL procedure. No runtime error occurs, but a truncated version of the 4GL variable may be passed.\n\nWhen a 4GL date variable passes to a 3GL procedure by name, or when the return type of a 3GL procedure is date, 4GL receives it back from the 3GL procedure as a 25-byte string and must then convert it to the internal date format. The date must be valid before the conversion can succeed.\n\nPassing a 4GL variable containing a null value to a 3GL procedure causes a runtime error. Use the ifnull function and is null comparison operator to pass nullable types between 3GL and 4GL, for example:\n\n```\nifnull (v1, v2)\n```\n\nThis reference returns the value of v1 if v1 is not null; otherwise, if v1 is null, it returns the value of v2. The variables v1 and v2 must be the same data type.\n\nIf an impossible value exists for the argument, use the impossible value to indicate a null:\n\n```\ncallproc empcalc (ifnull (age, -1));\n```\n\nIf no impossible value exists for the argument, pass a separate indicator variable to indicate a null argument:\n\n```\nnull_indicator = 0;\nif (age is null) then\n     null_indicator = -1;\nendif;\ncallproc empcalc (age, null_indicator);\n```\n\n## Guidelines for Writing C Procedures\n\nUse the following syntax when writing a C procedure:\n\n```c\nprocname([parameters])\n{\n           processing statements\n}\n```\n\n> Note: You cannot name your C procedure \"main,\" and the procedure must not be static. You can call any C procedure from 4GL except the \"main\" function.\n\nFollow these guidelines for passing parameters to C procedures:\n\n- Pass an integer as four bytes by value (or by reference if byref is specified).\n- Pass a smallint as four bytes by value (or by reference if byref is specified).\n- Pass a float as a double-format float by value (or by reference, if byref is specified).\n\nTo ensure full portability, pass all floating point parameters to C procedures using the byref qualifier. For example, the following code fragment declares some variables and calls a C procedure, passing the procedure a floating-point parameter:\n\n```c\n/* variable declarations */\ntest_float = float;\ntest_integer = integer;\ntest_return = integer\n...\ntest_return = callproc myCproc (test_integer,\n                             byref(test_float));\n```\n\nThe corresponding C procedure is declared as follows:\n\n```c\nLong\nmyCproc (ivalue, fvalue)\nlong ivalue;\ndouble *fvalue;\n{\n     processing statements\n}\n```\n\n- Pass a string as a pointer to a null-terminated string as follows:\n  - Pass fixed-length string types (c, char) with trailing blanks up to their full length.\n  - Pass variable-length string types (text, varchar) without trailing blanks.\n\n- In this call to a procedure \"q\":\n\n```c\ncallproc q (1 + 2, 2.3, 'This is a string');\n```\n\nthe following declarations are required:\n\n```c\nq(x, y, z)\nlong x;\ndouble y; char *z;\n{...\n```\n\nTo receive x and y that are passed by reference, make the following changes to their formal argument declarations:\n\n```c\nlong *x;\ndouble *y;\n```\n\nNo changes are necessary to receive z that is passed by reference.",
            "```c\nlong *x;\ndouble *y;\n```\n\nNo changes are necessary to receive z that is passed by reference.\n\nA C procedure must return an int, a long, a double, or a char * value, as shown in the following examples.\n\n- To return an integer:\n\n```c\nint\nreti()\n{\nreturn 10;\n}\n```\n\n- To return a floating-point value:\n\n```c\ndouble\nretf()\n{\nreturn 10.5;\n}\n```\n\n- To return a character string:\n\n```c\nchar *\nrets()\n{\nreturn \"Returned from rets\";\n}\n```\n\nAny C procedure that returns a char * value to 4GL must return a pointer to a valid address (a string constant or static or global character buffer). The procedure cannot return a pointer to a local character buffer."
        ]
    },
    {
        "instruction": "Explain what is not allowed when returning a character string from a C procedure to 4GL in OpenROAD.",
        "input": "",
        "output": "Any C procedure that returns a char * value to 4GL must return a pointer to a valid address (a string constant or static or global character buffer). The procedure cannot return a pointer to a local character buffer, as it is not guaranteed to remain valid after the function call.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->3GL_procedures",
        "task_description": "Explain the features and creation process of 3GL procedures in Actian 4GL SQL.",
        "document": [
            "# 3GL Procedures\n\nA 3GL procedure is a procedure written in a third-generation language, such as C, that you can call by name from a script or 4GL procedure. 3GL procedures are used to perform operations that are outside the scope of OpenROAD but are available from a 3GL.\n\nYou maintain and compile 3GL procedures outside of OpenROAD. For more information about how to register 3GL procedures in an application, see the Workbench User Guide.\n\nThe following subsections describe how to declare parameters for 3GL procedures. They also provide language-specific information about coding the procedures. For more information about calling 3GL procedures, see Using 3GL in Your Application.\n\n## 3GL Parameters\n\nOpenROAD lets you pass simple variables to a 3GL procedure. You can also pass objects and arrays as described in the Language Reference Guide online help and in Using 3GL in Your Application. When you pass values to a 3GL procedure, the data type of the values must match the data types of the parameters receiving them in the procedure.\n\nThe following table lists the 4GL simple data types and describes their corresponding 3GL data type declarations:\n\n| 4GL Data Type | Host Variable Declaration |\n|---------------|---------------------------|\n| Char | Fixed-length, null-terminated character string. The size is determined by field size or declared variable length. Data entered into the field is padded with blank characters up to its full declared length before being passed to the 3GL procedure. |\n| Varchar | Variable-length, null-terminated character string. Unlike char type, varchar variables are not extended with blank characters before being passed to the 3GL procedure. |\n| date | Fixed-length, 25-byte, null-terminated character string |\n| money | Double |\n| float, f | Double |\n| integer | Long, 4-byte integer |\n| smallint | Integer, 4-byte integer |\n\nYou can use the byref option with any variable that you pass to a 3GL procedure, regardless of the variable's data type.\n\nYou cannot pass a char or varchar variable that contains an embedded zero byte (hexadecimal'00') to a 3GL procedure. No runtime error occurs, but a truncated version of the 4GL variable may be passed.\n\nWhen a 4GL date variable passes to a 3GL procedure by name, or when the return type of a 3GL procedure is date, 4GL receives it back from the 3GL procedure as a 25-byte string and must then convert it to the internal date format. The date must be valid before the conversion can succeed.\n\nPassing a 4GL variable containing a null value to a 3GL procedure causes a runtime error. Use the ifnull function and is null comparison operator to pass nullable types between 3GL and 4GL, for example:\n\n```\nifnull (v1, v2)\n```\n\nThis reference returns the value of v1 if v1 is not null; otherwise, if v1 is null, it returns the value of v2. The variables v1 and v2 must be the same data type.\n\nIf an impossible value exists for the argument, use the impossible value to indicate a null:\n\n```\ncallproc empcalc (ifnull (age, -1));\n```\n\nIf no impossible value exists for the argument, pass a separate indicator variable to indicate a null argument:\n\n```\nnull_indicator = 0;\nif (age is null) then\n     null_indicator = -1;\nendif;\ncallproc empcalc (age, null_indicator);\n```\n\n## Guidelines for Writing C Procedures\n\nUse the following syntax when writing a C procedure:\n\n```c\nprocname([parameters])\n{\n           processing statements\n}\n```\n\n> Note: You cannot name your C procedure \"main,\" and the procedure must not be static. You can call any C procedure from 4GL except the \"main\" function.\n\nFollow these guidelines for passing parameters to C procedures:\n\n- Pass an integer as four bytes by value (or by reference if byref is specified).\n- Pass a smallint as four bytes by value (or by reference if byref is specified).\n- Pass a float as a double-format float by value (or by reference, if byref is specified).\n\nTo ensure full portability, pass all floating point parameters to C procedures using the byref qualifier. For example, the following code fragment declares some variables and calls a C procedure, passing the procedure a floating-point parameter:\n\n```c\n/* variable declarations */\ntest_float = float;\ntest_integer = integer;\ntest_return = integer\n...\ntest_return = callproc myCproc (test_integer,\n                             byref(test_float));\n```\n\nThe corresponding C procedure is declared as follows:\n\n```c\nLong\nmyCproc (ivalue, fvalue)\nlong ivalue;\ndouble *fvalue;\n{\n     processing statements\n}\n```\n\n- Pass a string as a pointer to a null-terminated string as follows:\n  - Pass fixed-length string types (c, char) with trailing blanks up to their full length.\n  - Pass variable-length string types (text, varchar) without trailing blanks.\n\n- In this call to a procedure \"q\":\n\n```c\ncallproc q (1 + 2, 2.3, 'This is a string');\n```\n\nthe following declarations are required:\n\n```c\nq(x, y, z)\nlong x;\ndouble y; char *z;\n{...\n```\n\nTo receive x and y that are passed by reference, make the following changes to their formal argument declarations:\n\n```c\nlong *x;\ndouble *y;\n```\n\nNo changes are necessary to receive z that is passed by reference.",
            "```c\nlong *x;\ndouble *y;\n```\n\nNo changes are necessary to receive z that is passed by reference.\n\nA C procedure must return an int, a long, a double, or a char * value, as shown in the following examples.\n\n- To return an integer:\n\n```c\nint\nreti()\n{\nreturn 10;\n}\n```\n\n- To return a floating-point value:\n\n```c\ndouble\nretf()\n{\nreturn 10.5;\n}\n```\n\n- To return a character string:\n\n```c\nchar *\nrets()\n{\nreturn \"Returned from rets\";\n}\n```\n\nAny C procedure that returns a char * value to 4GL must return a pointer to a valid address (a string constant or static or global character buffer). The procedure cannot return a pointer to a local character buffer."
        ]
    },
    {
        "instruction": "What is the format of declaring a C procedure in Actian 4GL?",
        "input": "",
        "output": "Use the following syntax when writing a C procedure in Actian 4GL:\n```c\nprocname([parameters])\n{\n           processing statements\n}\n```",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->3GL_procedures",
        "task_description": "Explain the features and creation process of 3GL procedures in Actian 4GL SQL.",
        "document": [
            "# 3GL Procedures\n\nA 3GL procedure is a procedure written in a third-generation language, such as C, that you can call by name from a script or 4GL procedure. 3GL procedures are used to perform operations that are outside the scope of OpenROAD but are available from a 3GL.\n\nYou maintain and compile 3GL procedures outside of OpenROAD. For more information about how to register 3GL procedures in an application, see the Workbench User Guide.\n\nThe following subsections describe how to declare parameters for 3GL procedures. They also provide language-specific information about coding the procedures. For more information about calling 3GL procedures, see Using 3GL in Your Application.\n\n## 3GL Parameters\n\nOpenROAD lets you pass simple variables to a 3GL procedure. You can also pass objects and arrays as described in the Language Reference Guide online help and in Using 3GL in Your Application. When you pass values to a 3GL procedure, the data type of the values must match the data types of the parameters receiving them in the procedure.\n\nThe following table lists the 4GL simple data types and describes their corresponding 3GL data type declarations:\n\n| 4GL Data Type | Host Variable Declaration |\n|---------------|---------------------------|\n| Char | Fixed-length, null-terminated character string. The size is determined by field size or declared variable length. Data entered into the field is padded with blank characters up to its full declared length before being passed to the 3GL procedure. |\n| Varchar | Variable-length, null-terminated character string. Unlike char type, varchar variables are not extended with blank characters before being passed to the 3GL procedure. |\n| date | Fixed-length, 25-byte, null-terminated character string |\n| money | Double |\n| float, f | Double |\n| integer | Long, 4-byte integer |\n| smallint | Integer, 4-byte integer |\n\nYou can use the byref option with any variable that you pass to a 3GL procedure, regardless of the variable's data type.\n\nYou cannot pass a char or varchar variable that contains an embedded zero byte (hexadecimal'00') to a 3GL procedure. No runtime error occurs, but a truncated version of the 4GL variable may be passed.\n\nWhen a 4GL date variable passes to a 3GL procedure by name, or when the return type of a 3GL procedure is date, 4GL receives it back from the 3GL procedure as a 25-byte string and must then convert it to the internal date format. The date must be valid before the conversion can succeed.\n\nPassing a 4GL variable containing a null value to a 3GL procedure causes a runtime error. Use the ifnull function and is null comparison operator to pass nullable types between 3GL and 4GL, for example:\n\n```\nifnull (v1, v2)\n```\n\nThis reference returns the value of v1 if v1 is not null; otherwise, if v1 is null, it returns the value of v2. The variables v1 and v2 must be the same data type.\n\nIf an impossible value exists for the argument, use the impossible value to indicate a null:\n\n```\ncallproc empcalc (ifnull (age, -1));\n```\n\nIf no impossible value exists for the argument, pass a separate indicator variable to indicate a null argument:\n\n```\nnull_indicator = 0;\nif (age is null) then\n     null_indicator = -1;\nendif;\ncallproc empcalc (age, null_indicator);\n```\n\n## Guidelines for Writing C Procedures\n\nUse the following syntax when writing a C procedure:\n\n```c\nprocname([parameters])\n{\n           processing statements\n}\n```\n\n> Note: You cannot name your C procedure \"main,\" and the procedure must not be static. You can call any C procedure from 4GL except the \"main\" function.\n\nFollow these guidelines for passing parameters to C procedures:\n\n- Pass an integer as four bytes by value (or by reference if byref is specified).\n- Pass a smallint as four bytes by value (or by reference if byref is specified).\n- Pass a float as a double-format float by value (or by reference, if byref is specified).\n\nTo ensure full portability, pass all floating point parameters to C procedures using the byref qualifier. For example, the following code fragment declares some variables and calls a C procedure, passing the procedure a floating-point parameter:\n\n```c\n/* variable declarations */\ntest_float = float;\ntest_integer = integer;\ntest_return = integer\n...\ntest_return = callproc myCproc (test_integer,\n                             byref(test_float));\n```\n\nThe corresponding C procedure is declared as follows:\n\n```c\nLong\nmyCproc (ivalue, fvalue)\nlong ivalue;\ndouble *fvalue;\n{\n     processing statements\n}\n```\n\n- Pass a string as a pointer to a null-terminated string as follows:\n  - Pass fixed-length string types (c, char) with trailing blanks up to their full length.\n  - Pass variable-length string types (text, varchar) without trailing blanks.\n\n- In this call to a procedure \"q\":\n\n```c\ncallproc q (1 + 2, 2.3, 'This is a string');\n```\n\nthe following declarations are required:\n\n```c\nq(x, y, z)\nlong x;\ndouble y; char *z;\n{...\n```\n\nTo receive x and y that are passed by reference, make the following changes to their formal argument declarations:\n\n```c\nlong *x;\ndouble *y;\n```\n\nNo changes are necessary to receive z that is passed by reference.",
            "```c\nlong *x;\ndouble *y;\n```\n\nNo changes are necessary to receive z that is passed by reference.\n\nA C procedure must return an int, a long, a double, or a char * value, as shown in the following examples.\n\n- To return an integer:\n\n```c\nint\nreti()\n{\nreturn 10;\n}\n```\n\n- To return a floating-point value:\n\n```c\ndouble\nretf()\n{\nreturn 10.5;\n}\n```\n\n- To return a character string:\n\n```c\nchar *\nrets()\n{\nreturn \"Returned from rets\";\n}\n```\n\nAny C procedure that returns a char * value to 4GL must return a pointer to a valid address (a string constant or static or global character buffer). The procedure cannot return a pointer to a local character buffer."
        ]
    },
    {
        "instruction": "What are the guidelines for passing floating-point parameters to C procedures in Actian 4GL?",
        "input": "",
        "output": "To ensure full portability, pass all floating point parameters to C procedures using the byref qualifier. For example, the following code fragment declares some variables and calls a C procedure, passing the procedure a floating-point parameter:\n```c\n/* variable declarations */\ntest_float = float;\ntest_integer = integer;\ntest_return = integer\n...\ntest_return = callproc myCproc (test_integer, byref(test_float));\n```\nThe corresponding C procedure is declared as follows:\n```c\nLong\nmyCproc (ivalue, fvalue)\nlong ivalue;\ndouble *fvalue;\n{\n     processing statements\n}\n```",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->3GL_procedures",
        "task_description": "Explain the features and creation process of 3GL procedures in Actian 4GL SQL.",
        "document": [
            "# 3GL Procedures\n\nA 3GL procedure is a procedure written in a third-generation language, such as C, that you can call by name from a script or 4GL procedure. 3GL procedures are used to perform operations that are outside the scope of OpenROAD but are available from a 3GL.\n\nYou maintain and compile 3GL procedures outside of OpenROAD. For more information about how to register 3GL procedures in an application, see the Workbench User Guide.\n\nThe following subsections describe how to declare parameters for 3GL procedures. They also provide language-specific information about coding the procedures. For more information about calling 3GL procedures, see Using 3GL in Your Application.\n\n## 3GL Parameters\n\nOpenROAD lets you pass simple variables to a 3GL procedure. You can also pass objects and arrays as described in the Language Reference Guide online help and in Using 3GL in Your Application. When you pass values to a 3GL procedure, the data type of the values must match the data types of the parameters receiving them in the procedure.\n\nThe following table lists the 4GL simple data types and describes their corresponding 3GL data type declarations:\n\n| 4GL Data Type | Host Variable Declaration |\n|---------------|---------------------------|\n| Char | Fixed-length, null-terminated character string. The size is determined by field size or declared variable length. Data entered into the field is padded with blank characters up to its full declared length before being passed to the 3GL procedure. |\n| Varchar | Variable-length, null-terminated character string. Unlike char type, varchar variables are not extended with blank characters before being passed to the 3GL procedure. |\n| date | Fixed-length, 25-byte, null-terminated character string |\n| money | Double |\n| float, f | Double |\n| integer | Long, 4-byte integer |\n| smallint | Integer, 4-byte integer |\n\nYou can use the byref option with any variable that you pass to a 3GL procedure, regardless of the variable's data type.\n\nYou cannot pass a char or varchar variable that contains an embedded zero byte (hexadecimal'00') to a 3GL procedure. No runtime error occurs, but a truncated version of the 4GL variable may be passed.\n\nWhen a 4GL date variable passes to a 3GL procedure by name, or when the return type of a 3GL procedure is date, 4GL receives it back from the 3GL procedure as a 25-byte string and must then convert it to the internal date format. The date must be valid before the conversion can succeed.\n\nPassing a 4GL variable containing a null value to a 3GL procedure causes a runtime error. Use the ifnull function and is null comparison operator to pass nullable types between 3GL and 4GL, for example:\n\n```\nifnull (v1, v2)\n```\n\nThis reference returns the value of v1 if v1 is not null; otherwise, if v1 is null, it returns the value of v2. The variables v1 and v2 must be the same data type.\n\nIf an impossible value exists for the argument, use the impossible value to indicate a null:\n\n```\ncallproc empcalc (ifnull (age, -1));\n```\n\nIf no impossible value exists for the argument, pass a separate indicator variable to indicate a null argument:\n\n```\nnull_indicator = 0;\nif (age is null) then\n     null_indicator = -1;\nendif;\ncallproc empcalc (age, null_indicator);\n```\n\n## Guidelines for Writing C Procedures\n\nUse the following syntax when writing a C procedure:\n\n```c\nprocname([parameters])\n{\n           processing statements\n}\n```\n\n> Note: You cannot name your C procedure \"main,\" and the procedure must not be static. You can call any C procedure from 4GL except the \"main\" function.\n\nFollow these guidelines for passing parameters to C procedures:\n\n- Pass an integer as four bytes by value (or by reference if byref is specified).\n- Pass a smallint as four bytes by value (or by reference if byref is specified).\n- Pass a float as a double-format float by value (or by reference, if byref is specified).\n\nTo ensure full portability, pass all floating point parameters to C procedures using the byref qualifier. For example, the following code fragment declares some variables and calls a C procedure, passing the procedure a floating-point parameter:\n\n```c\n/* variable declarations */\ntest_float = float;\ntest_integer = integer;\ntest_return = integer\n...\ntest_return = callproc myCproc (test_integer,\n                             byref(test_float));\n```\n\nThe corresponding C procedure is declared as follows:\n\n```c\nLong\nmyCproc (ivalue, fvalue)\nlong ivalue;\ndouble *fvalue;\n{\n     processing statements\n}\n```\n\n- Pass a string as a pointer to a null-terminated string as follows:\n  - Pass fixed-length string types (c, char) with trailing blanks up to their full length.\n  - Pass variable-length string types (text, varchar) without trailing blanks.\n\n- In this call to a procedure \"q\":\n\n```c\ncallproc q (1 + 2, 2.3, 'This is a string');\n```\n\nthe following declarations are required:\n\n```c\nq(x, y, z)\nlong x;\ndouble y; char *z;\n{...\n```\n\nTo receive x and y that are passed by reference, make the following changes to their formal argument declarations:\n\n```c\nlong *x;\ndouble *y;\n```\n\nNo changes are necessary to receive z that is passed by reference.",
            "```c\nlong *x;\ndouble *y;\n```\n\nNo changes are necessary to receive z that is passed by reference.\n\nA C procedure must return an int, a long, a double, or a char * value, as shown in the following examples.\n\n- To return an integer:\n\n```c\nint\nreti()\n{\nreturn 10;\n}\n```\n\n- To return a floating-point value:\n\n```c\ndouble\nretf()\n{\nreturn 10.5;\n}\n```\n\n- To return a character string:\n\n```c\nchar *\nrets()\n{\nreturn \"Returned from rets\";\n}\n```\n\nAny C procedure that returns a char * value to 4GL must return a pointer to a valid address (a string constant or static or global character buffer). The procedure cannot return a pointer to a local character buffer."
        ]
    },
    {
        "instruction": "What are the data types supported for passing values to a 3GL procedure in Actian 4GL?",
        "input": "",
        "output": "OpenROAD supports passing simple variables to a 3GL procedure, as well as objects and arrays. For 4GL simple data types, you can pass: char, varchar, date, money, float, f, integer, smallint, and double. Here is the corresponding 3GL data type declarations for each of these 4GL data types:\n\n| 4GL Data Type | Host Variable Declaration |\n|---------------|---------------------------|\n| Char | Fixed-length, null-terminated character string. The size is determined by field size or declared variable length. Data entered into the field is padded with blank characters up to its full declared length before being passed to the 3GL procedure. |\n| Varchar | Variable-length, null-terminated character string. Unlike char type, varchar variables are not extended with blank characters before being passed to the 3GL procedure. |\n| date | Fixed-length, 25-byte, null-terminated character string |\n| money | Double |\n| float, f | Double |\n| integer | Long, 4-byte integer |\n| smallint | Integer, 4-byte integer |\n\nYou can use the byref option with any variable that you pass to a 3GL procedure, regardless of the variable's data type.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->3GL_procedures",
        "task_description": "Explain the features and creation process of 3GL procedures in Actian 4GL SQL.",
        "document": [
            "# 3GL Procedures\n\nA 3GL procedure is a procedure written in a third-generation language, such as C, that you can call by name from a script or 4GL procedure. 3GL procedures are used to perform operations that are outside the scope of OpenROAD but are available from a 3GL.\n\nYou maintain and compile 3GL procedures outside of OpenROAD. For more information about how to register 3GL procedures in an application, see the Workbench User Guide.\n\nThe following subsections describe how to declare parameters for 3GL procedures. They also provide language-specific information about coding the procedures. For more information about calling 3GL procedures, see Using 3GL in Your Application.\n\n## 3GL Parameters\n\nOpenROAD lets you pass simple variables to a 3GL procedure. You can also pass objects and arrays as described in the Language Reference Guide online help and in Using 3GL in Your Application. When you pass values to a 3GL procedure, the data type of the values must match the data types of the parameters receiving them in the procedure.\n\nThe following table lists the 4GL simple data types and describes their corresponding 3GL data type declarations:\n\n| 4GL Data Type | Host Variable Declaration |\n|---------------|---------------------------|\n| Char | Fixed-length, null-terminated character string. The size is determined by field size or declared variable length. Data entered into the field is padded with blank characters up to its full declared length before being passed to the 3GL procedure. |\n| Varchar | Variable-length, null-terminated character string. Unlike char type, varchar variables are not extended with blank characters before being passed to the 3GL procedure. |\n| date | Fixed-length, 25-byte, null-terminated character string |\n| money | Double |\n| float, f | Double |\n| integer | Long, 4-byte integer |\n| smallint | Integer, 4-byte integer |\n\nYou can use the byref option with any variable that you pass to a 3GL procedure, regardless of the variable's data type.\n\nYou cannot pass a char or varchar variable that contains an embedded zero byte (hexadecimal'00') to a 3GL procedure. No runtime error occurs, but a truncated version of the 4GL variable may be passed.\n\nWhen a 4GL date variable passes to a 3GL procedure by name, or when the return type of a 3GL procedure is date, 4GL receives it back from the 3GL procedure as a 25-byte string and must then convert it to the internal date format. The date must be valid before the conversion can succeed.\n\nPassing a 4GL variable containing a null value to a 3GL procedure causes a runtime error. Use the ifnull function and is null comparison operator to pass nullable types between 3GL and 4GL, for example:\n\n```\nifnull (v1, v2)\n```\n\nThis reference returns the value of v1 if v1 is not null; otherwise, if v1 is null, it returns the value of v2. The variables v1 and v2 must be the same data type.\n\nIf an impossible value exists for the argument, use the impossible value to indicate a null:\n\n```\ncallproc empcalc (ifnull (age, -1));\n```\n\nIf no impossible value exists for the argument, pass a separate indicator variable to indicate a null argument:\n\n```\nnull_indicator = 0;\nif (age is null) then\n     null_indicator = -1;\nendif;\ncallproc empcalc (age, null_indicator);\n```\n\n## Guidelines for Writing C Procedures\n\nUse the following syntax when writing a C procedure:\n\n```c\nprocname([parameters])\n{\n           processing statements\n}\n```\n\n> Note: You cannot name your C procedure \"main,\" and the procedure must not be static. You can call any C procedure from 4GL except the \"main\" function.\n\nFollow these guidelines for passing parameters to C procedures:\n\n- Pass an integer as four bytes by value (or by reference if byref is specified).\n- Pass a smallint as four bytes by value (or by reference if byref is specified).\n- Pass a float as a double-format float by value (or by reference, if byref is specified).\n\nTo ensure full portability, pass all floating point parameters to C procedures using the byref qualifier. For example, the following code fragment declares some variables and calls a C procedure, passing the procedure a floating-point parameter:\n\n```c\n/* variable declarations */\ntest_float = float;\ntest_integer = integer;\ntest_return = integer\n...\ntest_return = callproc myCproc (test_integer,\n                             byref(test_float));\n```\n\nThe corresponding C procedure is declared as follows:\n\n```c\nLong\nmyCproc (ivalue, fvalue)\nlong ivalue;\ndouble *fvalue;\n{\n     processing statements\n}\n```\n\n- Pass a string as a pointer to a null-terminated string as follows:\n  - Pass fixed-length string types (c, char) with trailing blanks up to their full length.\n  - Pass variable-length string types (text, varchar) without trailing blanks.\n\n- In this call to a procedure \"q\":\n\n```c\ncallproc q (1 + 2, 2.3, 'This is a string');\n```\n\nthe following declarations are required:\n\n```c\nq(x, y, z)\nlong x;\ndouble y; char *z;\n{...\n```\n\nTo receive x and y that are passed by reference, make the following changes to their formal argument declarations:\n\n```c\nlong *x;\ndouble *y;\n```\n\nNo changes are necessary to receive z that is passed by reference.",
            "```c\nlong *x;\ndouble *y;\n```\n\nNo changes are necessary to receive z that is passed by reference.\n\nA C procedure must return an int, a long, a double, or a char * value, as shown in the following examples.\n\n- To return an integer:\n\n```c\nint\nreti()\n{\nreturn 10;\n}\n```\n\n- To return a floating-point value:\n\n```c\ndouble\nretf()\n{\nreturn 10.5;\n}\n```\n\n- To return a character string:\n\n```c\nchar *\nrets()\n{\nreturn \"Returned from rets\";\n}\n```\n\nAny C procedure that returns a char * value to 4GL must return a pointer to a valid address (a string constant or static or global character buffer). The procedure cannot return a pointer to a local character buffer."
        ]
    },
    {
        "instruction": "What should be noted when passing a char or varchar variable containing an embedded zero byte (hexadecimal '00') to a 3GL procedure in Actian 4GL?",
        "input": "",
        "output": "No runtime error occurs when you pass a char or varchar variable containing an embedded zero byte (hexadecimal '00') to a 3GL procedure in Actian 4GL, but a truncated version of the 4GL variable may be passed. To avoid this issue, it is best practice to ensure that such variables do not contain zero bytes before passing them to a 3GL procedure.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->3GL_procedures",
        "task_description": "Explain the features and creation process of 3GL procedures in Actian 4GL SQL.",
        "document": [
            "# 3GL Procedures\n\nA 3GL procedure is a procedure written in a third-generation language, such as C, that you can call by name from a script or 4GL procedure. 3GL procedures are used to perform operations that are outside the scope of OpenROAD but are available from a 3GL.\n\nYou maintain and compile 3GL procedures outside of OpenROAD. For more information about how to register 3GL procedures in an application, see the Workbench User Guide.\n\nThe following subsections describe how to declare parameters for 3GL procedures. They also provide language-specific information about coding the procedures. For more information about calling 3GL procedures, see Using 3GL in Your Application.\n\n## 3GL Parameters\n\nOpenROAD lets you pass simple variables to a 3GL procedure. You can also pass objects and arrays as described in the Language Reference Guide online help and in Using 3GL in Your Application. When you pass values to a 3GL procedure, the data type of the values must match the data types of the parameters receiving them in the procedure.\n\nThe following table lists the 4GL simple data types and describes their corresponding 3GL data type declarations:\n\n| 4GL Data Type | Host Variable Declaration |\n|---------------|---------------------------|\n| Char | Fixed-length, null-terminated character string. The size is determined by field size or declared variable length. Data entered into the field is padded with blank characters up to its full declared length before being passed to the 3GL procedure. |\n| Varchar | Variable-length, null-terminated character string. Unlike char type, varchar variables are not extended with blank characters before being passed to the 3GL procedure. |\n| date | Fixed-length, 25-byte, null-terminated character string |\n| money | Double |\n| float, f | Double |\n| integer | Long, 4-byte integer |\n| smallint | Integer, 4-byte integer |\n\nYou can use the byref option with any variable that you pass to a 3GL procedure, regardless of the variable's data type.\n\nYou cannot pass a char or varchar variable that contains an embedded zero byte (hexadecimal'00') to a 3GL procedure. No runtime error occurs, but a truncated version of the 4GL variable may be passed.\n\nWhen a 4GL date variable passes to a 3GL procedure by name, or when the return type of a 3GL procedure is date, 4GL receives it back from the 3GL procedure as a 25-byte string and must then convert it to the internal date format. The date must be valid before the conversion can succeed.\n\nPassing a 4GL variable containing a null value to a 3GL procedure causes a runtime error. Use the ifnull function and is null comparison operator to pass nullable types between 3GL and 4GL, for example:\n\n```\nifnull (v1, v2)\n```\n\nThis reference returns the value of v1 if v1 is not null; otherwise, if v1 is null, it returns the value of v2. The variables v1 and v2 must be the same data type.\n\nIf an impossible value exists for the argument, use the impossible value to indicate a null:\n\n```\ncallproc empcalc (ifnull (age, -1));\n```\n\nIf no impossible value exists for the argument, pass a separate indicator variable to indicate a null argument:\n\n```\nnull_indicator = 0;\nif (age is null) then\n     null_indicator = -1;\nendif;\ncallproc empcalc (age, null_indicator);\n```\n\n## Guidelines for Writing C Procedures\n\nUse the following syntax when writing a C procedure:\n\n```c\nprocname([parameters])\n{\n           processing statements\n}\n```\n\n> Note: You cannot name your C procedure \"main,\" and the procedure must not be static. You can call any C procedure from 4GL except the \"main\" function.\n\nFollow these guidelines for passing parameters to C procedures:\n\n- Pass an integer as four bytes by value (or by reference if byref is specified).\n- Pass a smallint as four bytes by value (or by reference if byref is specified).\n- Pass a float as a double-format float by value (or by reference, if byref is specified).\n\nTo ensure full portability, pass all floating point parameters to C procedures using the byref qualifier. For example, the following code fragment declares some variables and calls a C procedure, passing the procedure a floating-point parameter:\n\n```c\n/* variable declarations */\ntest_float = float;\ntest_integer = integer;\ntest_return = integer\n...\ntest_return = callproc myCproc (test_integer,\n                             byref(test_float));\n```\n\nThe corresponding C procedure is declared as follows:\n\n```c\nLong\nmyCproc (ivalue, fvalue)\nlong ivalue;\ndouble *fvalue;\n{\n     processing statements\n}\n```\n\n- Pass a string as a pointer to a null-terminated string as follows:\n  - Pass fixed-length string types (c, char) with trailing blanks up to their full length.\n  - Pass variable-length string types (text, varchar) without trailing blanks.\n\n- In this call to a procedure \"q\":\n\n```c\ncallproc q (1 + 2, 2.3, 'This is a string');\n```\n\nthe following declarations are required:\n\n```c\nq(x, y, z)\nlong x;\ndouble y; char *z;\n{...\n```\n\nTo receive x and y that are passed by reference, make the following changes to their formal argument declarations:\n\n```c\nlong *x;\ndouble *y;\n```\n\nNo changes are necessary to receive z that is passed by reference.",
            "```c\nlong *x;\ndouble *y;\n```\n\nNo changes are necessary to receive z that is passed by reference.\n\nA C procedure must return an int, a long, a double, or a char * value, as shown in the following examples.\n\n- To return an integer:\n\n```c\nint\nreti()\n{\nreturn 10;\n}\n```\n\n- To return a floating-point value:\n\n```c\ndouble\nretf()\n{\nreturn 10.5;\n}\n```\n\n- To return a character string:\n\n```c\nchar *\nrets()\n{\nreturn \"Returned from rets\";\n}\n```\n\nAny C procedure that returns a char * value to 4GL must return a pointer to a valid address (a string constant or static or global character buffer). The procedure cannot return a pointer to a local character buffer."
        ]
    },
    {
        "instruction": "Can you describe the process of passing parameters from OpenROAD to a 3GL procedure?",
        "input": "",
        "output": "To pass parameters from OpenROAD to a 3GL procedure, follow these steps:\n\n1. Define the data types for your variables in OpenROAD based on their corresponding 3GL data type declarations (as described in the document).\n2. Call the 3GL procedure using its name and list the parameters within parentheses.\n\nFor example:\n```sql\ncallproc myCproc (test_integer, test_float);\n```",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->3GL_procedures",
        "task_description": "Explain the features and creation process of 3GL procedures in Actian 4GL SQL.",
        "document": [
            "# 3GL Procedures\n\nA 3GL procedure is a procedure written in a third-generation language, such as C, that you can call by name from a script or 4GL procedure. 3GL procedures are used to perform operations that are outside the scope of OpenROAD but are available from a 3GL.\n\nYou maintain and compile 3GL procedures outside of OpenROAD. For more information about how to register 3GL procedures in an application, see the Workbench User Guide.\n\nThe following subsections describe how to declare parameters for 3GL procedures. They also provide language-specific information about coding the procedures. For more information about calling 3GL procedures, see Using 3GL in Your Application.\n\n## 3GL Parameters\n\nOpenROAD lets you pass simple variables to a 3GL procedure. You can also pass objects and arrays as described in the Language Reference Guide online help and in Using 3GL in Your Application. When you pass values to a 3GL procedure, the data type of the values must match the data types of the parameters receiving them in the procedure.\n\nThe following table lists the 4GL simple data types and describes their corresponding 3GL data type declarations:\n\n| 4GL Data Type | Host Variable Declaration |\n|---------------|---------------------------|\n| Char | Fixed-length, null-terminated character string. The size is determined by field size or declared variable length. Data entered into the field is padded with blank characters up to its full declared length before being passed to the 3GL procedure. |\n| Varchar | Variable-length, null-terminated character string. Unlike char type, varchar variables are not extended with blank characters before being passed to the 3GL procedure. |\n| date | Fixed-length, 25-byte, null-terminated character string |\n| money | Double |\n| float, f | Double |\n| integer | Long, 4-byte integer |\n| smallint | Integer, 4-byte integer |\n\nYou can use the byref option with any variable that you pass to a 3GL procedure, regardless of the variable's data type.\n\nYou cannot pass a char or varchar variable that contains an embedded zero byte (hexadecimal'00') to a 3GL procedure. No runtime error occurs, but a truncated version of the 4GL variable may be passed.\n\nWhen a 4GL date variable passes to a 3GL procedure by name, or when the return type of a 3GL procedure is date, 4GL receives it back from the 3GL procedure as a 25-byte string and must then convert it to the internal date format. The date must be valid before the conversion can succeed.\n\nPassing a 4GL variable containing a null value to a 3GL procedure causes a runtime error. Use the ifnull function and is null comparison operator to pass nullable types between 3GL and 4GL, for example:\n\n```\nifnull (v1, v2)\n```\n\nThis reference returns the value of v1 if v1 is not null; otherwise, if v1 is null, it returns the value of v2. The variables v1 and v2 must be the same data type.\n\nIf an impossible value exists for the argument, use the impossible value to indicate a null:\n\n```\ncallproc empcalc (ifnull (age, -1));\n```\n\nIf no impossible value exists for the argument, pass a separate indicator variable to indicate a null argument:\n\n```\nnull_indicator = 0;\nif (age is null) then\n     null_indicator = -1;\nendif;\ncallproc empcalc (age, null_indicator);\n```\n\n## Guidelines for Writing C Procedures\n\nUse the following syntax when writing a C procedure:\n\n```c\nprocname([parameters])\n{\n           processing statements\n}\n```\n\n> Note: You cannot name your C procedure \"main,\" and the procedure must not be static. You can call any C procedure from 4GL except the \"main\" function.\n\nFollow these guidelines for passing parameters to C procedures:\n\n- Pass an integer as four bytes by value (or by reference if byref is specified).\n- Pass a smallint as four bytes by value (or by reference if byref is specified).\n- Pass a float as a double-format float by value (or by reference, if byref is specified).\n\nTo ensure full portability, pass all floating point parameters to C procedures using the byref qualifier. For example, the following code fragment declares some variables and calls a C procedure, passing the procedure a floating-point parameter:\n\n```c\n/* variable declarations */\ntest_float = float;\ntest_integer = integer;\ntest_return = integer\n...\ntest_return = callproc myCproc (test_integer,\n                             byref(test_float));\n```\n\nThe corresponding C procedure is declared as follows:\n\n```c\nLong\nmyCproc (ivalue, fvalue)\nlong ivalue;\ndouble *fvalue;\n{\n     processing statements\n}\n```\n\n- Pass a string as a pointer to a null-terminated string as follows:\n  - Pass fixed-length string types (c, char) with trailing blanks up to their full length.\n  - Pass variable-length string types (text, varchar) without trailing blanks.\n\n- In this call to a procedure \"q\":\n\n```c\ncallproc q (1 + 2, 2.3, 'This is a string');\n```\n\nthe following declarations are required:\n\n```c\nq(x, y, z)\nlong x;\ndouble y; char *z;\n{...\n```\n\nTo receive x and y that are passed by reference, make the following changes to their formal argument declarations:\n\n```c\nlong *x;\ndouble *y;\n```\n\nNo changes are necessary to receive z that is passed by reference.",
            "```c\nlong *x;\ndouble *y;\n```\n\nNo changes are necessary to receive z that is passed by reference.\n\nA C procedure must return an int, a long, a double, or a char * value, as shown in the following examples.\n\n- To return an integer:\n\n```c\nint\nreti()\n{\nreturn 10;\n}\n```\n\n- To return a floating-point value:\n\n```c\ndouble\nretf()\n{\nreturn 10.5;\n}\n```\n\n- To return a character string:\n\n```c\nchar *\nrets()\n{\nreturn \"Returned from rets\";\n}\n```\n\nAny C procedure that returns a char * value to 4GL must return a pointer to a valid address (a string constant or static or global character buffer). The procedure cannot return a pointer to a local character buffer."
        ]
    },
    {
        "instruction": "What's the difference between returning an integer, floating-point value, and character string in C procedure?",
        "input": "",
        "output": "In C procedures, when a value needs to be returned, it must be one of int, double, or char*. Int and smallint are whole numbers while double is a decimal number. The difference between returning an integer, floating-point value, and character string lies in the data type:\n- If you want to return an integer or smallint, use `int` data type.\n- For decimal values, use `double` data type.\n- To return a character string (a sequence of characters terminated by null), use `char*`.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->3GL_procedures",
        "task_description": "Explain the features and creation process of 3GL procedures in Actian 4GL SQL.",
        "document": [
            "# 3GL Procedures\n\nA 3GL procedure is a procedure written in a third-generation language, such as C, that you can call by name from a script or 4GL procedure. 3GL procedures are used to perform operations that are outside the scope of OpenROAD but are available from a 3GL.\n\nYou maintain and compile 3GL procedures outside of OpenROAD. For more information about how to register 3GL procedures in an application, see the Workbench User Guide.\n\nThe following subsections describe how to declare parameters for 3GL procedures. They also provide language-specific information about coding the procedures. For more information about calling 3GL procedures, see Using 3GL in Your Application.\n\n## 3GL Parameters\n\nOpenROAD lets you pass simple variables to a 3GL procedure. You can also pass objects and arrays as described in the Language Reference Guide online help and in Using 3GL in Your Application. When you pass values to a 3GL procedure, the data type of the values must match the data types of the parameters receiving them in the procedure.\n\nThe following table lists the 4GL simple data types and describes their corresponding 3GL data type declarations:\n\n| 4GL Data Type | Host Variable Declaration |\n|---------------|---------------------------|\n| Char | Fixed-length, null-terminated character string. The size is determined by field size or declared variable length. Data entered into the field is padded with blank characters up to its full declared length before being passed to the 3GL procedure. |\n| Varchar | Variable-length, null-terminated character string. Unlike char type, varchar variables are not extended with blank characters before being passed to the 3GL procedure. |\n| date | Fixed-length, 25-byte, null-terminated character string |\n| money | Double |\n| float, f | Double |\n| integer | Long, 4-byte integer |\n| smallint | Integer, 4-byte integer |\n\nYou can use the byref option with any variable that you pass to a 3GL procedure, regardless of the variable's data type.\n\nYou cannot pass a char or varchar variable that contains an embedded zero byte (hexadecimal'00') to a 3GL procedure. No runtime error occurs, but a truncated version of the 4GL variable may be passed.\n\nWhen a 4GL date variable passes to a 3GL procedure by name, or when the return type of a 3GL procedure is date, 4GL receives it back from the 3GL procedure as a 25-byte string and must then convert it to the internal date format. The date must be valid before the conversion can succeed.\n\nPassing a 4GL variable containing a null value to a 3GL procedure causes a runtime error. Use the ifnull function and is null comparison operator to pass nullable types between 3GL and 4GL, for example:\n\n```\nifnull (v1, v2)\n```\n\nThis reference returns the value of v1 if v1 is not null; otherwise, if v1 is null, it returns the value of v2. The variables v1 and v2 must be the same data type.\n\nIf an impossible value exists for the argument, use the impossible value to indicate a null:\n\n```\ncallproc empcalc (ifnull (age, -1));\n```\n\nIf no impossible value exists for the argument, pass a separate indicator variable to indicate a null argument:\n\n```\nnull_indicator = 0;\nif (age is null) then\n     null_indicator = -1;\nendif;\ncallproc empcalc (age, null_indicator);\n```\n\n## Guidelines for Writing C Procedures\n\nUse the following syntax when writing a C procedure:\n\n```c\nprocname([parameters])\n{\n           processing statements\n}\n```\n\n> Note: You cannot name your C procedure \"main,\" and the procedure must not be static. You can call any C procedure from 4GL except the \"main\" function.\n\nFollow these guidelines for passing parameters to C procedures:\n\n- Pass an integer as four bytes by value (or by reference if byref is specified).\n- Pass a smallint as four bytes by value (or by reference if byref is specified).\n- Pass a float as a double-format float by value (or by reference, if byref is specified).\n\nTo ensure full portability, pass all floating point parameters to C procedures using the byref qualifier. For example, the following code fragment declares some variables and calls a C procedure, passing the procedure a floating-point parameter:\n\n```c\n/* variable declarations */\ntest_float = float;\ntest_integer = integer;\ntest_return = integer\n...\ntest_return = callproc myCproc (test_integer,\n                             byref(test_float));\n```\n\nThe corresponding C procedure is declared as follows:\n\n```c\nLong\nmyCproc (ivalue, fvalue)\nlong ivalue;\ndouble *fvalue;\n{\n     processing statements\n}\n```\n\n- Pass a string as a pointer to a null-terminated string as follows:\n  - Pass fixed-length string types (c, char) with trailing blanks up to their full length.\n  - Pass variable-length string types (text, varchar) without trailing blanks.\n\n- In this call to a procedure \"q\":\n\n```c\ncallproc q (1 + 2, 2.3, 'This is a string');\n```\n\nthe following declarations are required:\n\n```c\nq(x, y, z)\nlong x;\ndouble y; char *z;\n{...\n```\n\nTo receive x and y that are passed by reference, make the following changes to their formal argument declarations:\n\n```c\nlong *x;\ndouble *y;\n```\n\nNo changes are necessary to receive z that is passed by reference.",
            "```c\nlong *x;\ndouble *y;\n```\n\nNo changes are necessary to receive z that is passed by reference.\n\nA C procedure must return an int, a long, a double, or a char * value, as shown in the following examples.\n\n- To return an integer:\n\n```c\nint\nreti()\n{\nreturn 10;\n}\n```\n\n- To return a floating-point value:\n\n```c\ndouble\nretf()\n{\nreturn 10.5;\n}\n```\n\n- To return a character string:\n\n```c\nchar *\nrets()\n{\nreturn \"Returned from rets\";\n}\n```\n\nAny C procedure that returns a char * value to 4GL must return a pointer to a valid address (a string constant or static or global character buffer). The procedure cannot return a pointer to a local character buffer."
        ]
    },
    {
        "instruction": "What are the requirements for returning a char* value to 4GL from a C procedure?",
        "input": "",
        "output": "For returning a char* value to 4GL, the procedure must return a pointer to a valid address:\n- A string constant (e.g., \"example\").\n- A static or global character buffer that is allocated before entering the procedure.\n- Do not return a pointer to a local character buffer. Make sure the returned char* value can be accessed by the calling program without errors.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->3GL_procedures",
        "task_description": "Explain the features and creation process of 3GL procedures in Actian 4GL SQL.",
        "document": [
            "# 3GL Procedures\n\nA 3GL procedure is a procedure written in a third-generation language, such as C, that you can call by name from a script or 4GL procedure. 3GL procedures are used to perform operations that are outside the scope of OpenROAD but are available from a 3GL.\n\nYou maintain and compile 3GL procedures outside of OpenROAD. For more information about how to register 3GL procedures in an application, see the Workbench User Guide.\n\nThe following subsections describe how to declare parameters for 3GL procedures. They also provide language-specific information about coding the procedures. For more information about calling 3GL procedures, see Using 3GL in Your Application.\n\n## 3GL Parameters\n\nOpenROAD lets you pass simple variables to a 3GL procedure. You can also pass objects and arrays as described in the Language Reference Guide online help and in Using 3GL in Your Application. When you pass values to a 3GL procedure, the data type of the values must match the data types of the parameters receiving them in the procedure.\n\nThe following table lists the 4GL simple data types and describes their corresponding 3GL data type declarations:\n\n| 4GL Data Type | Host Variable Declaration |\n|---------------|---------------------------|\n| Char | Fixed-length, null-terminated character string. The size is determined by field size or declared variable length. Data entered into the field is padded with blank characters up to its full declared length before being passed to the 3GL procedure. |\n| Varchar | Variable-length, null-terminated character string. Unlike char type, varchar variables are not extended with blank characters before being passed to the 3GL procedure. |\n| date | Fixed-length, 25-byte, null-terminated character string |\n| money | Double |\n| float, f | Double |\n| integer | Long, 4-byte integer |\n| smallint | Integer, 4-byte integer |\n\nYou can use the byref option with any variable that you pass to a 3GL procedure, regardless of the variable's data type.\n\nYou cannot pass a char or varchar variable that contains an embedded zero byte (hexadecimal'00') to a 3GL procedure. No runtime error occurs, but a truncated version of the 4GL variable may be passed.\n\nWhen a 4GL date variable passes to a 3GL procedure by name, or when the return type of a 3GL procedure is date, 4GL receives it back from the 3GL procedure as a 25-byte string and must then convert it to the internal date format. The date must be valid before the conversion can succeed.\n\nPassing a 4GL variable containing a null value to a 3GL procedure causes a runtime error. Use the ifnull function and is null comparison operator to pass nullable types between 3GL and 4GL, for example:\n\n```\nifnull (v1, v2)\n```\n\nThis reference returns the value of v1 if v1 is not null; otherwise, if v1 is null, it returns the value of v2. The variables v1 and v2 must be the same data type.\n\nIf an impossible value exists for the argument, use the impossible value to indicate a null:\n\n```\ncallproc empcalc (ifnull (age, -1));\n```\n\nIf no impossible value exists for the argument, pass a separate indicator variable to indicate a null argument:\n\n```\nnull_indicator = 0;\nif (age is null) then\n     null_indicator = -1;\nendif;\ncallproc empcalc (age, null_indicator);\n```\n\n## Guidelines for Writing C Procedures\n\nUse the following syntax when writing a C procedure:\n\n```c\nprocname([parameters])\n{\n           processing statements\n}\n```\n\n> Note: You cannot name your C procedure \"main,\" and the procedure must not be static. You can call any C procedure from 4GL except the \"main\" function.\n\nFollow these guidelines for passing parameters to C procedures:\n\n- Pass an integer as four bytes by value (or by reference if byref is specified).\n- Pass a smallint as four bytes by value (or by reference if byref is specified).\n- Pass a float as a double-format float by value (or by reference, if byref is specified).\n\nTo ensure full portability, pass all floating point parameters to C procedures using the byref qualifier. For example, the following code fragment declares some variables and calls a C procedure, passing the procedure a floating-point parameter:\n\n```c\n/* variable declarations */\ntest_float = float;\ntest_integer = integer;\ntest_return = integer\n...\ntest_return = callproc myCproc (test_integer,\n                             byref(test_float));\n```\n\nThe corresponding C procedure is declared as follows:\n\n```c\nLong\nmyCproc (ivalue, fvalue)\nlong ivalue;\ndouble *fvalue;\n{\n     processing statements\n}\n```\n\n- Pass a string as a pointer to a null-terminated string as follows:\n  - Pass fixed-length string types (c, char) with trailing blanks up to their full length.\n  - Pass variable-length string types (text, varchar) without trailing blanks.\n\n- In this call to a procedure \"q\":\n\n```c\ncallproc q (1 + 2, 2.3, 'This is a string');\n```\n\nthe following declarations are required:\n\n```c\nq(x, y, z)\nlong x;\ndouble y; char *z;\n{...\n```\n\nTo receive x and y that are passed by reference, make the following changes to their formal argument declarations:\n\n```c\nlong *x;\ndouble *y;\n```\n\nNo changes are necessary to receive z that is passed by reference.",
            "```c\nlong *x;\ndouble *y;\n```\n\nNo changes are necessary to receive z that is passed by reference.\n\nA C procedure must return an int, a long, a double, or a char * value, as shown in the following examples.\n\n- To return an integer:\n\n```c\nint\nreti()\n{\nreturn 10;\n}\n```\n\n- To return a floating-point value:\n\n```c\ndouble\nretf()\n{\nreturn 10.5;\n}\n```\n\n- To return a character string:\n\n```c\nchar *\nrets()\n{\nreturn \"Returned from rets\";\n}\n```\n\nAny C procedure that returns a char * value to 4GL must return a pointer to a valid address (a string constant or static or global character buffer). The procedure cannot return a pointer to a local character buffer."
        ]
    },
    {
        "instruction": "Can you explain how to declare C procedures in OpenROAD?",
        "input": "",
        "output": "The following syntax is used when writing a C procedure:\n```c\nprocname([parameters])\n{\n       processing statements\n}\n```\n- You cannot name your C procedure \"main,\" and the procedure must not be static.\n- You can call any C procedure from 4GL except the \"main\" function.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->3GL_procedures",
        "task_description": "Explain the features and creation process of 3GL procedures in Actian 4GL SQL.",
        "document": [
            "# 3GL Procedures\n\nA 3GL procedure is a procedure written in a third-generation language, such as C, that you can call by name from a script or 4GL procedure. 3GL procedures are used to perform operations that are outside the scope of OpenROAD but are available from a 3GL.\n\nYou maintain and compile 3GL procedures outside of OpenROAD. For more information about how to register 3GL procedures in an application, see the Workbench User Guide.\n\nThe following subsections describe how to declare parameters for 3GL procedures. They also provide language-specific information about coding the procedures. For more information about calling 3GL procedures, see Using 3GL in Your Application.\n\n## 3GL Parameters\n\nOpenROAD lets you pass simple variables to a 3GL procedure. You can also pass objects and arrays as described in the Language Reference Guide online help and in Using 3GL in Your Application. When you pass values to a 3GL procedure, the data type of the values must match the data types of the parameters receiving them in the procedure.\n\nThe following table lists the 4GL simple data types and describes their corresponding 3GL data type declarations:\n\n| 4GL Data Type | Host Variable Declaration |\n|---------------|---------------------------|\n| Char | Fixed-length, null-terminated character string. The size is determined by field size or declared variable length. Data entered into the field is padded with blank characters up to its full declared length before being passed to the 3GL procedure. |\n| Varchar | Variable-length, null-terminated character string. Unlike char type, varchar variables are not extended with blank characters before being passed to the 3GL procedure. |\n| date | Fixed-length, 25-byte, null-terminated character string |\n| money | Double |\n| float, f | Double |\n| integer | Long, 4-byte integer |\n| smallint | Integer, 4-byte integer |\n\nYou can use the byref option with any variable that you pass to a 3GL procedure, regardless of the variable's data type.\n\nYou cannot pass a char or varchar variable that contains an embedded zero byte (hexadecimal'00') to a 3GL procedure. No runtime error occurs, but a truncated version of the 4GL variable may be passed.\n\nWhen a 4GL date variable passes to a 3GL procedure by name, or when the return type of a 3GL procedure is date, 4GL receives it back from the 3GL procedure as a 25-byte string and must then convert it to the internal date format. The date must be valid before the conversion can succeed.\n\nPassing a 4GL variable containing a null value to a 3GL procedure causes a runtime error. Use the ifnull function and is null comparison operator to pass nullable types between 3GL and 4GL, for example:\n\n```\nifnull (v1, v2)\n```\n\nThis reference returns the value of v1 if v1 is not null; otherwise, if v1 is null, it returns the value of v2. The variables v1 and v2 must be the same data type.\n\nIf an impossible value exists for the argument, use the impossible value to indicate a null:\n\n```\ncallproc empcalc (ifnull (age, -1));\n```\n\nIf no impossible value exists for the argument, pass a separate indicator variable to indicate a null argument:\n\n```\nnull_indicator = 0;\nif (age is null) then\n     null_indicator = -1;\nendif;\ncallproc empcalc (age, null_indicator);\n```\n\n## Guidelines for Writing C Procedures\n\nUse the following syntax when writing a C procedure:\n\n```c\nprocname([parameters])\n{\n           processing statements\n}\n```\n\n> Note: You cannot name your C procedure \"main,\" and the procedure must not be static. You can call any C procedure from 4GL except the \"main\" function.\n\nFollow these guidelines for passing parameters to C procedures:\n\n- Pass an integer as four bytes by value (or by reference if byref is specified).\n- Pass a smallint as four bytes by value (or by reference if byref is specified).\n- Pass a float as a double-format float by value (or by reference, if byref is specified).\n\nTo ensure full portability, pass all floating point parameters to C procedures using the byref qualifier. For example, the following code fragment declares some variables and calls a C procedure, passing the procedure a floating-point parameter:\n\n```c\n/* variable declarations */\ntest_float = float;\ntest_integer = integer;\ntest_return = integer\n...\ntest_return = callproc myCproc (test_integer,\n                             byref(test_float));\n```\n\nThe corresponding C procedure is declared as follows:\n\n```c\nLong\nmyCproc (ivalue, fvalue)\nlong ivalue;\ndouble *fvalue;\n{\n     processing statements\n}\n```\n\n- Pass a string as a pointer to a null-terminated string as follows:\n  - Pass fixed-length string types (c, char) with trailing blanks up to their full length.\n  - Pass variable-length string types (text, varchar) without trailing blanks.\n\n- In this call to a procedure \"q\":\n\n```c\ncallproc q (1 + 2, 2.3, 'This is a string');\n```\n\nthe following declarations are required:\n\n```c\nq(x, y, z)\nlong x;\ndouble y; char *z;\n{...\n```\n\nTo receive x and y that are passed by reference, make the following changes to their formal argument declarations:\n\n```c\nlong *x;\ndouble *y;\n```\n\nNo changes are necessary to receive z that is passed by reference.",
            "```c\nlong *x;\ndouble *y;\n```\n\nNo changes are necessary to receive z that is passed by reference.\n\nA C procedure must return an int, a long, a double, or a char * value, as shown in the following examples.\n\n- To return an integer:\n\n```c\nint\nreti()\n{\nreturn 10;\n}\n```\n\n- To return a floating-point value:\n\n```c\ndouble\nretf()\n{\nreturn 10.5;\n}\n```\n\n- To return a character string:\n\n```c\nchar *\nrets()\n{\nreturn \"Returned from rets\";\n}\n```\n\nAny C procedure that returns a char * value to 4GL must return a pointer to a valid address (a string constant or static or global character buffer). The procedure cannot return a pointer to a local character buffer."
        ]
    },
    {
        "instruction": "Explain what is meant by null-terminated character string in OpenROAD, and how it differs from variable-length string types?",
        "input": "",
        "output": "A null-terminated character string (NTS) in OpenROAD refers to a sequence of characters terminated by a null byte (ASCII NUL - hexadecimal '00'). This null byte serves as an end-of-string indicator. In contrast, variable-length string types like \"text\" or \"varchar\" are not null-terminated and do not have the null byte as their terminator. Instead, they use length fields to store the number of characters.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->3GL_procedures",
        "task_description": "Explain the features and creation process of 3GL procedures in Actian 4GL SQL.",
        "document": [
            "# 3GL Procedures\n\nA 3GL procedure is a procedure written in a third-generation language, such as C, that you can call by name from a script or 4GL procedure. 3GL procedures are used to perform operations that are outside the scope of OpenROAD but are available from a 3GL.\n\nYou maintain and compile 3GL procedures outside of OpenROAD. For more information about how to register 3GL procedures in an application, see the Workbench User Guide.\n\nThe following subsections describe how to declare parameters for 3GL procedures. They also provide language-specific information about coding the procedures. For more information about calling 3GL procedures, see Using 3GL in Your Application.\n\n## 3GL Parameters\n\nOpenROAD lets you pass simple variables to a 3GL procedure. You can also pass objects and arrays as described in the Language Reference Guide online help and in Using 3GL in Your Application. When you pass values to a 3GL procedure, the data type of the values must match the data types of the parameters receiving them in the procedure.\n\nThe following table lists the 4GL simple data types and describes their corresponding 3GL data type declarations:\n\n| 4GL Data Type | Host Variable Declaration |\n|---------------|---------------------------|\n| Char | Fixed-length, null-terminated character string. The size is determined by field size or declared variable length. Data entered into the field is padded with blank characters up to its full declared length before being passed to the 3GL procedure. |\n| Varchar | Variable-length, null-terminated character string. Unlike char type, varchar variables are not extended with blank characters before being passed to the 3GL procedure. |\n| date | Fixed-length, 25-byte, null-terminated character string |\n| money | Double |\n| float, f | Double |\n| integer | Long, 4-byte integer |\n| smallint | Integer, 4-byte integer |\n\nYou can use the byref option with any variable that you pass to a 3GL procedure, regardless of the variable's data type.\n\nYou cannot pass a char or varchar variable that contains an embedded zero byte (hexadecimal'00') to a 3GL procedure. No runtime error occurs, but a truncated version of the 4GL variable may be passed.\n\nWhen a 4GL date variable passes to a 3GL procedure by name, or when the return type of a 3GL procedure is date, 4GL receives it back from the 3GL procedure as a 25-byte string and must then convert it to the internal date format. The date must be valid before the conversion can succeed.\n\nPassing a 4GL variable containing a null value to a 3GL procedure causes a runtime error. Use the ifnull function and is null comparison operator to pass nullable types between 3GL and 4GL, for example:\n\n```\nifnull (v1, v2)\n```\n\nThis reference returns the value of v1 if v1 is not null; otherwise, if v1 is null, it returns the value of v2. The variables v1 and v2 must be the same data type.\n\nIf an impossible value exists for the argument, use the impossible value to indicate a null:\n\n```\ncallproc empcalc (ifnull (age, -1));\n```\n\nIf no impossible value exists for the argument, pass a separate indicator variable to indicate a null argument:\n\n```\nnull_indicator = 0;\nif (age is null) then\n     null_indicator = -1;\nendif;\ncallproc empcalc (age, null_indicator);\n```\n\n## Guidelines for Writing C Procedures\n\nUse the following syntax when writing a C procedure:\n\n```c\nprocname([parameters])\n{\n           processing statements\n}\n```\n\n> Note: You cannot name your C procedure \"main,\" and the procedure must not be static. You can call any C procedure from 4GL except the \"main\" function.\n\nFollow these guidelines for passing parameters to C procedures:\n\n- Pass an integer as four bytes by value (or by reference if byref is specified).\n- Pass a smallint as four bytes by value (or by reference if byref is specified).\n- Pass a float as a double-format float by value (or by reference, if byref is specified).\n\nTo ensure full portability, pass all floating point parameters to C procedures using the byref qualifier. For example, the following code fragment declares some variables and calls a C procedure, passing the procedure a floating-point parameter:\n\n```c\n/* variable declarations */\ntest_float = float;\ntest_integer = integer;\ntest_return = integer\n...\ntest_return = callproc myCproc (test_integer,\n                             byref(test_float));\n```\n\nThe corresponding C procedure is declared as follows:\n\n```c\nLong\nmyCproc (ivalue, fvalue)\nlong ivalue;\ndouble *fvalue;\n{\n     processing statements\n}\n```\n\n- Pass a string as a pointer to a null-terminated string as follows:\n  - Pass fixed-length string types (c, char) with trailing blanks up to their full length.\n  - Pass variable-length string types (text, varchar) without trailing blanks.\n\n- In this call to a procedure \"q\":\n\n```c\ncallproc q (1 + 2, 2.3, 'This is a string');\n```\n\nthe following declarations are required:\n\n```c\nq(x, y, z)\nlong x;\ndouble y; char *z;\n{...\n```\n\nTo receive x and y that are passed by reference, make the following changes to their formal argument declarations:\n\n```c\nlong *x;\ndouble *y;\n```\n\nNo changes are necessary to receive z that is passed by reference.",
            "```c\nlong *x;\ndouble *y;\n```\n\nNo changes are necessary to receive z that is passed by reference.\n\nA C procedure must return an int, a long, a double, or a char * value, as shown in the following examples.\n\n- To return an integer:\n\n```c\nint\nreti()\n{\nreturn 10;\n}\n```\n\n- To return a floating-point value:\n\n```c\ndouble\nretf()\n{\nreturn 10.5;\n}\n```\n\n- To return a character string:\n\n```c\nchar *\nrets()\n{\nreturn \"Returned from rets\";\n}\n```\n\nAny C procedure that returns a char * value to 4GL must return a pointer to a valid address (a string constant or static or global character buffer). The procedure cannot return a pointer to a local character buffer."
        ]
    },
    {
        "instruction": "Can you create a simple C procedure that accepts two parameters of type integer and double, performs some calculations on them, and returns the result as a double?",
        "input": "",
        "output": "Here's an example of creating a C procedure:\n```c\ndouble addAndMultiply (int i1, int i2, double f1, double f2) {\n    double sum = i1 + i2;\n    double product = f1 * f2;\n    return sum + product;\n}\n```\nYou can call the procedure from 4GL like this:\n```c\ncall \"addAndMultiply\" (3, 5, 2.3, 4.7);\n```",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->3GL_procedures",
        "task_description": "Explain the features and creation process of 3GL procedures in Actian 4GL SQL.",
        "document": [
            "# 3GL Procedures\n\nA 3GL procedure is a procedure written in a third-generation language, such as C, that you can call by name from a script or 4GL procedure. 3GL procedures are used to perform operations that are outside the scope of OpenROAD but are available from a 3GL.\n\nYou maintain and compile 3GL procedures outside of OpenROAD. For more information about how to register 3GL procedures in an application, see the Workbench User Guide.\n\nThe following subsections describe how to declare parameters for 3GL procedures. They also provide language-specific information about coding the procedures. For more information about calling 3GL procedures, see Using 3GL in Your Application.\n\n## 3GL Parameters\n\nOpenROAD lets you pass simple variables to a 3GL procedure. You can also pass objects and arrays as described in the Language Reference Guide online help and in Using 3GL in Your Application. When you pass values to a 3GL procedure, the data type of the values must match the data types of the parameters receiving them in the procedure.\n\nThe following table lists the 4GL simple data types and describes their corresponding 3GL data type declarations:\n\n| 4GL Data Type | Host Variable Declaration |\n|---------------|---------------------------|\n| Char | Fixed-length, null-terminated character string. The size is determined by field size or declared variable length. Data entered into the field is padded with blank characters up to its full declared length before being passed to the 3GL procedure. |\n| Varchar | Variable-length, null-terminated character string. Unlike char type, varchar variables are not extended with blank characters before being passed to the 3GL procedure. |\n| date | Fixed-length, 25-byte, null-terminated character string |\n| money | Double |\n| float, f | Double |\n| integer | Long, 4-byte integer |\n| smallint | Integer, 4-byte integer |\n\nYou can use the byref option with any variable that you pass to a 3GL procedure, regardless of the variable's data type.\n\nYou cannot pass a char or varchar variable that contains an embedded zero byte (hexadecimal'00') to a 3GL procedure. No runtime error occurs, but a truncated version of the 4GL variable may be passed.\n\nWhen a 4GL date variable passes to a 3GL procedure by name, or when the return type of a 3GL procedure is date, 4GL receives it back from the 3GL procedure as a 25-byte string and must then convert it to the internal date format. The date must be valid before the conversion can succeed.\n\nPassing a 4GL variable containing a null value to a 3GL procedure causes a runtime error. Use the ifnull function and is null comparison operator to pass nullable types between 3GL and 4GL, for example:\n\n```\nifnull (v1, v2)\n```\n\nThis reference returns the value of v1 if v1 is not null; otherwise, if v1 is null, it returns the value of v2. The variables v1 and v2 must be the same data type.\n\nIf an impossible value exists for the argument, use the impossible value to indicate a null:\n\n```\ncallproc empcalc (ifnull (age, -1));\n```\n\nIf no impossible value exists for the argument, pass a separate indicator variable to indicate a null argument:\n\n```\nnull_indicator = 0;\nif (age is null) then\n     null_indicator = -1;\nendif;\ncallproc empcalc (age, null_indicator);\n```\n\n## Guidelines for Writing C Procedures\n\nUse the following syntax when writing a C procedure:\n\n```c\nprocname([parameters])\n{\n           processing statements\n}\n```\n\n> Note: You cannot name your C procedure \"main,\" and the procedure must not be static. You can call any C procedure from 4GL except the \"main\" function.\n\nFollow these guidelines for passing parameters to C procedures:\n\n- Pass an integer as four bytes by value (or by reference if byref is specified).\n- Pass a smallint as four bytes by value (or by reference if byref is specified).\n- Pass a float as a double-format float by value (or by reference, if byref is specified).\n\nTo ensure full portability, pass all floating point parameters to C procedures using the byref qualifier. For example, the following code fragment declares some variables and calls a C procedure, passing the procedure a floating-point parameter:\n\n```c\n/* variable declarations */\ntest_float = float;\ntest_integer = integer;\ntest_return = integer\n...\ntest_return = callproc myCproc (test_integer,\n                             byref(test_float));\n```\n\nThe corresponding C procedure is declared as follows:\n\n```c\nLong\nmyCproc (ivalue, fvalue)\nlong ivalue;\ndouble *fvalue;\n{\n     processing statements\n}\n```\n\n- Pass a string as a pointer to a null-terminated string as follows:\n  - Pass fixed-length string types (c, char) with trailing blanks up to their full length.\n  - Pass variable-length string types (text, varchar) without trailing blanks.\n\n- In this call to a procedure \"q\":\n\n```c\ncallproc q (1 + 2, 2.3, 'This is a string');\n```\n\nthe following declarations are required:\n\n```c\nq(x, y, z)\nlong x;\ndouble y; char *z;\n{...\n```\n\nTo receive x and y that are passed by reference, make the following changes to their formal argument declarations:\n\n```c\nlong *x;\ndouble *y;\n```\n\nNo changes are necessary to receive z that is passed by reference.",
            "```c\nlong *x;\ndouble *y;\n```\n\nNo changes are necessary to receive z that is passed by reference.\n\nA C procedure must return an int, a long, a double, or a char * value, as shown in the following examples.\n\n- To return an integer:\n\n```c\nint\nreti()\n{\nreturn 10;\n}\n```\n\n- To return a floating-point value:\n\n```c\ndouble\nretf()\n{\nreturn 10.5;\n}\n```\n\n- To return a character string:\n\n```c\nchar *\nrets()\n{\nreturn \"Returned from rets\";\n}\n```\n\nAny C procedure that returns a char * value to 4GL must return a pointer to a valid address (a string constant or static or global character buffer). The procedure cannot return a pointer to a local character buffer."
        ]
    },
    {
        "instruction": "Provide examples for passing parameters to C procedures and their declarations using the syntax mentioned in the document.",
        "input": "",
        "output": "To write a C procedure, you can use the following syntax:\n```c\nprocname([parameters])\n{\n           processing statements\n}\n```\nFor example:\n```c\nmyCProc(int param1, double param2)\n{\n   // Processing Statements\n}\n```\nIn this call to the procedure `myCProc`, you can pass an integer and a floating point number:\n```c\ncallproc myCProc(5, 6.0);\n```\nWhen passing floating-point numbers, ensure full portability by using the `byref` qualifier:\n```c\nfloat test_float = float; // Variable declaration\n// Passing the variable to a C procedure\ncallproc myCProc(test_integer, byref(test_float));\n```\nThe corresponding C procedure is declared as follows:\n```c\nvoid myCProc (long param1, double* param2)\n{\n    // Processing statements using param1 and param2\n}\n```",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->3GL_procedures",
        "task_description": "Explain the features and creation process of 3GL procedures in Actian 4GL SQL.",
        "document": [
            "# 3GL Procedures\n\nA 3GL procedure is a procedure written in a third-generation language, such as C, that you can call by name from a script or 4GL procedure. 3GL procedures are used to perform operations that are outside the scope of OpenROAD but are available from a 3GL.\n\nYou maintain and compile 3GL procedures outside of OpenROAD. For more information about how to register 3GL procedures in an application, see the Workbench User Guide.\n\nThe following subsections describe how to declare parameters for 3GL procedures. They also provide language-specific information about coding the procedures. For more information about calling 3GL procedures, see Using 3GL in Your Application.\n\n## 3GL Parameters\n\nOpenROAD lets you pass simple variables to a 3GL procedure. You can also pass objects and arrays as described in the Language Reference Guide online help and in Using 3GL in Your Application. When you pass values to a 3GL procedure, the data type of the values must match the data types of the parameters receiving them in the procedure.\n\nThe following table lists the 4GL simple data types and describes their corresponding 3GL data type declarations:\n\n| 4GL Data Type | Host Variable Declaration |\n|---------------|---------------------------|\n| Char | Fixed-length, null-terminated character string. The size is determined by field size or declared variable length. Data entered into the field is padded with blank characters up to its full declared length before being passed to the 3GL procedure. |\n| Varchar | Variable-length, null-terminated character string. Unlike char type, varchar variables are not extended with blank characters before being passed to the 3GL procedure. |\n| date | Fixed-length, 25-byte, null-terminated character string |\n| money | Double |\n| float, f | Double |\n| integer | Long, 4-byte integer |\n| smallint | Integer, 4-byte integer |\n\nYou can use the byref option with any variable that you pass to a 3GL procedure, regardless of the variable's data type.\n\nYou cannot pass a char or varchar variable that contains an embedded zero byte (hexadecimal'00') to a 3GL procedure. No runtime error occurs, but a truncated version of the 4GL variable may be passed.\n\nWhen a 4GL date variable passes to a 3GL procedure by name, or when the return type of a 3GL procedure is date, 4GL receives it back from the 3GL procedure as a 25-byte string and must then convert it to the internal date format. The date must be valid before the conversion can succeed.\n\nPassing a 4GL variable containing a null value to a 3GL procedure causes a runtime error. Use the ifnull function and is null comparison operator to pass nullable types between 3GL and 4GL, for example:\n\n```\nifnull (v1, v2)\n```\n\nThis reference returns the value of v1 if v1 is not null; otherwise, if v1 is null, it returns the value of v2. The variables v1 and v2 must be the same data type.\n\nIf an impossible value exists for the argument, use the impossible value to indicate a null:\n\n```\ncallproc empcalc (ifnull (age, -1));\n```\n\nIf no impossible value exists for the argument, pass a separate indicator variable to indicate a null argument:\n\n```\nnull_indicator = 0;\nif (age is null) then\n     null_indicator = -1;\nendif;\ncallproc empcalc (age, null_indicator);\n```\n\n## Guidelines for Writing C Procedures\n\nUse the following syntax when writing a C procedure:\n\n```c\nprocname([parameters])\n{\n           processing statements\n}\n```\n\n> Note: You cannot name your C procedure \"main,\" and the procedure must not be static. You can call any C procedure from 4GL except the \"main\" function.\n\nFollow these guidelines for passing parameters to C procedures:\n\n- Pass an integer as four bytes by value (or by reference if byref is specified).\n- Pass a smallint as four bytes by value (or by reference if byref is specified).\n- Pass a float as a double-format float by value (or by reference, if byref is specified).\n\nTo ensure full portability, pass all floating point parameters to C procedures using the byref qualifier. For example, the following code fragment declares some variables and calls a C procedure, passing the procedure a floating-point parameter:\n\n```c\n/* variable declarations */\ntest_float = float;\ntest_integer = integer;\ntest_return = integer\n...\ntest_return = callproc myCproc (test_integer,\n                             byref(test_float));\n```\n\nThe corresponding C procedure is declared as follows:\n\n```c\nLong\nmyCproc (ivalue, fvalue)\nlong ivalue;\ndouble *fvalue;\n{\n     processing statements\n}\n```\n\n- Pass a string as a pointer to a null-terminated string as follows:\n  - Pass fixed-length string types (c, char) with trailing blanks up to their full length.\n  - Pass variable-length string types (text, varchar) without trailing blanks.\n\n- In this call to a procedure \"q\":\n\n```c\ncallproc q (1 + 2, 2.3, 'This is a string');\n```\n\nthe following declarations are required:\n\n```c\nq(x, y, z)\nlong x;\ndouble y; char *z;\n{...\n```\n\nTo receive x and y that are passed by reference, make the following changes to their formal argument declarations:\n\n```c\nlong *x;\ndouble *y;\n```\n\nNo changes are necessary to receive z that is passed by reference.",
            "```c\nlong *x;\ndouble *y;\n```\n\nNo changes are necessary to receive z that is passed by reference.\n\nA C procedure must return an int, a long, a double, or a char * value, as shown in the following examples.\n\n- To return an integer:\n\n```c\nint\nreti()\n{\nreturn 10;\n}\n```\n\n- To return a floating-point value:\n\n```c\ndouble\nretf()\n{\nreturn 10.5;\n}\n```\n\n- To return a character string:\n\n```c\nchar *\nrets()\n{\nreturn \"Returned from rets\";\n}\n```\n\nAny C procedure that returns a char * value to 4GL must return a pointer to a valid address (a string constant or static or global character buffer). The procedure cannot return a pointer to a local character buffer."
        ]
    },
    {
        "instruction": "What happens when a 4GL date variable is passed to a 3GL procedure by name or when the return type of the 3GL procedure is 'date' in OpenROAD?",
        "input": "",
        "output": "When a 4GL date variable is passed to a 3GL procedure by name or when the return type of the 3GL procedure is 'date', 4GL receives it back as a 25-byte string, and it must then convert it into the internal date format. The date must be valid before the conversion can succeed.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->3GL_procedures",
        "task_description": "Explain the features and creation process of 3GL procedures in Actian 4GL SQL.",
        "document": [
            "# 3GL Procedures\n\nA 3GL procedure is a procedure written in a third-generation language, such as C, that you can call by name from a script or 4GL procedure. 3GL procedures are used to perform operations that are outside the scope of OpenROAD but are available from a 3GL.\n\nYou maintain and compile 3GL procedures outside of OpenROAD. For more information about how to register 3GL procedures in an application, see the Workbench User Guide.\n\nThe following subsections describe how to declare parameters for 3GL procedures. They also provide language-specific information about coding the procedures. For more information about calling 3GL procedures, see Using 3GL in Your Application.\n\n## 3GL Parameters\n\nOpenROAD lets you pass simple variables to a 3GL procedure. You can also pass objects and arrays as described in the Language Reference Guide online help and in Using 3GL in Your Application. When you pass values to a 3GL procedure, the data type of the values must match the data types of the parameters receiving them in the procedure.\n\nThe following table lists the 4GL simple data types and describes their corresponding 3GL data type declarations:\n\n| 4GL Data Type | Host Variable Declaration |\n|---------------|---------------------------|\n| Char | Fixed-length, null-terminated character string. The size is determined by field size or declared variable length. Data entered into the field is padded with blank characters up to its full declared length before being passed to the 3GL procedure. |\n| Varchar | Variable-length, null-terminated character string. Unlike char type, varchar variables are not extended with blank characters before being passed to the 3GL procedure. |\n| date | Fixed-length, 25-byte, null-terminated character string |\n| money | Double |\n| float, f | Double |\n| integer | Long, 4-byte integer |\n| smallint | Integer, 4-byte integer |\n\nYou can use the byref option with any variable that you pass to a 3GL procedure, regardless of the variable's data type.\n\nYou cannot pass a char or varchar variable that contains an embedded zero byte (hexadecimal'00') to a 3GL procedure. No runtime error occurs, but a truncated version of the 4GL variable may be passed.\n\nWhen a 4GL date variable passes to a 3GL procedure by name, or when the return type of a 3GL procedure is date, 4GL receives it back from the 3GL procedure as a 25-byte string and must then convert it to the internal date format. The date must be valid before the conversion can succeed.\n\nPassing a 4GL variable containing a null value to a 3GL procedure causes a runtime error. Use the ifnull function and is null comparison operator to pass nullable types between 3GL and 4GL, for example:\n\n```\nifnull (v1, v2)\n```\n\nThis reference returns the value of v1 if v1 is not null; otherwise, if v1 is null, it returns the value of v2. The variables v1 and v2 must be the same data type.\n\nIf an impossible value exists for the argument, use the impossible value to indicate a null:\n\n```\ncallproc empcalc (ifnull (age, -1));\n```\n\nIf no impossible value exists for the argument, pass a separate indicator variable to indicate a null argument:\n\n```\nnull_indicator = 0;\nif (age is null) then\n     null_indicator = -1;\nendif;\ncallproc empcalc (age, null_indicator);\n```\n\n## Guidelines for Writing C Procedures\n\nUse the following syntax when writing a C procedure:\n\n```c\nprocname([parameters])\n{\n           processing statements\n}\n```\n\n> Note: You cannot name your C procedure \"main,\" and the procedure must not be static. You can call any C procedure from 4GL except the \"main\" function.\n\nFollow these guidelines for passing parameters to C procedures:\n\n- Pass an integer as four bytes by value (or by reference if byref is specified).\n- Pass a smallint as four bytes by value (or by reference if byref is specified).\n- Pass a float as a double-format float by value (or by reference, if byref is specified).\n\nTo ensure full portability, pass all floating point parameters to C procedures using the byref qualifier. For example, the following code fragment declares some variables and calls a C procedure, passing the procedure a floating-point parameter:\n\n```c\n/* variable declarations */\ntest_float = float;\ntest_integer = integer;\ntest_return = integer\n...\ntest_return = callproc myCproc (test_integer,\n                             byref(test_float));\n```\n\nThe corresponding C procedure is declared as follows:\n\n```c\nLong\nmyCproc (ivalue, fvalue)\nlong ivalue;\ndouble *fvalue;\n{\n     processing statements\n}\n```\n\n- Pass a string as a pointer to a null-terminated string as follows:\n  - Pass fixed-length string types (c, char) with trailing blanks up to their full length.\n  - Pass variable-length string types (text, varchar) without trailing blanks.\n\n- In this call to a procedure \"q\":\n\n```c\ncallproc q (1 + 2, 2.3, 'This is a string');\n```\n\nthe following declarations are required:\n\n```c\nq(x, y, z)\nlong x;\ndouble y; char *z;\n{...\n```\n\nTo receive x and y that are passed by reference, make the following changes to their formal argument declarations:\n\n```c\nlong *x;\ndouble *y;\n```\n\nNo changes are necessary to receive z that is passed by reference.",
            "```c\nlong *x;\ndouble *y;\n```\n\nNo changes are necessary to receive z that is passed by reference.\n\nA C procedure must return an int, a long, a double, or a char * value, as shown in the following examples.\n\n- To return an integer:\n\n```c\nint\nreti()\n{\nreturn 10;\n}\n```\n\n- To return a floating-point value:\n\n```c\ndouble\nretf()\n{\nreturn 10.5;\n}\n```\n\n- To return a character string:\n\n```c\nchar *\nrets()\n{\nreturn \"Returned from rets\";\n}\n```\n\nAny C procedure that returns a char * value to 4GL must return a pointer to a valid address (a string constant or static or global character buffer). The procedure cannot return a pointer to a local character buffer."
        ]
    },
    {
        "instruction": "Describe how to write a C procedure that returns an integer value in Actian 4GL SQL?",
        "input": "",
        "output": "To write a C procedure in Actian 4GL SQL that returns an integer value, follow these steps:\n\n1. First, declare the function's return type as int and give it a name (e.g., `reti`).\n2. Within the function, use the \"return\" statement to assign the desired integer value (e.g., 10) that will be returned by the function.\n3. Save your C code in an external file.\n4. Call this C procedure from your SQL script using the `call c_program` statement and include the required path to the source code file as a parameter. For example:\n```sql\ncall c_program ('path/to/myCproc');\n```",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->3GL_procedures",
        "task_description": "Explain the features and creation process of 3GL procedures in Actian 4GL SQL.",
        "document": [
            "# 3GL Procedures\n\nA 3GL procedure is a procedure written in a third-generation language, such as C, that you can call by name from a script or 4GL procedure. 3GL procedures are used to perform operations that are outside the scope of OpenROAD but are available from a 3GL.\n\nYou maintain and compile 3GL procedures outside of OpenROAD. For more information about how to register 3GL procedures in an application, see the Workbench User Guide.\n\nThe following subsections describe how to declare parameters for 3GL procedures. They also provide language-specific information about coding the procedures. For more information about calling 3GL procedures, see Using 3GL in Your Application.\n\n## 3GL Parameters\n\nOpenROAD lets you pass simple variables to a 3GL procedure. You can also pass objects and arrays as described in the Language Reference Guide online help and in Using 3GL in Your Application. When you pass values to a 3GL procedure, the data type of the values must match the data types of the parameters receiving them in the procedure.\n\nThe following table lists the 4GL simple data types and describes their corresponding 3GL data type declarations:\n\n| 4GL Data Type | Host Variable Declaration |\n|---------------|---------------------------|\n| Char | Fixed-length, null-terminated character string. The size is determined by field size or declared variable length. Data entered into the field is padded with blank characters up to its full declared length before being passed to the 3GL procedure. |\n| Varchar | Variable-length, null-terminated character string. Unlike char type, varchar variables are not extended with blank characters before being passed to the 3GL procedure. |\n| date | Fixed-length, 25-byte, null-terminated character string |\n| money | Double |\n| float, f | Double |\n| integer | Long, 4-byte integer |\n| smallint | Integer, 4-byte integer |\n\nYou can use the byref option with any variable that you pass to a 3GL procedure, regardless of the variable's data type.\n\nYou cannot pass a char or varchar variable that contains an embedded zero byte (hexadecimal'00') to a 3GL procedure. No runtime error occurs, but a truncated version of the 4GL variable may be passed.\n\nWhen a 4GL date variable passes to a 3GL procedure by name, or when the return type of a 3GL procedure is date, 4GL receives it back from the 3GL procedure as a 25-byte string and must then convert it to the internal date format. The date must be valid before the conversion can succeed.\n\nPassing a 4GL variable containing a null value to a 3GL procedure causes a runtime error. Use the ifnull function and is null comparison operator to pass nullable types between 3GL and 4GL, for example:\n\n```\nifnull (v1, v2)\n```\n\nThis reference returns the value of v1 if v1 is not null; otherwise, if v1 is null, it returns the value of v2. The variables v1 and v2 must be the same data type.\n\nIf an impossible value exists for the argument, use the impossible value to indicate a null:\n\n```\ncallproc empcalc (ifnull (age, -1));\n```\n\nIf no impossible value exists for the argument, pass a separate indicator variable to indicate a null argument:\n\n```\nnull_indicator = 0;\nif (age is null) then\n     null_indicator = -1;\nendif;\ncallproc empcalc (age, null_indicator);\n```\n\n## Guidelines for Writing C Procedures\n\nUse the following syntax when writing a C procedure:\n\n```c\nprocname([parameters])\n{\n           processing statements\n}\n```\n\n> Note: You cannot name your C procedure \"main,\" and the procedure must not be static. You can call any C procedure from 4GL except the \"main\" function.\n\nFollow these guidelines for passing parameters to C procedures:\n\n- Pass an integer as four bytes by value (or by reference if byref is specified).\n- Pass a smallint as four bytes by value (or by reference if byref is specified).\n- Pass a float as a double-format float by value (or by reference, if byref is specified).\n\nTo ensure full portability, pass all floating point parameters to C procedures using the byref qualifier. For example, the following code fragment declares some variables and calls a C procedure, passing the procedure a floating-point parameter:\n\n```c\n/* variable declarations */\ntest_float = float;\ntest_integer = integer;\ntest_return = integer\n...\ntest_return = callproc myCproc (test_integer,\n                             byref(test_float));\n```\n\nThe corresponding C procedure is declared as follows:\n\n```c\nLong\nmyCproc (ivalue, fvalue)\nlong ivalue;\ndouble *fvalue;\n{\n     processing statements\n}\n```\n\n- Pass a string as a pointer to a null-terminated string as follows:\n  - Pass fixed-length string types (c, char) with trailing blanks up to their full length.\n  - Pass variable-length string types (text, varchar) without trailing blanks.\n\n- In this call to a procedure \"q\":\n\n```c\ncallproc q (1 + 2, 2.3, 'This is a string');\n```\n\nthe following declarations are required:\n\n```c\nq(x, y, z)\nlong x;\ndouble y; char *z;\n{...\n```\n\nTo receive x and y that are passed by reference, make the following changes to their formal argument declarations:\n\n```c\nlong *x;\ndouble *y;\n```\n\nNo changes are necessary to receive z that is passed by reference.",
            "```c\nlong *x;\ndouble *y;\n```\n\nNo changes are necessary to receive z that is passed by reference.\n\nA C procedure must return an int, a long, a double, or a char * value, as shown in the following examples.\n\n- To return an integer:\n\n```c\nint\nreti()\n{\nreturn 10;\n}\n```\n\n- To return a floating-point value:\n\n```c\ndouble\nretf()\n{\nreturn 10.5;\n}\n```\n\n- To return a character string:\n\n```c\nchar *\nrets()\n{\nreturn \"Returned from rets\";\n}\n```\n\nAny C procedure that returns a char * value to 4GL must return a pointer to a valid address (a string constant or static or global character buffer). The procedure cannot return a pointer to a local character buffer."
        ]
    },
    {
        "instruction": "What is meant by the term \"static\" in C programming, and how does it apply when passing parameters from OpenROAD to a C procedure?",
        "input": "",
        "output": "In C programming, the keyword \"static\" denotes that a variable or function has a lifespan beyond the current function call. When passing parameters from OpenROAD to a C procedure, static variables in the C procedure can be used as a persistent storage area to maintain data across multiple calls. This is useful if you want your C procedure to remember the state of its internal variables between invocations.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->3GL_procedures",
        "task_description": "Explain the features and creation process of 3GL procedures in Actian 4GL SQL.",
        "document": [
            "# 3GL Procedures\n\nA 3GL procedure is a procedure written in a third-generation language, such as C, that you can call by name from a script or 4GL procedure. 3GL procedures are used to perform operations that are outside the scope of OpenROAD but are available from a 3GL.\n\nYou maintain and compile 3GL procedures outside of OpenROAD. For more information about how to register 3GL procedures in an application, see the Workbench User Guide.\n\nThe following subsections describe how to declare parameters for 3GL procedures. They also provide language-specific information about coding the procedures. For more information about calling 3GL procedures, see Using 3GL in Your Application.\n\n## 3GL Parameters\n\nOpenROAD lets you pass simple variables to a 3GL procedure. You can also pass objects and arrays as described in the Language Reference Guide online help and in Using 3GL in Your Application. When you pass values to a 3GL procedure, the data type of the values must match the data types of the parameters receiving them in the procedure.\n\nThe following table lists the 4GL simple data types and describes their corresponding 3GL data type declarations:\n\n| 4GL Data Type | Host Variable Declaration |\n|---------------|---------------------------|\n| Char | Fixed-length, null-terminated character string. The size is determined by field size or declared variable length. Data entered into the field is padded with blank characters up to its full declared length before being passed to the 3GL procedure. |\n| Varchar | Variable-length, null-terminated character string. Unlike char type, varchar variables are not extended with blank characters before being passed to the 3GL procedure. |\n| date | Fixed-length, 25-byte, null-terminated character string |\n| money | Double |\n| float, f | Double |\n| integer | Long, 4-byte integer |\n| smallint | Integer, 4-byte integer |\n\nYou can use the byref option with any variable that you pass to a 3GL procedure, regardless of the variable's data type.\n\nYou cannot pass a char or varchar variable that contains an embedded zero byte (hexadecimal'00') to a 3GL procedure. No runtime error occurs, but a truncated version of the 4GL variable may be passed.\n\nWhen a 4GL date variable passes to a 3GL procedure by name, or when the return type of a 3GL procedure is date, 4GL receives it back from the 3GL procedure as a 25-byte string and must then convert it to the internal date format. The date must be valid before the conversion can succeed.\n\nPassing a 4GL variable containing a null value to a 3GL procedure causes a runtime error. Use the ifnull function and is null comparison operator to pass nullable types between 3GL and 4GL, for example:\n\n```\nifnull (v1, v2)\n```\n\nThis reference returns the value of v1 if v1 is not null; otherwise, if v1 is null, it returns the value of v2. The variables v1 and v2 must be the same data type.\n\nIf an impossible value exists for the argument, use the impossible value to indicate a null:\n\n```\ncallproc empcalc (ifnull (age, -1));\n```\n\nIf no impossible value exists for the argument, pass a separate indicator variable to indicate a null argument:\n\n```\nnull_indicator = 0;\nif (age is null) then\n     null_indicator = -1;\nendif;\ncallproc empcalc (age, null_indicator);\n```\n\n## Guidelines for Writing C Procedures\n\nUse the following syntax when writing a C procedure:\n\n```c\nprocname([parameters])\n{\n           processing statements\n}\n```\n\n> Note: You cannot name your C procedure \"main,\" and the procedure must not be static. You can call any C procedure from 4GL except the \"main\" function.\n\nFollow these guidelines for passing parameters to C procedures:\n\n- Pass an integer as four bytes by value (or by reference if byref is specified).\n- Pass a smallint as four bytes by value (or by reference if byref is specified).\n- Pass a float as a double-format float by value (or by reference, if byref is specified).\n\nTo ensure full portability, pass all floating point parameters to C procedures using the byref qualifier. For example, the following code fragment declares some variables and calls a C procedure, passing the procedure a floating-point parameter:\n\n```c\n/* variable declarations */\ntest_float = float;\ntest_integer = integer;\ntest_return = integer\n...\ntest_return = callproc myCproc (test_integer,\n                             byref(test_float));\n```\n\nThe corresponding C procedure is declared as follows:\n\n```c\nLong\nmyCproc (ivalue, fvalue)\nlong ivalue;\ndouble *fvalue;\n{\n     processing statements\n}\n```\n\n- Pass a string as a pointer to a null-terminated string as follows:\n  - Pass fixed-length string types (c, char) with trailing blanks up to their full length.\n  - Pass variable-length string types (text, varchar) without trailing blanks.\n\n- In this call to a procedure \"q\":\n\n```c\ncallproc q (1 + 2, 2.3, 'This is a string');\n```\n\nthe following declarations are required:\n\n```c\nq(x, y, z)\nlong x;\ndouble y; char *z;\n{...\n```\n\nTo receive x and y that are passed by reference, make the following changes to their formal argument declarations:\n\n```c\nlong *x;\ndouble *y;\n```\n\nNo changes are necessary to receive z that is passed by reference.",
            "```c\nlong *x;\ndouble *y;\n```\n\nNo changes are necessary to receive z that is passed by reference.\n\nA C procedure must return an int, a long, a double, or a char * value, as shown in the following examples.\n\n- To return an integer:\n\n```c\nint\nreti()\n{\nreturn 10;\n}\n```\n\n- To return a floating-point value:\n\n```c\ndouble\nretf()\n{\nreturn 10.5;\n}\n```\n\n- To return a character string:\n\n```c\nchar *\nrets()\n{\nreturn \"Returned from rets\";\n}\n```\n\nAny C procedure that returns a char * value to 4GL must return a pointer to a valid address (a string constant or static or global character buffer). The procedure cannot return a pointer to a local character buffer."
        ]
    },
    {
        "instruction": "List the steps for compiling a 3GL procedure outside of OpenROAD.",
        "input": "",
        "output": "Here's a list of steps to compile and maintain a 3GL procedure outside OpenROAD:\n1. Write the code in your preferred programming language (C, for example).\n2. Save the file with a proper name and extension (e.g., `myprocedure.c`).\n3. Compile the code using appropriate tools and settings for your operating system (e.g., `gcc -o myprocedure myprocedure.c` on Linux).\n4. Make sure you've correctly linked any required libraries.\n5. Test your compiled 3GL procedure outside OpenROAD to verify that it works as expected.\n6. Once everything is working properly, register the compiled 3GL procedure with an application in Workbench following the instructions in the Workbench User Guide.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->3GL_procedures",
        "task_description": "Explain the features and creation process of 3GL procedures in Actian 4GL SQL.",
        "document": [
            "# 3GL Procedures\n\nA 3GL procedure is a procedure written in a third-generation language, such as C, that you can call by name from a script or 4GL procedure. 3GL procedures are used to perform operations that are outside the scope of OpenROAD but are available from a 3GL.\n\nYou maintain and compile 3GL procedures outside of OpenROAD. For more information about how to register 3GL procedures in an application, see the Workbench User Guide.\n\nThe following subsections describe how to declare parameters for 3GL procedures. They also provide language-specific information about coding the procedures. For more information about calling 3GL procedures, see Using 3GL in Your Application.\n\n## 3GL Parameters\n\nOpenROAD lets you pass simple variables to a 3GL procedure. You can also pass objects and arrays as described in the Language Reference Guide online help and in Using 3GL in Your Application. When you pass values to a 3GL procedure, the data type of the values must match the data types of the parameters receiving them in the procedure.\n\nThe following table lists the 4GL simple data types and describes their corresponding 3GL data type declarations:\n\n| 4GL Data Type | Host Variable Declaration |\n|---------------|---------------------------|\n| Char | Fixed-length, null-terminated character string. The size is determined by field size or declared variable length. Data entered into the field is padded with blank characters up to its full declared length before being passed to the 3GL procedure. |\n| Varchar | Variable-length, null-terminated character string. Unlike char type, varchar variables are not extended with blank characters before being passed to the 3GL procedure. |\n| date | Fixed-length, 25-byte, null-terminated character string |\n| money | Double |\n| float, f | Double |\n| integer | Long, 4-byte integer |\n| smallint | Integer, 4-byte integer |\n\nYou can use the byref option with any variable that you pass to a 3GL procedure, regardless of the variable's data type.\n\nYou cannot pass a char or varchar variable that contains an embedded zero byte (hexadecimal'00') to a 3GL procedure. No runtime error occurs, but a truncated version of the 4GL variable may be passed.\n\nWhen a 4GL date variable passes to a 3GL procedure by name, or when the return type of a 3GL procedure is date, 4GL receives it back from the 3GL procedure as a 25-byte string and must then convert it to the internal date format. The date must be valid before the conversion can succeed.\n\nPassing a 4GL variable containing a null value to a 3GL procedure causes a runtime error. Use the ifnull function and is null comparison operator to pass nullable types between 3GL and 4GL, for example:\n\n```\nifnull (v1, v2)\n```\n\nThis reference returns the value of v1 if v1 is not null; otherwise, if v1 is null, it returns the value of v2. The variables v1 and v2 must be the same data type.\n\nIf an impossible value exists for the argument, use the impossible value to indicate a null:\n\n```\ncallproc empcalc (ifnull (age, -1));\n```\n\nIf no impossible value exists for the argument, pass a separate indicator variable to indicate a null argument:\n\n```\nnull_indicator = 0;\nif (age is null) then\n     null_indicator = -1;\nendif;\ncallproc empcalc (age, null_indicator);\n```\n\n## Guidelines for Writing C Procedures\n\nUse the following syntax when writing a C procedure:\n\n```c\nprocname([parameters])\n{\n           processing statements\n}\n```\n\n> Note: You cannot name your C procedure \"main,\" and the procedure must not be static. You can call any C procedure from 4GL except the \"main\" function.\n\nFollow these guidelines for passing parameters to C procedures:\n\n- Pass an integer as four bytes by value (or by reference if byref is specified).\n- Pass a smallint as four bytes by value (or by reference if byref is specified).\n- Pass a float as a double-format float by value (or by reference, if byref is specified).\n\nTo ensure full portability, pass all floating point parameters to C procedures using the byref qualifier. For example, the following code fragment declares some variables and calls a C procedure, passing the procedure a floating-point parameter:\n\n```c\n/* variable declarations */\ntest_float = float;\ntest_integer = integer;\ntest_return = integer\n...\ntest_return = callproc myCproc (test_integer,\n                             byref(test_float));\n```\n\nThe corresponding C procedure is declared as follows:\n\n```c\nLong\nmyCproc (ivalue, fvalue)\nlong ivalue;\ndouble *fvalue;\n{\n     processing statements\n}\n```\n\n- Pass a string as a pointer to a null-terminated string as follows:\n  - Pass fixed-length string types (c, char) with trailing blanks up to their full length.\n  - Pass variable-length string types (text, varchar) without trailing blanks.\n\n- In this call to a procedure \"q\":\n\n```c\ncallproc q (1 + 2, 2.3, 'This is a string');\n```\n\nthe following declarations are required:\n\n```c\nq(x, y, z)\nlong x;\ndouble y; char *z;\n{...\n```\n\nTo receive x and y that are passed by reference, make the following changes to their formal argument declarations:\n\n```c\nlong *x;\ndouble *y;\n```\n\nNo changes are necessary to receive z that is passed by reference.",
            "```c\nlong *x;\ndouble *y;\n```\n\nNo changes are necessary to receive z that is passed by reference.\n\nA C procedure must return an int, a long, a double, or a char * value, as shown in the following examples.\n\n- To return an integer:\n\n```c\nint\nreti()\n{\nreturn 10;\n}\n```\n\n- To return a floating-point value:\n\n```c\ndouble\nretf()\n{\nreturn 10.5;\n}\n```\n\n- To return a character string:\n\n```c\nchar *\nrets()\n{\nreturn \"Returned from rets\";\n}\n```\n\nAny C procedure that returns a char * value to 4GL must return a pointer to a valid address (a string constant or static or global character buffer). The procedure cannot return a pointer to a local character buffer."
        ]
    },
    {
        "instruction": "What data types can be passed to a 3GL procedure in OpenROAD?",
        "input": "",
        "output": "You can pass simple variables, objects, arrays, char, varchar, date, money, float, f, integer, smallint, and double values to a 3GL procedure in OpenROAD. For more information about passing specific data types, see the Workbench User Guide or Language Reference Guide online help.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->3GL_procedures",
        "task_description": "Explain the features and creation process of 3GL procedures in Actian 4GL SQL.",
        "document": [
            "# 3GL Procedures\n\nA 3GL procedure is a procedure written in a third-generation language, such as C, that you can call by name from a script or 4GL procedure. 3GL procedures are used to perform operations that are outside the scope of OpenROAD but are available from a 3GL.\n\nYou maintain and compile 3GL procedures outside of OpenROAD. For more information about how to register 3GL procedures in an application, see the Workbench User Guide.\n\nThe following subsections describe how to declare parameters for 3GL procedures. They also provide language-specific information about coding the procedures. For more information about calling 3GL procedures, see Using 3GL in Your Application.\n\n## 3GL Parameters\n\nOpenROAD lets you pass simple variables to a 3GL procedure. You can also pass objects and arrays as described in the Language Reference Guide online help and in Using 3GL in Your Application. When you pass values to a 3GL procedure, the data type of the values must match the data types of the parameters receiving them in the procedure.\n\nThe following table lists the 4GL simple data types and describes their corresponding 3GL data type declarations:\n\n| 4GL Data Type | Host Variable Declaration |\n|---------------|---------------------------|\n| Char | Fixed-length, null-terminated character string. The size is determined by field size or declared variable length. Data entered into the field is padded with blank characters up to its full declared length before being passed to the 3GL procedure. |\n| Varchar | Variable-length, null-terminated character string. Unlike char type, varchar variables are not extended with blank characters before being passed to the 3GL procedure. |\n| date | Fixed-length, 25-byte, null-terminated character string |\n| money | Double |\n| float, f | Double |\n| integer | Long, 4-byte integer |\n| smallint | Integer, 4-byte integer |\n\nYou can use the byref option with any variable that you pass to a 3GL procedure, regardless of the variable's data type.\n\nYou cannot pass a char or varchar variable that contains an embedded zero byte (hexadecimal'00') to a 3GL procedure. No runtime error occurs, but a truncated version of the 4GL variable may be passed.\n\nWhen a 4GL date variable passes to a 3GL procedure by name, or when the return type of a 3GL procedure is date, 4GL receives it back from the 3GL procedure as a 25-byte string and must then convert it to the internal date format. The date must be valid before the conversion can succeed.\n\nPassing a 4GL variable containing a null value to a 3GL procedure causes a runtime error. Use the ifnull function and is null comparison operator to pass nullable types between 3GL and 4GL, for example:\n\n```\nifnull (v1, v2)\n```\n\nThis reference returns the value of v1 if v1 is not null; otherwise, if v1 is null, it returns the value of v2. The variables v1 and v2 must be the same data type.\n\nIf an impossible value exists for the argument, use the impossible value to indicate a null:\n\n```\ncallproc empcalc (ifnull (age, -1));\n```\n\nIf no impossible value exists for the argument, pass a separate indicator variable to indicate a null argument:\n\n```\nnull_indicator = 0;\nif (age is null) then\n     null_indicator = -1;\nendif;\ncallproc empcalc (age, null_indicator);\n```\n\n## Guidelines for Writing C Procedures\n\nUse the following syntax when writing a C procedure:\n\n```c\nprocname([parameters])\n{\n           processing statements\n}\n```\n\n> Note: You cannot name your C procedure \"main,\" and the procedure must not be static. You can call any C procedure from 4GL except the \"main\" function.\n\nFollow these guidelines for passing parameters to C procedures:\n\n- Pass an integer as four bytes by value (or by reference if byref is specified).\n- Pass a smallint as four bytes by value (or by reference if byref is specified).\n- Pass a float as a double-format float by value (or by reference, if byref is specified).\n\nTo ensure full portability, pass all floating point parameters to C procedures using the byref qualifier. For example, the following code fragment declares some variables and calls a C procedure, passing the procedure a floating-point parameter:\n\n```c\n/* variable declarations */\ntest_float = float;\ntest_integer = integer;\ntest_return = integer\n...\ntest_return = callproc myCproc (test_integer,\n                             byref(test_float));\n```\n\nThe corresponding C procedure is declared as follows:\n\n```c\nLong\nmyCproc (ivalue, fvalue)\nlong ivalue;\ndouble *fvalue;\n{\n     processing statements\n}\n```\n\n- Pass a string as a pointer to a null-terminated string as follows:\n  - Pass fixed-length string types (c, char) with trailing blanks up to their full length.\n  - Pass variable-length string types (text, varchar) without trailing blanks.\n\n- In this call to a procedure \"q\":\n\n```c\ncallproc q (1 + 2, 2.3, 'This is a string');\n```\n\nthe following declarations are required:\n\n```c\nq(x, y, z)\nlong x;\ndouble y; char *z;\n{...\n```\n\nTo receive x and y that are passed by reference, make the following changes to their formal argument declarations:\n\n```c\nlong *x;\ndouble *y;\n```\n\nNo changes are necessary to receive z that is passed by reference.",
            "```c\nlong *x;\ndouble *y;\n```\n\nNo changes are necessary to receive z that is passed by reference.\n\nA C procedure must return an int, a long, a double, or a char * value, as shown in the following examples.\n\n- To return an integer:\n\n```c\nint\nreti()\n{\nreturn 10;\n}\n```\n\n- To return a floating-point value:\n\n```c\ndouble\nretf()\n{\nreturn 10.5;\n}\n```\n\n- To return a character string:\n\n```c\nchar *\nrets()\n{\nreturn \"Returned from rets\";\n}\n```\n\nAny C procedure that returns a char * value to 4GL must return a pointer to a valid address (a string constant or static or global character buffer). The procedure cannot return a pointer to a local character buffer."
        ]
    },
    {
        "instruction": "Can you explain how nullable types are handled when passing them between 3GL and 4GL in OpenROAD?",
        "input": "",
        "output": "When a 4GL variable containing a null value is passed to a 3GL procedure, it causes a runtime error. Use the ifnull function and the is null comparison operator to pass nullable types between 3GL and 4GL in OpenROAD. For example:\n```4gl\nifnull (v1, v2)\n```\nThis reference returns the value of v1 if v1 is not null; otherwise, it returns the value of v2. The variables v1 and v2 must be the same data type. You can use the impossible value or a separate indicator variable to indicate a null argument in 3GL procedures.",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->3GL_procedures",
        "task_description": "Explain the features and creation process of 3GL procedures in Actian 4GL SQL.",
        "document": [
            "# 3GL Procedures\n\nA 3GL procedure is a procedure written in a third-generation language, such as C, that you can call by name from a script or 4GL procedure. 3GL procedures are used to perform operations that are outside the scope of OpenROAD but are available from a 3GL.\n\nYou maintain and compile 3GL procedures outside of OpenROAD. For more information about how to register 3GL procedures in an application, see the Workbench User Guide.\n\nThe following subsections describe how to declare parameters for 3GL procedures. They also provide language-specific information about coding the procedures. For more information about calling 3GL procedures, see Using 3GL in Your Application.\n\n## 3GL Parameters\n\nOpenROAD lets you pass simple variables to a 3GL procedure. You can also pass objects and arrays as described in the Language Reference Guide online help and in Using 3GL in Your Application. When you pass values to a 3GL procedure, the data type of the values must match the data types of the parameters receiving them in the procedure.\n\nThe following table lists the 4GL simple data types and describes their corresponding 3GL data type declarations:\n\n| 4GL Data Type | Host Variable Declaration |\n|---------------|---------------------------|\n| Char | Fixed-length, null-terminated character string. The size is determined by field size or declared variable length. Data entered into the field is padded with blank characters up to its full declared length before being passed to the 3GL procedure. |\n| Varchar | Variable-length, null-terminated character string. Unlike char type, varchar variables are not extended with blank characters before being passed to the 3GL procedure. |\n| date | Fixed-length, 25-byte, null-terminated character string |\n| money | Double |\n| float, f | Double |\n| integer | Long, 4-byte integer |\n| smallint | Integer, 4-byte integer |\n\nYou can use the byref option with any variable that you pass to a 3GL procedure, regardless of the variable's data type.\n\nYou cannot pass a char or varchar variable that contains an embedded zero byte (hexadecimal'00') to a 3GL procedure. No runtime error occurs, but a truncated version of the 4GL variable may be passed.\n\nWhen a 4GL date variable passes to a 3GL procedure by name, or when the return type of a 3GL procedure is date, 4GL receives it back from the 3GL procedure as a 25-byte string and must then convert it to the internal date format. The date must be valid before the conversion can succeed.\n\nPassing a 4GL variable containing a null value to a 3GL procedure causes a runtime error. Use the ifnull function and is null comparison operator to pass nullable types between 3GL and 4GL, for example:\n\n```\nifnull (v1, v2)\n```\n\nThis reference returns the value of v1 if v1 is not null; otherwise, if v1 is null, it returns the value of v2. The variables v1 and v2 must be the same data type.\n\nIf an impossible value exists for the argument, use the impossible value to indicate a null:\n\n```\ncallproc empcalc (ifnull (age, -1));\n```\n\nIf no impossible value exists for the argument, pass a separate indicator variable to indicate a null argument:\n\n```\nnull_indicator = 0;\nif (age is null) then\n     null_indicator = -1;\nendif;\ncallproc empcalc (age, null_indicator);\n```\n\n## Guidelines for Writing C Procedures\n\nUse the following syntax when writing a C procedure:\n\n```c\nprocname([parameters])\n{\n           processing statements\n}\n```\n\n> Note: You cannot name your C procedure \"main,\" and the procedure must not be static. You can call any C procedure from 4GL except the \"main\" function.\n\nFollow these guidelines for passing parameters to C procedures:\n\n- Pass an integer as four bytes by value (or by reference if byref is specified).\n- Pass a smallint as four bytes by value (or by reference if byref is specified).\n- Pass a float as a double-format float by value (or by reference, if byref is specified).\n\nTo ensure full portability, pass all floating point parameters to C procedures using the byref qualifier. For example, the following code fragment declares some variables and calls a C procedure, passing the procedure a floating-point parameter:\n\n```c\n/* variable declarations */\ntest_float = float;\ntest_integer = integer;\ntest_return = integer\n...\ntest_return = callproc myCproc (test_integer,\n                             byref(test_float));\n```\n\nThe corresponding C procedure is declared as follows:\n\n```c\nLong\nmyCproc (ivalue, fvalue)\nlong ivalue;\ndouble *fvalue;\n{\n     processing statements\n}\n```\n\n- Pass a string as a pointer to a null-terminated string as follows:\n  - Pass fixed-length string types (c, char) with trailing blanks up to their full length.\n  - Pass variable-length string types (text, varchar) without trailing blanks.\n\n- In this call to a procedure \"q\":\n\n```c\ncallproc q (1 + 2, 2.3, 'This is a string');\n```\n\nthe following declarations are required:\n\n```c\nq(x, y, z)\nlong x;\ndouble y; char *z;\n{...\n```\n\nTo receive x and y that are passed by reference, make the following changes to their formal argument declarations:\n\n```c\nlong *x;\ndouble *y;\n```\n\nNo changes are necessary to receive z that is passed by reference.",
            "```c\nlong *x;\ndouble *y;\n```\n\nNo changes are necessary to receive z that is passed by reference.\n\nA C procedure must return an int, a long, a double, or a char * value, as shown in the following examples.\n\n- To return an integer:\n\n```c\nint\nreti()\n{\nreturn 10;\n}\n```\n\n- To return a floating-point value:\n\n```c\ndouble\nretf()\n{\nreturn 10.5;\n}\n```\n\n- To return a character string:\n\n```c\nchar *\nrets()\n{\nreturn \"Returned from rets\";\n}\n```\n\nAny C procedure that returns a char * value to 4GL must return a pointer to a valid address (a string constant or static or global character buffer). The procedure cannot return a pointer to a local character buffer."
        ]
    },
    {
        "instruction": "Can you demonstrate a simple example of declaring a C procedure that returns an integer in Actian 4GL SQL?",
        "input": "",
        "output": "To declare and create a C procedure in Actian 4GL SQL, follow these steps:\n```sql\n-- Step 1: Declare the function's data type, name, and return type\nDECLARE FUNCTION int_proc RETURNS INTEGER;\n\n-- Step 2: Define the body of the function using the C syntax (see examples in the document)\nCREATE FUNCTION int_proc AS EXTERNAL NAME c_int_return_proc;\n\n-- Here's an example of a C code for the int_proc procedure, which returns an integer value:\n\nint\nc_int_return_proc()\n{\n   return 10; // The number can be changed as desired.\n}\n```",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->3GL_procedures",
        "task_description": "Explain the features and creation process of 3GL procedures in Actian 4GL SQL.",
        "document": [
            "# 3GL Procedures\n\nA 3GL procedure is a procedure written in a third-generation language, such as C, that you can call by name from a script or 4GL procedure. 3GL procedures are used to perform operations that are outside the scope of OpenROAD but are available from a 3GL.\n\nYou maintain and compile 3GL procedures outside of OpenROAD. For more information about how to register 3GL procedures in an application, see the Workbench User Guide.\n\nThe following subsections describe how to declare parameters for 3GL procedures. They also provide language-specific information about coding the procedures. For more information about calling 3GL procedures, see Using 3GL in Your Application.\n\n## 3GL Parameters\n\nOpenROAD lets you pass simple variables to a 3GL procedure. You can also pass objects and arrays as described in the Language Reference Guide online help and in Using 3GL in Your Application. When you pass values to a 3GL procedure, the data type of the values must match the data types of the parameters receiving them in the procedure.\n\nThe following table lists the 4GL simple data types and describes their corresponding 3GL data type declarations:\n\n| 4GL Data Type | Host Variable Declaration |\n|---------------|---------------------------|\n| Char | Fixed-length, null-terminated character string. The size is determined by field size or declared variable length. Data entered into the field is padded with blank characters up to its full declared length before being passed to the 3GL procedure. |\n| Varchar | Variable-length, null-terminated character string. Unlike char type, varchar variables are not extended with blank characters before being passed to the 3GL procedure. |\n| date | Fixed-length, 25-byte, null-terminated character string |\n| money | Double |\n| float, f | Double |\n| integer | Long, 4-byte integer |\n| smallint | Integer, 4-byte integer |\n\nYou can use the byref option with any variable that you pass to a 3GL procedure, regardless of the variable's data type.\n\nYou cannot pass a char or varchar variable that contains an embedded zero byte (hexadecimal'00') to a 3GL procedure. No runtime error occurs, but a truncated version of the 4GL variable may be passed.\n\nWhen a 4GL date variable passes to a 3GL procedure by name, or when the return type of a 3GL procedure is date, 4GL receives it back from the 3GL procedure as a 25-byte string and must then convert it to the internal date format. The date must be valid before the conversion can succeed.\n\nPassing a 4GL variable containing a null value to a 3GL procedure causes a runtime error. Use the ifnull function and is null comparison operator to pass nullable types between 3GL and 4GL, for example:\n\n```\nifnull (v1, v2)\n```\n\nThis reference returns the value of v1 if v1 is not null; otherwise, if v1 is null, it returns the value of v2. The variables v1 and v2 must be the same data type.\n\nIf an impossible value exists for the argument, use the impossible value to indicate a null:\n\n```\ncallproc empcalc (ifnull (age, -1));\n```\n\nIf no impossible value exists for the argument, pass a separate indicator variable to indicate a null argument:\n\n```\nnull_indicator = 0;\nif (age is null) then\n     null_indicator = -1;\nendif;\ncallproc empcalc (age, null_indicator);\n```\n\n## Guidelines for Writing C Procedures\n\nUse the following syntax when writing a C procedure:\n\n```c\nprocname([parameters])\n{\n           processing statements\n}\n```\n\n> Note: You cannot name your C procedure \"main,\" and the procedure must not be static. You can call any C procedure from 4GL except the \"main\" function.\n\nFollow these guidelines for passing parameters to C procedures:\n\n- Pass an integer as four bytes by value (or by reference if byref is specified).\n- Pass a smallint as four bytes by value (or by reference if byref is specified).\n- Pass a float as a double-format float by value (or by reference, if byref is specified).\n\nTo ensure full portability, pass all floating point parameters to C procedures using the byref qualifier. For example, the following code fragment declares some variables and calls a C procedure, passing the procedure a floating-point parameter:\n\n```c\n/* variable declarations */\ntest_float = float;\ntest_integer = integer;\ntest_return = integer\n...\ntest_return = callproc myCproc (test_integer,\n                             byref(test_float));\n```\n\nThe corresponding C procedure is declared as follows:\n\n```c\nLong\nmyCproc (ivalue, fvalue)\nlong ivalue;\ndouble *fvalue;\n{\n     processing statements\n}\n```\n\n- Pass a string as a pointer to a null-terminated string as follows:\n  - Pass fixed-length string types (c, char) with trailing blanks up to their full length.\n  - Pass variable-length string types (text, varchar) without trailing blanks.\n\n- In this call to a procedure \"q\":\n\n```c\ncallproc q (1 + 2, 2.3, 'This is a string');\n```\n\nthe following declarations are required:\n\n```c\nq(x, y, z)\nlong x;\ndouble y; char *z;\n{...\n```\n\nTo receive x and y that are passed by reference, make the following changes to their formal argument declarations:\n\n```c\nlong *x;\ndouble *y;\n```\n\nNo changes are necessary to receive z that is passed by reference.",
            "```c\nlong *x;\ndouble *y;\n```\n\nNo changes are necessary to receive z that is passed by reference.\n\nA C procedure must return an int, a long, a double, or a char * value, as shown in the following examples.\n\n- To return an integer:\n\n```c\nint\nreti()\n{\nreturn 10;\n}\n```\n\n- To return a floating-point value:\n\n```c\ndouble\nretf()\n{\nreturn 10.5;\n}\n```\n\n- To return a character string:\n\n```c\nchar *\nrets()\n{\nreturn \"Returned from rets\";\n}\n```\n\nAny C procedure that returns a char * value to 4GL must return a pointer to a valid address (a string constant or static or global character buffer). The procedure cannot return a pointer to a local character buffer."
        ]
    },
    {
        "instruction": "What are the requirements for returning a character string from a C procedure in Actian 4GL SQL?",
        "input": "",
        "output": "For a C procedure to return a character string value to 4GL in Actian, do the following:\n- The C procedure should return a pointer to a valid address (a string constant or static or global character buffer).\n- It cannot return a pointer to a local character buffer.\n\nHere's an example of returning a string from a C procedure:\n```c\nchar *\nret_str()\n{\n   char str[] = \"Returned from ret_str\"; // A valid, non-local buffer\n   return str;\n}\n```",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->3GL_procedures",
        "task_description": "Explain the features and creation process of 3GL procedures in Actian 4GL SQL.",
        "document": [
            "# 3GL Procedures\n\nA 3GL procedure is a procedure written in a third-generation language, such as C, that you can call by name from a script or 4GL procedure. 3GL procedures are used to perform operations that are outside the scope of OpenROAD but are available from a 3GL.\n\nYou maintain and compile 3GL procedures outside of OpenROAD. For more information about how to register 3GL procedures in an application, see the Workbench User Guide.\n\nThe following subsections describe how to declare parameters for 3GL procedures. They also provide language-specific information about coding the procedures. For more information about calling 3GL procedures, see Using 3GL in Your Application.\n\n## 3GL Parameters\n\nOpenROAD lets you pass simple variables to a 3GL procedure. You can also pass objects and arrays as described in the Language Reference Guide online help and in Using 3GL in Your Application. When you pass values to a 3GL procedure, the data type of the values must match the data types of the parameters receiving them in the procedure.\n\nThe following table lists the 4GL simple data types and describes their corresponding 3GL data type declarations:\n\n| 4GL Data Type | Host Variable Declaration |\n|---------------|---------------------------|\n| Char | Fixed-length, null-terminated character string. The size is determined by field size or declared variable length. Data entered into the field is padded with blank characters up to its full declared length before being passed to the 3GL procedure. |\n| Varchar | Variable-length, null-terminated character string. Unlike char type, varchar variables are not extended with blank characters before being passed to the 3GL procedure. |\n| date | Fixed-length, 25-byte, null-terminated character string |\n| money | Double |\n| float, f | Double |\n| integer | Long, 4-byte integer |\n| smallint | Integer, 4-byte integer |\n\nYou can use the byref option with any variable that you pass to a 3GL procedure, regardless of the variable's data type.\n\nYou cannot pass a char or varchar variable that contains an embedded zero byte (hexadecimal'00') to a 3GL procedure. No runtime error occurs, but a truncated version of the 4GL variable may be passed.\n\nWhen a 4GL date variable passes to a 3GL procedure by name, or when the return type of a 3GL procedure is date, 4GL receives it back from the 3GL procedure as a 25-byte string and must then convert it to the internal date format. The date must be valid before the conversion can succeed.\n\nPassing a 4GL variable containing a null value to a 3GL procedure causes a runtime error. Use the ifnull function and is null comparison operator to pass nullable types between 3GL and 4GL, for example:\n\n```\nifnull (v1, v2)\n```\n\nThis reference returns the value of v1 if v1 is not null; otherwise, if v1 is null, it returns the value of v2. The variables v1 and v2 must be the same data type.\n\nIf an impossible value exists for the argument, use the impossible value to indicate a null:\n\n```\ncallproc empcalc (ifnull (age, -1));\n```\n\nIf no impossible value exists for the argument, pass a separate indicator variable to indicate a null argument:\n\n```\nnull_indicator = 0;\nif (age is null) then\n     null_indicator = -1;\nendif;\ncallproc empcalc (age, null_indicator);\n```\n\n## Guidelines for Writing C Procedures\n\nUse the following syntax when writing a C procedure:\n\n```c\nprocname([parameters])\n{\n           processing statements\n}\n```\n\n> Note: You cannot name your C procedure \"main,\" and the procedure must not be static. You can call any C procedure from 4GL except the \"main\" function.\n\nFollow these guidelines for passing parameters to C procedures:\n\n- Pass an integer as four bytes by value (or by reference if byref is specified).\n- Pass a smallint as four bytes by value (or by reference if byref is specified).\n- Pass a float as a double-format float by value (or by reference, if byref is specified).\n\nTo ensure full portability, pass all floating point parameters to C procedures using the byref qualifier. For example, the following code fragment declares some variables and calls a C procedure, passing the procedure a floating-point parameter:\n\n```c\n/* variable declarations */\ntest_float = float;\ntest_integer = integer;\ntest_return = integer\n...\ntest_return = callproc myCproc (test_integer,\n                             byref(test_float));\n```\n\nThe corresponding C procedure is declared as follows:\n\n```c\nLong\nmyCproc (ivalue, fvalue)\nlong ivalue;\ndouble *fvalue;\n{\n     processing statements\n}\n```\n\n- Pass a string as a pointer to a null-terminated string as follows:\n  - Pass fixed-length string types (c, char) with trailing blanks up to their full length.\n  - Pass variable-length string types (text, varchar) without trailing blanks.\n\n- In this call to a procedure \"q\":\n\n```c\ncallproc q (1 + 2, 2.3, 'This is a string');\n```\n\nthe following declarations are required:\n\n```c\nq(x, y, z)\nlong x;\ndouble y; char *z;\n{...\n```\n\nTo receive x and y that are passed by reference, make the following changes to their formal argument declarations:\n\n```c\nlong *x;\ndouble *y;\n```\n\nNo changes are necessary to receive z that is passed by reference.",
            "```c\nlong *x;\ndouble *y;\n```\n\nNo changes are necessary to receive z that is passed by reference.\n\nA C procedure must return an int, a long, a double, or a char * value, as shown in the following examples.\n\n- To return an integer:\n\n```c\nint\nreti()\n{\nreturn 10;\n}\n```\n\n- To return a floating-point value:\n\n```c\ndouble\nretf()\n{\nreturn 10.5;\n}\n```\n\n- To return a character string:\n\n```c\nchar *\nrets()\n{\nreturn \"Returned from rets\";\n}\n```\n\nAny C procedure that returns a char * value to 4GL must return a pointer to a valid address (a string constant or static or global character buffer). The procedure cannot return a pointer to a local character buffer."
        ]
    },
    {
        "instruction": "What are the requirements for a C procedure to be callable from Actian 4GL?",
        "input": "",
        "output": "To make a C procedure callable in Actian 4GL, it should adhere to these guidelines:\n- The procedure cannot be named \"main\".\n- Procedures cannot be static.\n- To return a char * value to 4GL, the procedure must return a pointer to a valid address (a string constant or static or global character buffer).",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->3GL_procedures",
        "task_description": "Explain the features and creation process of 3GL procedures in Actian 4GL SQL.",
        "document": [
            "# 3GL Procedures\n\nA 3GL procedure is a procedure written in a third-generation language, such as C, that you can call by name from a script or 4GL procedure. 3GL procedures are used to perform operations that are outside the scope of OpenROAD but are available from a 3GL.\n\nYou maintain and compile 3GL procedures outside of OpenROAD. For more information about how to register 3GL procedures in an application, see the Workbench User Guide.\n\nThe following subsections describe how to declare parameters for 3GL procedures. They also provide language-specific information about coding the procedures. For more information about calling 3GL procedures, see Using 3GL in Your Application.\n\n## 3GL Parameters\n\nOpenROAD lets you pass simple variables to a 3GL procedure. You can also pass objects and arrays as described in the Language Reference Guide online help and in Using 3GL in Your Application. When you pass values to a 3GL procedure, the data type of the values must match the data types of the parameters receiving them in the procedure.\n\nThe following table lists the 4GL simple data types and describes their corresponding 3GL data type declarations:\n\n| 4GL Data Type | Host Variable Declaration |\n|---------------|---------------------------|\n| Char | Fixed-length, null-terminated character string. The size is determined by field size or declared variable length. Data entered into the field is padded with blank characters up to its full declared length before being passed to the 3GL procedure. |\n| Varchar | Variable-length, null-terminated character string. Unlike char type, varchar variables are not extended with blank characters before being passed to the 3GL procedure. |\n| date | Fixed-length, 25-byte, null-terminated character string |\n| money | Double |\n| float, f | Double |\n| integer | Long, 4-byte integer |\n| smallint | Integer, 4-byte integer |\n\nYou can use the byref option with any variable that you pass to a 3GL procedure, regardless of the variable's data type.\n\nYou cannot pass a char or varchar variable that contains an embedded zero byte (hexadecimal'00') to a 3GL procedure. No runtime error occurs, but a truncated version of the 4GL variable may be passed.\n\nWhen a 4GL date variable passes to a 3GL procedure by name, or when the return type of a 3GL procedure is date, 4GL receives it back from the 3GL procedure as a 25-byte string and must then convert it to the internal date format. The date must be valid before the conversion can succeed.\n\nPassing a 4GL variable containing a null value to a 3GL procedure causes a runtime error. Use the ifnull function and is null comparison operator to pass nullable types between 3GL and 4GL, for example:\n\n```\nifnull (v1, v2)\n```\n\nThis reference returns the value of v1 if v1 is not null; otherwise, if v1 is null, it returns the value of v2. The variables v1 and v2 must be the same data type.\n\nIf an impossible value exists for the argument, use the impossible value to indicate a null:\n\n```\ncallproc empcalc (ifnull (age, -1));\n```\n\nIf no impossible value exists for the argument, pass a separate indicator variable to indicate a null argument:\n\n```\nnull_indicator = 0;\nif (age is null) then\n     null_indicator = -1;\nendif;\ncallproc empcalc (age, null_indicator);\n```\n\n## Guidelines for Writing C Procedures\n\nUse the following syntax when writing a C procedure:\n\n```c\nprocname([parameters])\n{\n           processing statements\n}\n```\n\n> Note: You cannot name your C procedure \"main,\" and the procedure must not be static. You can call any C procedure from 4GL except the \"main\" function.\n\nFollow these guidelines for passing parameters to C procedures:\n\n- Pass an integer as four bytes by value (or by reference if byref is specified).\n- Pass a smallint as four bytes by value (or by reference if byref is specified).\n- Pass a float as a double-format float by value (or by reference, if byref is specified).\n\nTo ensure full portability, pass all floating point parameters to C procedures using the byref qualifier. For example, the following code fragment declares some variables and calls a C procedure, passing the procedure a floating-point parameter:\n\n```c\n/* variable declarations */\ntest_float = float;\ntest_integer = integer;\ntest_return = integer\n...\ntest_return = callproc myCproc (test_integer,\n                             byref(test_float));\n```\n\nThe corresponding C procedure is declared as follows:\n\n```c\nLong\nmyCproc (ivalue, fvalue)\nlong ivalue;\ndouble *fvalue;\n{\n     processing statements\n}\n```\n\n- Pass a string as a pointer to a null-terminated string as follows:\n  - Pass fixed-length string types (c, char) with trailing blanks up to their full length.\n  - Pass variable-length string types (text, varchar) without trailing blanks.\n\n- In this call to a procedure \"q\":\n\n```c\ncallproc q (1 + 2, 2.3, 'This is a string');\n```\n\nthe following declarations are required:\n\n```c\nq(x, y, z)\nlong x;\ndouble y; char *z;\n{...\n```\n\nTo receive x and y that are passed by reference, make the following changes to their formal argument declarations:\n\n```c\nlong *x;\ndouble *y;\n```\n\nNo changes are necessary to receive z that is passed by reference.",
            "```c\nlong *x;\ndouble *y;\n```\n\nNo changes are necessary to receive z that is passed by reference.\n\nA C procedure must return an int, a long, a double, or a char * value, as shown in the following examples.\n\n- To return an integer:\n\n```c\nint\nreti()\n{\nreturn 10;\n}\n```\n\n- To return a floating-point value:\n\n```c\ndouble\nretf()\n{\nreturn 10.5;\n}\n```\n\n- To return a character string:\n\n```c\nchar *\nrets()\n{\nreturn \"Returned from rets\";\n}\n```\n\nAny C procedure that returns a char * value to 4GL must return a pointer to a valid address (a string constant or static or global character buffer). The procedure cannot return a pointer to a local character buffer."
        ]
    },
    {
        "instruction": "Explain the concept of passing by reference in C procedures.",
        "input": "",
        "output": "Passing by reference is a method for calling functions where you pass the address (pointer) of a variable rather than copying its value to the function. In this way, modifications made inside the function will affect the original variable outside it. Here's an example in C:\n```c\nvoid inc(long *x)\n{\n    (*x)++; // increment value of x pointed by *x\n}\nint main()\n{\n    long z = 10;\n    inc(&z);\n    printf(\"z is %d\\n\", z); // Prints 11\n}\n```\nIn this example, we declare a function called \"inc\" that receives a pointer to a long variable \"x\". We use the dereference operator (*) to modify the value of x pointed by *x. The main function initializes z as 10 and passes its address using &z. After calling the inc() function, we print out z in the main().",
        "taxonomy_path": "knowledge->programming_languages->procedures->procedures->3GL_procedures",
        "task_description": "Explain the features and creation process of 3GL procedures in Actian 4GL SQL.",
        "document": [
            "# 3GL Procedures\n\nA 3GL procedure is a procedure written in a third-generation language, such as C, that you can call by name from a script or 4GL procedure. 3GL procedures are used to perform operations that are outside the scope of OpenROAD but are available from a 3GL.\n\nYou maintain and compile 3GL procedures outside of OpenROAD. For more information about how to register 3GL procedures in an application, see the Workbench User Guide.\n\nThe following subsections describe how to declare parameters for 3GL procedures. They also provide language-specific information about coding the procedures. For more information about calling 3GL procedures, see Using 3GL in Your Application.\n\n## 3GL Parameters\n\nOpenROAD lets you pass simple variables to a 3GL procedure. You can also pass objects and arrays as described in the Language Reference Guide online help and in Using 3GL in Your Application. When you pass values to a 3GL procedure, the data type of the values must match the data types of the parameters receiving them in the procedure.\n\nThe following table lists the 4GL simple data types and describes their corresponding 3GL data type declarations:\n\n| 4GL Data Type | Host Variable Declaration |\n|---------------|---------------------------|\n| Char | Fixed-length, null-terminated character string. The size is determined by field size or declared variable length. Data entered into the field is padded with blank characters up to its full declared length before being passed to the 3GL procedure. |\n| Varchar | Variable-length, null-terminated character string. Unlike char type, varchar variables are not extended with blank characters before being passed to the 3GL procedure. |\n| date | Fixed-length, 25-byte, null-terminated character string |\n| money | Double |\n| float, f | Double |\n| integer | Long, 4-byte integer |\n| smallint | Integer, 4-byte integer |\n\nYou can use the byref option with any variable that you pass to a 3GL procedure, regardless of the variable's data type.\n\nYou cannot pass a char or varchar variable that contains an embedded zero byte (hexadecimal'00') to a 3GL procedure. No runtime error occurs, but a truncated version of the 4GL variable may be passed.\n\nWhen a 4GL date variable passes to a 3GL procedure by name, or when the return type of a 3GL procedure is date, 4GL receives it back from the 3GL procedure as a 25-byte string and must then convert it to the internal date format. The date must be valid before the conversion can succeed.\n\nPassing a 4GL variable containing a null value to a 3GL procedure causes a runtime error. Use the ifnull function and is null comparison operator to pass nullable types between 3GL and 4GL, for example:\n\n```\nifnull (v1, v2)\n```\n\nThis reference returns the value of v1 if v1 is not null; otherwise, if v1 is null, it returns the value of v2. The variables v1 and v2 must be the same data type.\n\nIf an impossible value exists for the argument, use the impossible value to indicate a null:\n\n```\ncallproc empcalc (ifnull (age, -1));\n```\n\nIf no impossible value exists for the argument, pass a separate indicator variable to indicate a null argument:\n\n```\nnull_indicator = 0;\nif (age is null) then\n     null_indicator = -1;\nendif;\ncallproc empcalc (age, null_indicator);\n```\n\n## Guidelines for Writing C Procedures\n\nUse the following syntax when writing a C procedure:\n\n```c\nprocname([parameters])\n{\n           processing statements\n}\n```\n\n> Note: You cannot name your C procedure \"main,\" and the procedure must not be static. You can call any C procedure from 4GL except the \"main\" function.\n\nFollow these guidelines for passing parameters to C procedures:\n\n- Pass an integer as four bytes by value (or by reference if byref is specified).\n- Pass a smallint as four bytes by value (or by reference if byref is specified).\n- Pass a float as a double-format float by value (or by reference, if byref is specified).\n\nTo ensure full portability, pass all floating point parameters to C procedures using the byref qualifier. For example, the following code fragment declares some variables and calls a C procedure, passing the procedure a floating-point parameter:\n\n```c\n/* variable declarations */\ntest_float = float;\ntest_integer = integer;\ntest_return = integer\n...\ntest_return = callproc myCproc (test_integer,\n                             byref(test_float));\n```\n\nThe corresponding C procedure is declared as follows:\n\n```c\nLong\nmyCproc (ivalue, fvalue)\nlong ivalue;\ndouble *fvalue;\n{\n     processing statements\n}\n```\n\n- Pass a string as a pointer to a null-terminated string as follows:\n  - Pass fixed-length string types (c, char) with trailing blanks up to their full length.\n  - Pass variable-length string types (text, varchar) without trailing blanks.\n\n- In this call to a procedure \"q\":\n\n```c\ncallproc q (1 + 2, 2.3, 'This is a string');\n```\n\nthe following declarations are required:\n\n```c\nq(x, y, z)\nlong x;\ndouble y; char *z;\n{...\n```\n\nTo receive x and y that are passed by reference, make the following changes to their formal argument declarations:\n\n```c\nlong *x;\ndouble *y;\n```\n\nNo changes are necessary to receive z that is passed by reference.",
            "```c\nlong *x;\ndouble *y;\n```\n\nNo changes are necessary to receive z that is passed by reference.\n\nA C procedure must return an int, a long, a double, or a char * value, as shown in the following examples.\n\n- To return an integer:\n\n```c\nint\nreti()\n{\nreturn 10;\n}\n```\n\n- To return a floating-point value:\n\n```c\ndouble\nretf()\n{\nreturn 10.5;\n}\n```\n\n- To return a character string:\n\n```c\nchar *\nrets()\n{\nreturn \"Returned from rets\";\n}\n```\n\nAny C procedure that returns a char * value to 4GL must return a pointer to a valid address (a string constant or static or global character buffer). The procedure cannot return a pointer to a local character buffer."
        ]
    }
]