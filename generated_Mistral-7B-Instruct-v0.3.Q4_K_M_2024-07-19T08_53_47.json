[
    {
        "instruction": "Explain the use of simple lists in variable_list for the fetch statement.",
        "input": "",
        "output": "You can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "Explain how to fetch column values out of order using the fetch statement.",
        "input": "",
        "output": "You must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "What happens if a fetch statement finds no rows to fetch?",
        "input": "",
        "output": "If a `fetch` statement finds no rows to fetch, it sets the `State` attribute of the `CursorObject` to `CS_NO_MORE_ROWS`. Additionally, 4GL does not change the variables and sets the value of the `iirowcount` system variable to zero. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "What is the difference between specifying column names in a fetch statement and not specifying them?",
        "input": "",
        "output": "If you specify the column names when fetching the column values out of order, that is, not in the same order in which they were specified in the select statement, you must do so. When you specify the column names, you can fetch the columns in any order. If you do not specify the column names, OpenROAD reports a mismatch in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "Explain the significance of the State attribute of the CursorObject class when a fetch statement is unsuccessful or there are no more rows to fetch.",
        "input": "",
        "output": "When a fetch statement is unsuccessful or there are no more rows to fetch, 4GL sets the value of the `State` attribute of the `CursorObject` class to `CS_NO_MORE_ROWS`. This means that all rows have been fetched. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "Explain what happens when a mismatch is found between the data types of the variables and the values that are assigned to them by a fetch statement.",
        "input": "",
        "output": "OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "Describe how the `fetch` statement moves the cursor forward one row in the result table.",
        "input": "",
        "output": "The `fetch` statement retrieves a single row from the open cursor and advances the cursor to the next row. It is used to retrieve the rows returned by an SQL query or a stored procedure and assigns the values from the specified columns into 4GL variables. This allows you to process the data as needed.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "What happens if the fetch statement fails? Provide an example of what might cause this failure.",
        "input": "",
        "output": "If the `fetch` statement fails, 4GL sets the value of the `iirowcount` system variable to zero and does not change the variables. The `State` attribute is also set to indicate that there was an error. An example of what might cause a failure is if there are no more rows to fetch or if the data types of the variables and the column names are incompatible.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "What is the maximum number of variables in the variable_list for the fetch statement?",
        "input": "",
        "output": "The `fetch` statement cannot contain more variables than there are select expressions in the `open` statement.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "Explain how to retrieve all of the values in a result row using the Fetch statement.",
        "input": "",
        "output": "To retrieve all of the values in a result row, you can specify a list of variables that match the order specified by the select statement in your `open` statement. For example:\n```\nfetch cursor_variable into :variable1, :variable2, :variable3;\n```\nThis retrieves the values from all columns specified in the select statement and loads them into the specified variables in the given order.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "Explain how to retrieve a subset of the values that begins with the first value retrieved by the select statement and continues in the order listed in the select (stopping before all are retrieved).",
        "input": "",
        "output": "To retrieve a subset of the values, you can specify a list of variables starting from the first value and continuing in the order listed in the select statement. The list should contain fewer variables than there are columns specified in the select statement, but not more. For example:\n```\nfetch cursor_variable into :variable1, :variable2;\n```\nThis retrieves the values for the first two columns specified in the select statement and stops before retrieving all of them.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "Provide an example of fetching a subset of column values out of order using the Fetch statement.",
        "input": "",
        "output": "If you select columns A, B, C, and D and then want to fetch columns B and D out of order, you must specify the column names. For example:\n```\nfetch cursor_variable into :variableB = B, :variableD = D;\n```",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "Explain how OpenROAD checks the compatibility of variables and column names during runtime for the Fetch statement.",
        "input": "",
        "output": "OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, it reports an error in the `iierrornumber` system variable although the row is still fetched and becomes the current row.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "Provide an example of how to fetch multiple columns using column names and format the variable_list as in the document examples.",
        "input": "",
        "output": "To fetch multiple columns using column names, you can use this syntax:\n```sql\nfetch cursor_variable into :column1 = column_name1, :column2 = column_name2;\n```\nFor example:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\n```",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "Explain how to check the number of rows that have been successfully fetched using `RowCount` attribute of the `CursorObject` class.",
        "input": "",
        "output": "You can use the following code snippet to check the number of rows that have been retrieved:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif(emp_cursor.RowCount > 0) {\n   /* The row has been fetched successfully */\n} else {\n   /* Fetch operation failed or there are no more rows to fetch */\n}\n```",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "Describe what happens when the fetch statement finds no rows to fetch and its impact on the State attribute of the CursorObject class.",
        "input": "",
        "output": "When a `fetch` statement finds no rows to fetch, it sets the `State` attribute of the `CursorObject` class to `CS_NO_MORE_ROWS`. This indicates that there are no more rows left in the cursor. You can check the `State` attribute after each fetch to determine if there are more rows to fetch. If a `fetch` statement finds no rows to fetch, it does not change the variables and sets the value of the `iirowcount` system variable to zero. This system variable is used to check the number of rows that have been successfully fetched.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "What do you need to check if all rows have been fetched using a fetch statement?",
        "input": "",
        "output": "You can check the `State` attribute of the `CursorObject`. If its value is equal to `CS_NO_MORE_ROWS`, all rows have been fetched.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "Explain how you can use the fetch statement to put the values from specified columns into variables.",
        "input": "",
        "output": "To put the values from specified columns into variables, you need to format the `variable_list` parameter in the `fetch` statement using either of the following formats:\n- `:variable{, :variable}` or\n- `:variable = columnname{, :variable = columnname}`\n\nYou cannot mix the two formats.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "Provide an example of using a `fetch` statement when retrieving a subset of values from a row in the order specified.",
        "input": "",
        "output": "Here's an example that retrieves the first two columns from a result table in the specified order:\n```sql\nDECLARE emp_cursor CURSOR FOR SELECT name, age FROM employees;\nOPEN emp_cursor;\nFETCH emp_cursor INTO :emp_name = name, :emp_age = age;\nIF NOT EMPTY emp_name AND NOT EMPTY emp_age THEN\n   DISPLAY \"Employee Name: \", emp_name, \" and Age: \", emp_age;\nEND IF;\nCLOSE emp_cursor;\n```",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "Explain how you can check the number of rows that have been retrieved using the `RowCount` attribute of the `CursorObject` class.",
        "input": "",
        "output": "To check the number of rows that have been retrieved, you should first open the cursor object and then check its `RowCount` attribute. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch. After every fetch operation, you can see the updated value of the `RowCount` attribute to determine how many rows have been fetched.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "What happens to the value of `iirowcount` variable if the fetch statement is unsuccessful or there are no more rows to fetch?",
        "input": "",
        "output": "If the fetch statement is unsuccessful or there are no more rows to fetch, 4GL sets the value of the `iirowcount` system variable to zero.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "Describe how you can check the `State` attribute after each fetch to determine if there are more rows to fetch.",
        "input": "",
        "output": "To check the `State` attribute after each fetch to determine if there are more rows to fetch, you need to access the `State` attribute of the `CursorObject`. Here's an example:\n```sql\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "How does OpenROAD handle compatibility between the variables and column names when using the `fetch` statement?",
        "input": "",
        "output": "OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "Explain the syntax of the Fetch statement in Actian 4GL SQL.",
        "input": "",
        "output": "The `fetch` statement retrieves a row from an open cursor and loads it into 4GL variables. The syntax is as follows:\n```\nfetch cursor_variable into variable_list;\n```\nReplace `cursor_variable` with the reference variable that points to an object of type `CursorObject` (which must be open), and replace `variable_list` with a list of variables that will hold the retrieved values. You can specify this list in two different formats:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "Explain how to fetch columns out of order using the Fetch statement in Actian 4GL SQL.",
        "input": "",
        "output": "To fetch columns out of order (i.e., not in the same order they were specified in the `open` statement), you must specify the column names in the `variable_list`. For example, if you selected columns A, B, C, and D and then want to fetch columns B and D, you would write:\n```\nfetch cursor_variable into :B = b, :D = d;\n```\nWhen you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list`.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "Can you explain the difference between the simple list of variables and specifying the column names when using the fetch statement?",
        "input": "",
        "output": "When using a simple list of variables, you can retrieve all the values in the result row, in the order specified by the select statement or retrieve a subset of the values. However, if you want to fetch the column values out of order or need to specify the columns that are not in the same order as the select statement, you must specify the column names.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "What are the parameters required for the Fetch statement in Actian 4GL SQL?",
        "input": "",
        "output": "The `fetch` statement has two parameters:\n- cursor\\_variable: Specifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n- variable\\_list: Specifies the variables into which you load your data. The format for this list can be either:\n  ```sql\n  :variable{, :variable}\n  ```\n  or\n  ```sql\n  :variable = columnname{, :variable = columnname}\n  ```",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "What happens if there is a mismatch between the variable data types and column names in Actian 4GL SQL?",
        "input": "",
        "output": "If there is a mismatch between the data types of the variables and values assigned to them, or between the variables and column names, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched. In other words, the mismatch doesn't prevent the fetch from being completed; it just means that there's an error.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "Provide an example of fetching all of the values in a result row using the simple list format.",
        "input": "",
        "output": "To fetch all of the values in a result row using the simple list format, you can use the following example:\n```sql\nfetch emp_cursor into :emp_name, :emp_age, :emp_salary;\n```",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "Explain what happens if there is a mismatch between the data types of the variables and the column names.",
        "input": "",
        "output": "If there is a mismatch between the data types of the variables and the values that are assigned to them, OpenROAD reports it in the `iierrornumber` system variable. However, the row is still fetched and becomes the current row.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "Explain what happens to the retrieved row after a successful fetch.",
        "input": "",
        "output": "After a successful fetch, the retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor. The values from the specified columns are loaded into the specified variables.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "What are the compatibility requirements when using the fetch statement?",
        "input": "",
        "output": "OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row. The data types of the variables and the values that are assigned to them must be compatible.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "What is the syntax of the `fetch` statement in Actian 4GL SQL?",
        "input": "",
        "output": "The syntax of the fetch statement in Actian 4GL SQL is as follows:\n```\nfetch cursor_variable into variable_list;\n```",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "How can you fetch a subset of columns from the current row retrieved by the select statement?",
        "input": "",
        "output": "You can specify a list of variables to load the data into, and only retrieve the required columns. For example:\n```sql\nfetch emp_cursor into :emp_name = name;\n```\nThis will fetch only the `name` column from the current row. You can also mix retrieving all of the values in the order specified by the select statement with retrieving a subset of the values out of order using column names.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "Can you give an example of how to check if there are remaining rows after a fetch statement in Actian 4GL SQL?",
        "input": "",
        "output": "To check if there are remaining rows after a fetch statement, you can use the following code:\n\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n      /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n      /* All rows have been fetched. */\n...\nelse\n      /* There is an error. */\nendif;\n```",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "Explain when you should use column names in the `fetch` statement instead of their order in Actian 4GL SQL.",
        "input": "",
        "output": "You should use column names in the `fetch` statement when you need to fetch columns out of order, that is, not in the same order they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns D and B, you must specify the column names (D and B). When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the column names in the variable_list of your `fetch` statement.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "Explain when it is necessary to specify column names in the fetch statement and provide an example.",
        "input": "",
        "output": "It is necessary to specify column names in the fetch statement whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names like this:\n```sql\nfetch emp_cursor into :emp_name = null, :emp_birthday = birthday, :emp_department = department;\n```\nIn this example, the `emp_name` variable is not used because it does not correspond to any column in the current row. Instead, it is set to `null`.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "Describe what happens when there are no more rows to fetch using a fetch statement and provide an example.",
        "input": "",
        "output": "If there are no more rows to fetch using the fetch statement, OpenROAD sets the value of the `iirowcount` system variable to zero and does not change the variables. Additionally, the `State` attribute of the CursorObject is set to `CS_NO_MORE_ROWS`. Here's an example:\n```sql\nwhile 1 do\n    fetch emp_cursor into :emp_name, :emp_age;\n    if emp_cursor.RowCount = 0 then exit; end if;\n    /* Process the fetched row */\nend while;\n```\nIn this example, the `while` loop continues until there are no more rows to fetch. When there are no more rows to fetch, the `iirowcount` is set to zero and the loop exits.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "What should be done if there is a mismatch between the data types of the variables and the column names?",
        "input": "",
        "output": "OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row. To handle this error, you can implement exception handling or customize your application to accommodate the unexpected data type.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "Explain how to check whether there are more rows left in a cursor after a successful fetch using the `State` attribute of the `CursorObject` class.",
        "input": "",
        "output": "To check whether there are more rows left in a cursor after a successful fetch, you can inspect the `State` attribute of the `CursorObject` object. Here's an example:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif(emp_cursor.State == CS_CURRENT) {\n  /* There is at least one more row left in the cursor */\n} elseif(emp_cursor.State == CS_NO_MORE_ROWS) {\n  /* All rows have been fetched */\n} else {\n  /* Error or unexpected state encountered */\n}\n```",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    },
    {
        "instruction": "Explain what is the purpose of using a simple list of variables in a fetch statement.",
        "input": "",
        "output": "When you use a simple list of variables in a `fetch` statement, you can retrieve all of the values in the result row or just a subset of them. If you specify fewer variables than there are select expressions in the `open` statement, you'll only fetch a subset. The order of the retrieved data will be the same as the order specified by the select statement. Here is an example:\n```sql\nfetch emp_cursor into :emp_name, :emp_age, :emp_salary;\n```\nIn this case, all three columns (name, age, and salary) are fetched in that specific order. If you have fewer variables, the missing ones will be skipped during the fetch operation.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->fetch_statements",
        "task_description": "Explain the features and parameters of the fetch statement in Actian 4GL SQL.",
        "document": [
            "# Fetch Statement\n\nThis statement retrieves a row from an open cursor and loads it into 4GL variables.\n\n## Syntax\n\n```\nfetch cursor_variable into variable_list;\n```\n\nYou can use the `fetch` statement to:\n- Move the cursor forward one row in the select statement's result table\n- Put the values from the specified columns into the specified variables\n- Set the `State` and `RowCount` attributes of the `CursorObject` class\n\nAfter a successful fetch, you can process the values in the variables any way you want. To display the cursor data in the window, you can fetch it into the variables that are associated with the fields on your form.\n\nThe retrieved row becomes the current row, that is, the row affected by the next `update cursor` or `delete cursor` statement for this cursor.\n\nYou can use a simple list of variables whenever you:\n- Retrieve all of the values in the result row, in the order specified by the select statement\n- Retrieve a subset of the values that begins with the first value retrieved by the select and continues in the order listed in the select (stopping before all are retrieved)\n\nYou must specify the column names whenever you fetch the column values out of order, that is, not in the same order in which they were specified in the select statement. For example, if you select columns A, B, C, and D and then fetch columns B and D, you must specify the column names. When you specify the column names, you can fetch the columns in any order. If you retrieved values into `resultnames` in your select statement, use these `resultnames` as the `columnnames` in the `variable_list` of your `fetch` statement.\n\nThe `fetch` statement can contain fewer variables than there are select expressions in the `open` statement, but it cannot contain more. Whether you specify the column names or not, the data types of the variables and the values that are assigned to them must be compatible. OpenROAD does not check the compatibility of the variables and column names until runtime. If there is a mismatch, OpenROAD reports it in the `iierrornumber` system variable, although the row is still fetched and becomes the current row.\n\nIf the `fetch` statement is successful, 4GL sets the value of the `iirowcount` system variable to one. If the `fetch` statement is unsuccessful or there are no more rows to fetch, 4GL sets `iirowcount` to zero and does not change the variables. Additionally, if a `fetch` statement finds no rows to fetch, it sets the `State` attribute to `CS_NO_MORE_ROWS`. Consequently, you can check the `State` attribute after each fetch to determine if there are more rows to fetch.\n\nTo find out how many rows have been successfully fetched, check the `RowCount` attribute of the `CursorObject` class. OpenROAD sets this attribute to zero whenever the cursor object is opened and increments it after each successful fetch.\n\nYou must issue any `fetch` statements for a cursor in the same DBMS session in which you opened the cursor.\n\nFor more information and examples of specifying columns in a `fetch` statement, and for a description of how to use cursors in OpenROAD, see the Programming Guide.\n\n## Parameters\n\nThis statement has the following parameters:\n\n### cursor_variable\nSpecifies a reference variable that points to an object of type `CursorObject`. This cursor must be open.\n\n### variable_list\nSpecifies the variables into which you load your data. You can format this list as:\n```\n:variable{, :variable}\n```\nor\n```\n:variable = columnname{, :variable = columnname}\n```\nYou cannot mix the two formats.\n\n## Examples\n\nCheck the `State` attribute of the `CursorObject` to determine whether there are remaining rows:\n```sql\nfetch emp_cursor into :emp_name = name, :emp_age = age;\nif emp_cursor.State = CS_CURRENT then\n          /* A new row has been fetched. */\n...\nelseif emp_cursor.State = CS_NO_MORE_ROWS then\n          /* All rows have been fetched. */\n...\nelse\n          /* There is an error. */\nendif;\n```\n\nCheck the `RowCount` attribute of the `CursorObject` to check the number of rows that have been retrieved:\n```sql\n/* Fetches no more than 5 rows from CursorObject */\nif emp_cursor.RowCount <= 5 then\n     fetch emp_cursor into :emp_name = name, :emp_age = age;\nelse\n     close emp_cursor;\nendif;\n```"
        ]
    }
]